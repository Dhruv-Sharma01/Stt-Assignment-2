hash,message,filename,source_code_before,source_code_current,diff,llm_inference,rectified_message,rectified_message,rectification_type,rq1_similarity,rq2_length,rq3_keyword,MI_Before,MI_After,CC_Before,CC_After,LOC_Before,LOC_After,MI_Change,CC_Change,LOC_Change
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",logo-full.svg,,"<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc=""http://purl.org/dc/elements/1.1/""
   xmlns:cc=""http://creativecommons.org/ns#""
   xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#""
   xmlns:svg=""http://www.w3.org/2000/svg""
   xmlns=""http://www.w3.org/2000/svg""
   xmlns:sodipodi=""http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd""
   xmlns:inkscape=""http://www.inkscape.org/namespaces/inkscape""
   width=""460""
   height=""180""
   id=""svg2""
   version=""1.1""
   inkscape:version=""0.47 r22583""
   sodipodi:docname=""logo.svg"">
  <defs
     id=""defs4"">
    <inkscape:perspective
       sodipodi:type=""inkscape:persp3d""
       inkscape:vp_x=""0 : 526.18109 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_z=""744.09448 : 526.18109 : 1""
       inkscape:persp3d-origin=""372.04724 : 350.78739 : 1""
       id=""perspective10"" />
    <inkscape:perspective
       id=""perspective2824""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2840""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2878""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2894""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2910""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2926""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective2976""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective3020""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective3036""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective3052""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
    <inkscape:perspective
       id=""perspective3866""
       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
       inkscape:vp_z=""1 : 0.5 : 1""
       inkscape:vp_y=""0 : 1000 : 0""
       inkscape:vp_x=""0 : 0.5 : 1""
       sodipodi:type=""inkscape:persp3d"" />
  </defs>
  <sodipodi:namedview
     id=""base""
     pagecolor=""#ffffff""
     bordercolor=""#666666""
     borderopacity=""1.0""
     inkscape:pageopacity=""0.0""
     inkscape:pageshadow=""2""
     inkscape:zoom=""0.98994949""
     inkscape:cx=""240.32415""
     inkscape:cy=""-37.836532""
     inkscape:document-units=""px""
     inkscape:current-layer=""layer1""
     showgrid=""false""
     inkscape:window-width=""1680""
     inkscape:window-height=""998""
     inkscape:window-x=""-8""
     inkscape:window-y=""-8""
     inkscape:window-maximized=""1"" />
  <metadata
     id=""metadata7"">
    <rdf:RDF>
      <cc:Work
         rdf:about="""">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource=""http://purl.org/dc/dcmitype/StillImage"" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label=""Layer 1""
     inkscape:groupmode=""layer""
     id=""layer1""
     transform=""translate(-27.820801,-24.714976)"">
    <path
       style=""fill:#000000""
       d=""M 96.944917,182.03377 C 89.662681,176.30608 81.894549,170.81448 76.586317,163.08166 65.416842,149.44499 56.816875,133.6567 50.937585,117.06515 47.383955,106.27654 46.166898,94.709824 41.585799,84.338096 c -4.792287,-7.533044 0.821224,-15.767897 9.072722,-18.16242 3.673742,-0.705104 10.133327,-4.170258 2.335951,-1.693539 -6.990592,5.128871 -7.667129,-4.655603 -0.498823,-5.27517 4.892026,-0.650249 6.692895,-4.655044 5.019966,-8.260251 -5.251326,-3.424464 12.733737,-7.18801 3.684373,-12.297799 -9.426987,-10.170666 13.186339,-12.128546 7.607283,-0.577786 -1.335447,8.882061 15.801226,-1.627907 11.825117,8.628945 4.041283,4.925694 15.133562,1.1211 14.85838,8.031392 5.887092,0.404678 7.907562,5.358061 13.433992,5.738347 5.72759,2.586557 16.1108,4.624792 18.0598,11.079149 -5.68242,4.498756 -18.84089,-9.292674 -19.47305,3.160397 1.71659,18.396078 1.27926,37.346439 8.00986,54.864989 3.18353,10.60759 10.9012,18.95779 17.87109,27.21946 6.66875,8.09126 15.70186,13.78715 24.90885,18.58338 8.07647,3.80901 16.78383,6.33528 25.58583,7.92044 3.5701,-2.7307 9.87303,-12.8828 15.44238,-8.60188 0.26423,4.81007 -11.0541,10.05512 -0.53248,9.5235 6.17819,-1.86378 10.46336,4.77803 15.55099,-1.21289 4.68719,5.55206 19.48197,-3.54734 16.14693,7.80115 -4.50972,2.90955 -11.08689,1.15142 -15.60404,5.15397 -7.44757,-3.71979 -13.37691,3.32843 -21.6219,2.43707 -9.15641,1.64002 -18.4716,2.30204 -27.75473,2.31642 -15.22952,-1.20328 -30.78158,-1.71049 -45.26969,-7.01291 -8.16166,-2.37161 -16.12649,-7.01887 -23.299683,-11.66829 z m 12.862043,5.5729 c 7.9696,3.44651 15.76243,7.07889 24.49656,8.17457 13.85682,1.92727 28.16653,4.89163 42.07301,2.18757 -6.2939,-2.84199 -12.80077,1.10719 -19.07096,-2.0322 -7.52033,1.61821 -15.59049,-0.41223 -23.23574,-1.41189 -8.69395,-3.87259 -18.0762,-6.53549 -26.21772,-11.56219 -10.173155,-3.71578 5.26142,4.76524 8.00873,5.45214 6.35952,3.60969 -6.99343,-1.85044 -8.87589,-3.35101 -5.32648,-2.9879 -6.00529,-2.36357 -0.52745,0.67085 1.10332,0.64577 2.19359,1.32226 3.34946,1.87216 z M 94.642259,176.88976 c 7.722781,2.86052 -0.03406,-5.43082 -3.572941,-4.94904 -1.567906,-2.72015 -5.9903,-4.43854 -2.870721,-5.89973 -5.611524,1.9481 -5.878319,-7.40814 -8.516004,-6.07139 -5.936516,-1.87454 -2.310496,-8.51501 -9.381929,-12.59292 -0.645488,-4.29697 -7.02577,-8.02393 -9.060801,-14.50525 -0.898786,-3.31843 -7.208336,-12.84783 -3.332369,-3.97927 3.300194,8.53747 9.106618,15.84879 13.93868,23.15175 3.752083,6.95328 8.182497,14.22026 15.015767,18.55788 2.303436,2.20963 4.527452,5.59533 7.780318,6.28797 z M 72.39456,152.46355 c 0.26956,-1.16626 1.412424,2.52422 0,0 z m 31.49641,27.85526 c 1.71013,-0.76577 -2.45912,-0.96476 0,0 z m 4.19228,1.52924 c -0.43419,-2.1116 -1.91376,1.18074 0,0 z m 5.24749,2.18891 c 2.49828,-2.37871 -3.85009,-1.49983 0,0 z m 8.99389,5.01274 c 1.51811,-2.2439 -4.85872,-0.84682 0,0 z m -17.2707,-12.03933 c 3.88031,-2.51023 -5.01186,-0.0347 0,0 z m 3.9366,1.96293 c -0.11004,-1.32709 -1.40297,0.59432 0,0 z m 19.67473,12.28006 c 3.16281,1.99601 18.46961,4.3749 8.88477,0.81847 -1.60377,0.33811 -17.77263,-4.57336 -8.88477,-0.81847 z M 97.430958,166.92721 c -0.307503,-1.33094 -4.909341,-1.4694 0,0 z m 9.159302,5.33813 c 2.38371,-1.66255 -4.94757,-1.28235 0,0 z m 7.70426,4.72382 c 3.42065,-1.28963 -5.54907,-1.29571 0,0 z M 93.703927,162.86805 c 3.711374,2.84621 14.967683,0.36473 5.683776,-1.69906 -4.225516,-2.2524 -13.74889,-3.79415 -7.25757,1.35821 l 1.573785,0.34088 9e-6,-3e-5 z m 25.808723,15.75216 c 1.54595,-2.63388 -6.48298,-1.50411 0,0 z m -7.84249,-6.23284 c 9.0752,2.56719 -7.63142,-5.739 -2.23911,-0.94466 l 1.19513,0.54082 1.04399,0.4039 -1e-5,-6e-5 z m 15.72354,9.0878 c 8.59474,0.082 -7.76304,-1.18486 0,1e-5 l 0,-1e-5 z M 90.396984,157.89545 c -0.335695,-1.60094 -2.120962,0.13419 0,0 z m 51.535396,31.73502 c 0.2292,-2.89141 -2.80486,2.15157 0,0 z m -36.86817,-22.75299 c -0.51986,-1.52251 -2.68548,-0.0622 0,0 z m -13.852128,-9.98649 c 4.934237,-0.29629 -6.755322,-2.17418 0,0 z M 74.802387,146.28394 c -0.614146,-2.36536 -5.369213,-4.2519 0,0 z m 43.079323,27.33941 c -0.90373,-1.0307 -0.4251,0.22546 0,0 z m 26.81408,16.45475 c -0.086,-1.57503 -1.46039,0.59616 0,0 z m -29.18712,-18.90528 c 0.48266,-2.02932 -4.20741,-0.61442 0,0 z M 95.532612,158.51286 c 3.670785,-0.39305 -5.880434,-2.48161 0,0 z M 129.32396,179.51 c 5.72042,-2.26627 -5.57541,-1.10635 0,0 z m -17.57682,-11.93145 c 6.59278,0.85002 -7.84442,-4.48425 -1.44651,-0.4773 l 1.4465,0.47734 1e-5,-4e-5 z m 22.91296,14.0886 c 6.15514,-3.67975 4.12588,8.61677 10.44254,1.0388 6.23086,-4.54942 -5.38086,5.62451 2.29838,0.81116 5.55359,-3.71438 13.75643,1.76075 18.93848,3.5472 3.72659,-0.18307 7.34938,3.22236 11.16973,1.15059 7.3542,-1.98082 -14.38097,-2.93789 -8.68344,-6.4523 -6.72914,1.95848 -11.70093,-2.33483 -15.01213,-6.64508 -7.54812,-1.74298 -16.27548,-5.602 -20.04257,-12.28184 -1.5359,-2.50802 2.21884,0.35333 -1.32586,-3.74638 -4.54834,-4.04546 -6.81948,-8.63766 -9.87278,-13.5552 -3.64755,-1.94587 -4.07249,-7.67345 -4.44123,-0.19201 0.0289,-4.72164 -4.40393,-7.89964 -5.48589,-6.57859 -0.0194,-4.54721 4.74396,-2.26787 1.40945,-5.63228 -0.71771,-4.71302 -3.08085,-9.6241 -3.79115,-14.9453 -1.1036,-2.56502 -0.15541,-8.05863 -3.76662,-2.25204 -1.31566,6.13669 -0.43668,-7.54129 1.6093,-3.03083 2.68543,-4.60251 -0.9641,-4.0612 -1.11361,-3.42211 1.74931,-3.88333 1.10719,-9.39159 -0.45644,-7.29023 0.93213,-4.11586 1.47259,-15.147529 -1.3951,-13.192579 1.73833,-4.303958 3.29668,-19.694077 -4.24961,-13.826325 -3.058358,0.04294 -8.354541,1.110195 -10.858032,2.355243 7.849502,4.326857 -0.789543,1.562577 -3.984808,0.874879 -0.416343,4.003642 -3.58119,2.272086 -7.535123,2.311339 6.315273,0.781339 -3.075253,6.458962 -6.698132,4.253506 -4.705102,2.248756 4.060621,7.862038 0.0944,9.597586 0.487433,2.616581 -7.208227,-0.944906 -6.603832,5.097711 -4.56774,-1.92155 -0.628961,7.16796 1.656273,4.09382 7.768882,2.10261 5.469108,6.89631 5.666947,11.44992 -1.265833,2.6534 -6.249495,-6.23691 -1.109939,-5.82517 -4.054715,-6.58674 -4.485232,-2.38081 -7.854566,0.67911 -0.783857,0.22222 8.5944,4.35376 2.709059,6.3967 5.177884,0.79894 5.325199,5.33008 6.379284,8.19735 3.11219,3.24152 2.475226,-3.57931 6.199071,0.31623 -2.356488,-3.4705 -12.48183,-9.77839 -4.329567,-7.7553 -0.04358,-3.49291 -1.474412,-6.30951 1.02322,-6.24118 2.473367,-4.47926 -2.590385,11.044 2.984725,5.35124 1.543285,-0.67388 1.92554,-4.48494 4.699544,0.35989 4.029096,3.96363 1.45533,6.83577 -4.228162,3.20648 1.016828,3.44946 7.603062,4.68217 6.365348,10.07646 1.3121,4.7444 3.147844,2.99695 4.747999,2.72266 1.25523,4.60973 1.968016,1.2201 2.027559,-0.97355 5.747357,1.23033 4.401142,4.62773 6.199456,7.00134 3.960416,1.78761 -5.668696,-12.11713 1.130659,-4.18106 7.153577,6.4586 2.682797,9.15464 -3.736856,8.11995 4.063129,-0.32824 5.373423,5.49305 10.455693,5.28853 4.63456,2.20477 7.77237,10.67291 -0.21613,7.1478 -2.77074,-2.49821 -12.575734,-5.5801 -4.56731,-0.82823 7.39657,3.42523 13.27117,5.47432 20.40487,9.77384 5.10535,3.64464 7.31104,7.81908 9.24607,8.64541 -4.29084,2.04946 -12.93089,-1.63655 -6.51514,-2.76618 -4.00168,-0.72894 -8.50258,-2.75259 -4.66961,2.2333 3.25926,2.72127 11.54708,2.43298 13.0328,2.74132 -1.25934,2.77488 -3.4207,2.99556 0.0516,3.21078 -3.87375,2.06438 1.24216,2.38403 1.60114,3.56362 z m -7.9215,-22.36993 c -2.35682,-2.46475 -2.9662,-7.08134 -0.41852,-3.06426 1.30648,0.52466 4.18523,7.54428 0.41857,3.06426 l -5e-5,0 z m 25.79733,16.38693 c 1.47004,-0.0952 0.0427,1.11681 0,0 z m -29.51867,-22.43039 c -0.0904,-3.72637 0.8525,2.87419 0,0 z m -2.56392,-3.44965 c -2.96446,-5.72787 3.73721,1.62212 0,0 z M 89.382646,128.35916 c 1.7416,-0.46446 0.856841,2.97864 0,0 z m 24.728294,13.40357 c 1.06957,-4.01654 1.25692,3.37014 0,0 z M 96.64115,129.61525 c -1.231543,-2.21638 2.576009,2.07865 0,0 z m 14.99279,4.80618 c -2.80851,-6.29223 1.98836,-3.43699 0.62135,1.03124 l -0.62135,-1.03124 0,0 z M 85.778757,117.17864 c -1.255624,-2.06432 -3.332663,-8.12135 -2.663982,-9.97042 0.604935,3.0114 6.403914,12.95956 2.844571,4.12096 -3.933386,-7.40908 4.701805,2.40491 5.590052,4.2529 0.413624,1.83837 -2.426789,-0.50225 -0.502192,3.80828 -3.509809,-4.90766 -2.071967,2.71088 -5.268449,-2.21172 z m -7.990701,-5.50612 c 0.328938,-4.79981 1.829262,3.29132 0,0 z m 3.594293,1.23728 c 1.715175,-3.62282 2.908243,5.05052 0,0 z m -8.64616,-6.68847 c -2.974956,-2.95622 -5.127809,-5.68132 0.139193,-1.83474 2.029482,0.0792 -4.509002,-6.19705 0.488751,-1.99305 5.25531,0.95822 2.5951,8.61674 -0.627944,3.82779 z m 4.541717,-0.11873 c 1.727646,-1.71203 0.917172,1.6853 0,0 z m 2.794587,0.8959 c -2.619181,-4.9094 3.178801,2.05822 0,0 z m -5.55546,-5.30909 c -8.64844,-7.696511 10.867309,4.02451 1.4129,1.4269 l -1.412955,-1.42683 5.5e-5,-7e-5 z m 24.77908,14.39717 c -3.742506,-2.24398 -0.991777,-15.79747 0.284503,-6.52785 3.638294,-1.17695 -0.200879,4.78728 2.512784,4.73208 -0.42767,3.76305 -1.64169,5.11594 -2.797287,1.79577 z m 9.165207,5.41684 c 0.36705,-4.08462 0.77249,2.79262 0,0 z m -1.59198,-1.57295 c 0.41206,-1.74497 0.0426,2.05487 0,0 z M 76.213566,99.16032 c -5.556046,-7.665657 16.147323,7.75413 3.558556,1.9443 -1.315432,-0.34404 -2.898208,-0.46688 -3.558556,-1.9443 z m 17.649112,9.35749 c -0.525779,-6.45461 1.174169,1.06991 -1.92e-4,-2e-5 l 1.92e-4,2e-5 z m 13.399762,8.59585 c 1.03698,-3.67668 0.0773,2.43221 0,0 z M 77.064685,96.23472 c 3.302172,-0.706291 13.684695,5.79939 4.150224,1.85832 -1.059396,-1.17279 -3.317802,-0.63994 -4.150224,-1.85832 z m 28.356745,14.13312 c 0.35296,-6.60002 1.97138,-3.94233 0.0122,0.94474 l -0.0121,-0.94473 -5e-5,-1e-5 z M 79.52277,93.938099 c 1.345456,-1.97361 -3.571631,-8.923063 0.708795,-2.492797 1.849543,1.469605 5.355103,2.461959 2.260017,3.080216 4.867744,4.294162 -1.187244,1.163612 -2.968812,-0.587419 z m 24.49612,14.368161 c 0.92952,-7.51843 0.81971,4.40485 0,0 z M 76.712755,86.993902 c 1.027706,-0.439207 0.542746,1.369335 0,0 z m 6.389622,3.803092 c 1.644416,-3.450522 3.03351,3.848297 0,0 z m 18.023553,10.026276 c -0.0174,-1.3252 0.34003,1.92765 0,0 z m -1.04404,-2.31139 c -2.501612,-6.171646 2.32693,3.26759 0,0 z m -1.536003,-4.046372 c -0.419906,-2.550188 1.427129,3.203862 -7.3e-5,-9e-6 l 7.3e-5,9e-6 z m 2.499773,-4.063514 c -1.71663,-3.025123 2.16777,-13.331073 2.60122,-6.939418 -1.81185,4.980256 -0.52268,7.766309 0.74129,1.086388 2.33417,-5.257159 -0.50421,10.374054 -3.34255,5.853057 l 4e-5,-2.7e-5 z m 2.56889,-15.326649 c 0.74833,-0.918921 0.16609,1.107082 0,0 z m -4.290016,84.534235 c -1.017552,-0.88802 0.127775,0.56506 0,0 z m 8.837726,4.47065 c 4.91599,1.26135 4.89086,-0.76487 0.44782,-1.36683 -2.3898,-2.22316 -9.930475,-4.58124 -3.18119,-0.27586 0.44699,1.13227 1.85944,1.10589 2.73337,1.64269 z M 90.708067,152.48725 c 2.708244,2.01956 10.201213,5.72375 3.858186,0.76868 2.138588,-2.48467 -4.093336,-3.80722 -2.026067,-5.46927 -5.258175,-3.21755 -4.147962,-2.93133 -0.464111,-2.8301 -6.319385,-2.82462 0.912163,-2.61333 0.571661,-4.06067 -2.436706,-0.48126 -12.103074,-4.29664 -6.416395,0.31341 -5.780887,-2.94751 -1.377603,1.09799 -3.12488,0.67029 -5.911336,-1.61178 5.264392,4.50224 -0.938845,2.98448 3.391327,2.6875 9.128301,6.88393 1.433786,2.84407 -1.013816,1.45934 5.506273,3.67136 7.106665,4.77911 z m 9.243194,5.31013 c 11.238769,3.62163 -5.510018,-4.4246 0,0 z m 47.316399,28.66432 c 0.14496,-2.22965 -1.53604,1.90201 0,0 z m 4.86324,2.04679 c 2.59297,-2.51255 0.106,4.00222 4.29655,-0.61509 0.0453,-3.30544 -0.12904,-5.25783 -4.81563,-1.24252 -1.29194,0.71648 -1.86871,3.76288 0.51908,1.85761 z M 74.932378,140.02637 c -0.796355,-3.1304 -5.581949,-3.11418 0,0 z m 5.193029,3.40294 c -1.928397,-3.19739 -6.880525,-2.89469 0,0 z m 29.543373,17.81697 c 2.8844,2.56199 13.24761,1.87984 3.50331,0.31527 -1.44321,-2.13386 -9.16415,-1.6203 -3.50331,-0.31527 z m 40.61236,25.08153 c 4.43933,-3.72512 -4.30122,1.66183 0,0 z m 9.2328,6.34473 c 0.0277,-1.19543 -1.91352,0.52338 0,0 z m 0.0142,-1.6736 c 4.91602,-5.20866 -4.76346,0.30807 -4e-5,0 l 4e-5,0 z M 62.15981,129.33339 c -4.189944,-5.97826 -2.604586,-8.66544 -6.645136,-13.54677 -0.764913,-3.73279 -6.931672,-12.20326 -3.189579,-3.22947 3.42754,5.24836 4.446054,13.37434 9.834715,16.77624 z m 95.82635,60.00977 c 9.04429,-5.84575 -3.7125,-2.54641 0,0 z m 6.9041,2.70461 c 4.52911,-3.88867 -2.86491,-0.81334 0,0 z M 73.393094,133.41838 c 1.296204,-1.92838 -3.347642,-0.24666 0,0 z m 90.055596,56.78275 c 4.38526,-2.82746 -1.01036,-2.39335 -0.79483,0.26003 l 0.79484,-0.26003 -1e-5,0 z m -59.51386,-37.51178 c -0.15075,-1.90924 -2.31574,0.16206 0,0 z m 3.67794,2.11629 c -1.16888,-2.36318 -1.79716,0.37121 0,0 z m 62.8725,37.30625 c 5.61806,-4.05283 -3.4056,-0.77594 -1.17927,0.76785 l 1.17927,-0.76785 0,0 z m -2.15131,-1.03979 c 4.57663,-3.83506 -4.83183,1.69954 0,0 z m 10.99163,7.31983 c 3.0728,-2.05816 -3.73316,-0.66575 0,0 z M 76.211249,132.02781 c 4.118965,0.92286 16.460394,10.1439 9.179466,0.63772 -3.728991,-1.10384 -1.492605,-10.21906 -5.29621,-8.60579 2.552972,4.2649 2.100461,6.08018 -3.259642,3.3914 -6.736808,-3.28853 -3.785888,1.6297 -2.469293,2.98518 -1.794185,0.40772 2.373226,1.5572 1.845679,1.59149 z m -18.76588,-14.82026 c 0.737407,-3.04991 -6.789814,-16.77881 -3.554464,-6.87916 1.167861,2.07373 1.049123,6.00387 3.554464,6.87916 z m 34.443451,21.23513 c -2.120989,-1.77378 -0.100792,-0.25103 0,0 z m 5.222997,1.21548 c -0.0027,-3.23079 -5.77326,-1.31196 0,0 z m 45.261473,28.53321 c -0.86326,-2.20739 -3.41229,-0.0512 8e-5,4e-5 l -8e-5,-4e-5 z m 2.17351,1.58769 c -0.32087,-1.23546 -1.25399,0.23848 0,0 z m 17.94015,11.3001 c 1.72546,-1.27472 -2.15318,-0.1628 0,0 z M 66.819057,119.6006 c 4.935243,-1.91072 -5.28775,-1.36248 0,0 z m 71.569733,45.08937 c -0.0549,-3.19499 -3.14622,0.79264 0,0 z M 64.869152,115.05675 c 3.170167,-1.07084 -2.932663,-0.70531 0,0 z m 9.201532,4.45726 c -0.0575,-1.05014 -0.973336,0.39747 0,0 z m 112.231406,68.82181 c 4.0765,-0.8265 13.36606,2.07489 14.86752,-1.08086 -4.95044,-0.12019 -17.12734,-3.49263 -17.70346,0.80479 l 1.08368,0.17072 1.75226,0.10534 0,1e-5 z M 76.995161,120.25099 c 0.07087,-3.23755 -2.524669,-0.12092 0,0 z M 52.801998,103.4687 c -1.098703,-6.16843 -4.178791,-0.93357 0,0 z m 5.769195,1.45013 c 0.07087,-1.9807 -5.280562,-1.78224 0,0 z m 3.296917,1.61923 c -0.953019,-0.77196 -0.745959,0.97521 0,0 z m 20.744719,13.30775 c 0.976615,-0.89718 -2.312116,-0.66455 0,0 z M 59.672204,102.88617 c -0.557624,-4.65897 -6.681999,-0.69805 0,0 z M 47.844441,95.21166 c -0.168219,-2.150189 -1.152625,0.81111 0,0 z m 1.759336,-1.328672 c -0.28703,-2.549584 -1.510515,0.324387 0,0 z m 9.720792,5.802442 c 4.110486,-1.61465 -7.487254,-3.33984 -0.839893,-0.30506 l 0.839893,0.30506 z m 130.097601,80.35913 c 2.63092,-2.4121 -3.34373,-0.74577 0,0 z m 15.71669,8.14691 c 1.05433,-3.1186 -2.65452,0.41058 0,0 z M 60.318012,94.590436 c 0.433018,-3.016773 -3.258762,0.59902 0,0 z M 46.487687,85.324242 c -0.742965,-4.25911 -0.64134,-11.735065 6.465133,-9.208583 -9.485962,1.883339 6.56534,11.790095 4.538357,3.968363 3.988626,0.195294 7.802669,-2.357284 5.709487,1.516403 7.85876,-0.867958 13.307129,-7.682612 20.898169,-6.72768 5.913058,-0.782493 12.378182,-1.375955 18.750257,-3.756157 5.23905,-0.37743 10.28235,-6.018062 7.41068,-9.361383 -7.14456,-0.604513 -14.62339,0.289393 -22.520112,1.858993 -8.750559,1.819117 -16.699014,5.275307 -25.528125,6.758866 -8.605891,1.15604 1.730998,3.185165 -0.734074,3.637227 -4.490681,1.558136 5.355488,2.608852 -0.582182,4.251428 C 57.228283,77.56448 53.411411,76.304535 54.977788,72.440196 46.7341,73.50992 39.490264,76.931325 46.003276,85.320342 l 0.484402,0.0037 9e-6,-2.56e-4 z m 19.864291,-10.1168 c 1.932856,-7.120464 10.355229,5.859274 3.168052,0.945776 -0.858453,-0.642457 -2.2703,-1.166588 -3.168052,-0.945776 z m 0.376038,-3.452197 c 2.789661,-2.078257 1.482964,1.16516 0,0 z m 3.542213,0.05622 c 0.251833,-3.27648 8.108752,1.73455 1.295517,1.179499 l -1.295517,-1.179499 0,0 z m 4.84543,-1.948193 c 1.769481,-2.067535 0.50862,1.83906 0,0 z m 1.239563,-0.83005 c 2.946379,-3.540216 16.68561,-2.259413 6.628966,-0.34519 -2.695543,-2.029363 -4.761797,1.196575 -6.628966,0.34519 z m 17.930017,-2.763886 c -0.448199,-9.670222 8.907771,3.436477 0,0 z m 5.087539,-0.02784 c 1.860022,-4.873906 7.218072,-1.955774 0.860732,-0.979407 0.13805,0.518656 -0.18642,2.516173 -0.860732,0.979407 z M 58.311842,92.088739 c 5.55753,-3.403212 -5.899945,-2.952541 0,0 l 0,0 z m 4.109214,1.141866 c 1.948513,-2.071884 -4.233857,-0.840369 0,0 z M 50.313395,84.63767 c 3.175569,-2.439416 -3.757842,-0.927473 0,0 z M 214.41578,187.30012 c 0.0918,-2.83019 -2.42718,1.27537 0,0 z m -16.67487,-11.37935 c 0.47417,-3.25845 -2.14286,0.28408 0,0 z m 21.26022,12.47672 c 4.43994,0.015 13.45265,-1.37884 3.79217,-1.37442 -1.51594,0.23641 -8.83311,0.18571 -3.79216,1.37439 l -1e-5,3e-5 z M 66.035603,91.23339 c 3.593258,-0.246807 5.621861,-3.963629 -0.694932,-3.749977 -9.789949,-1.013541 8.637508,3.352129 -1.255898,2.10383 -1.329368,0.880346 1.873606,1.889721 1.95083,1.646147 z m 3.164618,1.601748 c -0.375177,-2.307063 -1.111156,1.225591 0,0 z m 3.753896,-10.009901 c 1.559281,-1.934055 -2.157697,-0.517053 0,0 z M 61.003998,62.84999 c 6.412879,-2.181631 15.182392,-4.633087 18.210335,1.074184 -3.081589,-3.70893 -1.24361,-7.360157 1.666959,-1.937407 4.115576,5.486669 6.175915,-2.495489 3.499086,-4.335821 3.050468,3.790246 6.520044,5.581281 2.042429,0.239564 4.865693,-5.852929 -9.742712,0.766433 -13.063105,0.699775 -1.597564,0.717062 -16.493576,3.79889 -12.355704,4.259705 z m 3.75831,-7.197834 c 3.657324,-2.760416 12.648968,1.641989 6.879078,-2.743367 -0.564117,-0.498292 -12.636077,3.325475 -6.879078,2.743367 z m 13.333489,0.550473 c 4.280389,0.109225 -1.84632,-5.750287 3.254304,-3.095159 -0.837696,-2.736627 -5.938558,-3.248956 -8.432316,-4.342312 -1.410474,2.502054 2.870977,7.471102 5.178012,7.437471 z M 67.100291,44.099162 c 1.480803,-2.007406 -2.59521,1.017699 0,0 z m 5.449586,1.304353 c 6.897867,-0.914901 -1.758292,-2.970542 -1.389954,-0.07352 l 1.389954,0.07352 0,-9e-6 z M 62.374386,37.441437 c -4.856866,-6.340205 9.133987,1.065769 4.199411,-5.572646 -4.153254,-3.307245 -8.144297,3.721775 -4.199411,5.572646 z m 62.330124,33.572802 c 2.22762,-3.948988 -9.19697,-5.323011 -1.5009,-1.399578 0.70858,0.236781 0.54821,1.6727 1.5009,1.399578 z""
       id=""path2900"" />
    <g
       style=""font-size:28px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:89.99999762%;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
       id=""text3844"">
      <path
         d=""m 166.92789,156.32883 c -2e-5,1.80469 -0.62892,3.31771 -1.88672,4.53906 -1.20314,1.17578 -2.63412,1.76367 -4.29297,1.76367 -0.93881,0 -1.91863,-0.15495 -2.93945,-0.46484 -0.98438,-0.30078 -1.48113,-0.57422 -1.49024,-0.82031 -0.009,-0.20964 -0.005,-0.94336 0.0137,-2.20118 0.0274,-1.54036 0.041,-2.66145 0.041,-3.36328 0,-1.05728 -0.009,-2.59081 -0.0273,-4.60058 -0.0182,-2.00976 -0.0273,-3.34276 -0.0273,-3.99903 0,-0.65623 -0.10026,-1.1074 -0.30078,-1.35351 -0.18229,-0.21874 -0.57878,-0.39191 -1.18945,-0.51953 -0.23698,-0.082 -0.35547,-0.23241 -0.35547,-0.45118 0,-0.19138 0.17773,-0.35089 0.5332,-0.47851 0.51042,-0.18228 1.14388,-0.48761 1.90039,-0.91602 0.60156,-0.33722 0.97526,-0.50584 1.1211,-0.50586 0.28254,2e-5 0.42382,0.23244 0.42382,0.69727 0,0.0365 -0.0137,0.51043 -0.041,1.42187 -0.0182,0.85679 -0.0228,1.72723 -0.0137,2.61133 l 0.0273,4.73047 c 0,0.44662 0.15494,0.57423 0.46484,0.38281 1.09375,-0.62889 2.23307,-0.94335 3.41797,-0.94336 1.36718,10e-6 2.47916,0.41245 3.33594,1.23731 0.85676,0.82488 1.28514,1.90268 1.28516,3.2334 z m -2.1875,1.21679 c -1e-5,-1.24869 -0.34637,-2.27408 -1.03907,-3.07617 -0.65625,-0.7565 -1.45378,-1.13475 -2.39257,-1.13476 -0.64715,1e-5 -1.28517,0.16863 -1.91407,0.50586 -0.62891,0.33724 -0.94336,0.69271 -0.94336,1.0664 l 0,3.66406 c 0,1.75912 0.9707,2.63868 2.91211,2.63868 1.01171,0 1.82747,-0.32585 2.44727,-0.97754 0.61978,-0.65169 0.92968,-1.5472 0.92969,-2.68653 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2841"" />
      <path
         d=""m 179.35562,160.17062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41015,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -1e-5,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2843"" />
      <path
         d=""m 191.11343,160.70383 c -1e-5,0.33724 -0.46941,0.74739 -1.4082,1.23047 -1.02084,0.51953 -2.028,0.77929 -3.02148,0.77929 -1.54949,0 -2.81641,-0.4375 -3.80078,-1.3125 -1.02995,-0.92968 -1.54493,-2.18749 -1.54493,-3.77343 0,-1.70443 0.59245,-3.12174 1.77735,-4.25196 1.15755,-1.10285 2.57942,-1.65428 4.26562,-1.65429 1.02083,1e-5 1.9095,0.14584 2.66602,0.4375 0.6927,0.27344 1.03905,0.56511 1.03906,0.875 -1e-5,0.20964 -0.17091,0.52865 -0.5127,0.95703 -0.3418,0.42839 -0.62208,0.64258 -0.84082,0.64257 -0.13672,1e-5 -0.45118,-0.19595 -0.94335,-0.58789 -0.92059,-0.72915 -1.64064,-1.09374 -2.16016,-1.09375 -0.82032,10e-6 -1.4948,0.30991 -2.02344,0.92969 -0.55599,0.67449 -0.83399,1.60417 -0.83398,2.78906 -1e-5,1.431 0.40103,2.57488 1.20312,3.43164 0.72916,0.77475 1.60872,1.16211 2.63867,1.16211 1.02083,0 1.98242,-0.28255 2.88477,-0.84765 0.082,-0.0547 0.1914,-0.082 0.32812,-0.082 0.1914,0 0.2871,0.12305 0.28711,0.36914 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2845"" />
      <path
         d=""m 204.26578,161.155 c -1e-5,0.19141 -0.34865,0.48079 -1.0459,0.86816 -0.69728,0.38737 -1.25554,0.58106 -1.67481,0.58106 -0.35547,0 -0.66993,-0.17318 -0.94335,-0.51953 -0.27345,-0.34636 -0.46486,-0.51953 -0.57422,-0.51953 -0.082,0 -0.51498,0.18684 -1.29883,0.56054 -0.78386,0.3737 -1.57227,0.56055 -2.36524,0.56055 -0.7474,0 -1.37174,-0.21875 -1.87304,-0.65625 -0.54688,-0.48307 -0.82032,-1.13932 -0.82032,-1.96875 0,-1.57682 1.80469,-2.70703 5.41407,-3.39063 0.61978,-0.11848 0.93423,-0.36913 0.94336,-0.75195 l 0.0273,-0.875 c 0.0547,-1.49478 -0.60613,-2.24218 -1.98242,-2.24219 -0.39193,1e-5 -0.76335,0.35092 -1.11426,1.05274 -0.35092,0.70183 -0.8545,1.08008 -1.51074,1.13476 -0.7474,0.0729 -1.1211,-0.24153 -1.1211,-0.94336 0,-0.43749 0.55599,-0.9479 1.66797,-1.53125 1.16666,-0.61066 2.28776,-0.916 3.36328,-0.91601 1.85026,10e-6 2.76627,0.87957 2.74805,2.63867 l -0.0547,5.63281 c -0.009,0.59245 0.24153,0.88868 0.75196,0.88867 0.10025,1e-5 0.29165,-0.0228 0.57422,-0.0684 0.28254,-0.0456 0.4466,-0.0684 0.49218,-0.0684 0.26431,0 0.39648,0.17773 0.39649,0.5332 z m -4.21094,-3.11719 c 0.009,-0.22786 -0.0433,-0.37825 -0.15723,-0.45117 -0.11394,-0.0729 -0.29395,-0.0866 -0.54004,-0.041 -2.19662,0.39194 -3.29492,1.10743 -3.29492,2.14649 0,1.04818 0.56966,1.57226 1.70899,1.57226 0.45572,0 0.92512,-0.0866 1.4082,-0.25976 0.5651,-0.20052 0.84765,-0.44206 0.84766,-0.72461 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2847"" />
      <path
         d=""m 218.74429,161.31906 c -1e-5,0.18229 -0.4284,0.46029 -1.28515,0.83399 -0.72918,0.31901 -1.09376,0.47851 -1.09375,0.47851 -0.1185,0 -0.37143,-0.20508 -0.75879,-0.61523 -0.38738,-0.41016 -0.65854,-0.61524 -0.81348,-0.61524 -0.082,0 -0.55144,0.19141 -1.4082,0.57422 -0.85678,0.38281 -1.60873,0.57422 -2.25586,0.57422 -1.36719,0 -2.31967,-0.25977 -2.85742,-0.7793 -0.58334,-0.55599 -0.87501,-1.56315 -0.875,-3.02148 l 0,-2.74805 c -1e-5,-0.76562 -0.0775,-1.30338 -0.23242,-1.61328 -0.20964,-0.3828 -0.63347,-0.67447 -1.27149,-0.875 -0.20964,-0.0638 -0.31445,-0.17772 -0.31445,-0.3418 0,-0.18228 0.17773,-0.34178 0.5332,-0.47851 0.67448,-0.26431 1.3444,-0.53319 2.00977,-0.80664 0.46484,-0.1914 0.80208,-0.2871 1.01172,-0.28711 0.319,10e-6 0.47851,0.2142 0.47851,0.64258 0,1e-5 -0.0137,0.4808 -0.041,1.44238 -0.0274,0.9616 -0.041,1.87533 -0.041,2.74121 l 0,1.64063 c -1e-5,1.11198 0.21874,1.87304 0.65625,2.2832 0.39192,0.36458 1.10741,0.54687 2.14648,0.54687 1.60416,0 2.40624,-0.82031 2.40625,-2.46093 l 0,-2.4336 c -1e-5,-0.88411 -0.0798,-1.45149 -0.23925,-1.70215 -0.15952,-0.25064 -0.58563,-0.46711 -1.27832,-0.64941 -0.20053,-0.082 -0.30079,-0.2233 -0.30079,-0.42383 0,-0.20962 0.12304,-0.36002 0.36915,-0.45117 1.8867,-0.68358 2.92121,-1.02538 3.10351,-1.02539 0.35546,1e-5 0.53319,0.20509 0.5332,0.61523 -1e-5,-0.009 -0.0137,0.44891 -0.041,1.37403 -0.0274,0.92513 -0.041,1.82064 -0.041,2.68652 l 0,3.44531 c -1e-5,0.64714 0.47395,1.00717 1.42188,1.08008 0.31899,0.0274 0.4785,0.15039 0.47851,0.36914 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2849"" />
      <path
         d=""m 229.34,159.52805 c -1e-5,0.96614 -0.37143,1.73405 -1.11426,2.30371 -0.74285,0.56966 -1.75684,0.85449 -3.04199,0.85449 -0.85678,0 -1.71355,-0.0911 -2.57032,-0.27344 -0.73828,-0.16406 -1.16666,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10938,-0.73372 0.32813,-0.75195 0.21875,-0.0273 0.40559,0.0911 0.56054,0.35547 0.6836,1.19401 1.78646,1.79101 3.3086,1.79101 1.28515,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31901,-0.30078 -0.93881,-0.65169 -1.85937,-1.05274 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48307,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37826,-1.74999 1.13477,-2.29687 0.70182,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17774 0.65624,0.1185 0.99804,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17577 -1.63152,-1.76366 -2.73438,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87304,1.20312 -1e-5,0.44662 0.16861,0.80209 0.50586,1.06641 0.30077,0.22787 1.00715,0.58334 2.11914,1.0664 1.16666,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.82031,1.2168 0.82032,2.0918 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2851"" />
      <path
         d=""m 242.08218,160.17062 c -1e-5,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -10e-6,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -1e-5,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2853"" />
      <path
         d=""m 259.58218,159.52805 c -10e-6,0.96614 -0.37142,1.73405 -1.11425,2.30371 -0.74285,0.56966 -1.75685,0.85449 -3.042,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10937,-0.73372 0.32813,-0.75195 0.21874,-0.0273 0.40559,0.0911 0.56054,0.35547 0.68359,1.19401 1.78646,1.79101 3.3086,1.79101 1.28514,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31902,-0.30078 -0.93881,-0.65169 -1.85937,-1.05274 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13477,-2.29687 0.70181,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17774 0.65624,0.1185 0.99804,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17577 -1.63152,-1.76366 -2.73438,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87304,1.20312 -1e-5,0.44662 0.16861,0.80209 0.50585,1.06641 0.30078,0.22787 1.00716,0.58334 2.11915,1.0664 1.16665,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.8203,1.2168 0.82031,2.0918 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2855"" />
      <path
         d=""m 273.84195,156.95773 c -10e-6,1.58594 -0.5879,2.92807 -1.76367,4.02637 -1.17579,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.74089,0 -3.11719,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77734,1e-5 3.16275,0.47852 4.15625,1.43555 0.96613,0.92969 1.44921,2.1875 1.44922,3.77343 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34636,-2.59309 -1.03906,-3.48633 -0.67449,-0.86588 -1.53126,-1.29882 -2.57032,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65625,0.80209 1.51302,1.20313 2.57031,1.20313 1.0026,0 1.79557,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2857"" />
      <path
         d=""m 298.39664,162.09836 c -3e-5,0.30078 -0.1413,0.44206 -0.42383,0.42383 -1.8594,-0.13672 -3.59117,-0.13672 -5.19531,0 -0.35549,0.0273 -0.53322,-0.13217 -0.53321,-0.47852 -10e-6,-0.27344 0.24152,-0.41927 0.72461,-0.4375 0.61066,-0.0365 0.916,-0.5332 0.91602,-1.49023 l 0,-3.63672 c -2e-5,-2.04166 -0.82945,-3.06249 -2.48828,-3.0625 -0.87502,1e-5 -1.6771,0.15951 -2.40625,0.47851 -0.66538,0.28256 -1.00262,0.56512 -1.01172,0.84766 l -0.0547,5.42773 c -10e-6,0.56511 0.0684,0.93881 0.20508,1.1211 0.10025,0.1276 0.32355,0.21875 0.66992,0.27344 0.80207,0.13671 1.20311,0.30533 1.20313,0.50585 -2e-5,0.17318 -0.0228,0.29167 -0.0684,0.35547 -0.0547,0.0911 -0.21877,0.13216 -0.49219,0.12305 -1.03908,-0.0365 -2.5521,-0.0182 -4.53906,0.0547 -0.28257,0.009 -0.46486,-0.0137 -0.54688,-0.0684 -0.082,-0.0547 -0.12305,-0.18229 -0.12305,-0.38281 0,-0.23698 0.25976,-0.38282 0.7793,-0.4375 0.56509,-0.0638 0.84765,-0.57878 0.84766,-1.54493 l 0,-3.71875 c -1e-5,-1.00259 -0.22788,-1.77733 -0.6836,-2.32421 -0.40105,-0.49218 -0.91146,-0.73828 -1.53125,-0.73829 -0.91146,10e-6 -1.73177,0.18458 -2.46093,0.55371 -0.72918,0.36915 -1.09376,0.76336 -1.09375,1.18262 l 0,4.99024 c -10e-6,0.5651 0.14582,0.95703 0.4375,1.17578 0.26431,0.20052 0.74283,0.32357 1.43554,0.36914 0.37369,0.0182 0.56054,0.14583 0.56055,0.38281 -1e-5,0.26432 -0.1504,0.39649 -0.45117,0.39649 -2.27865,0 -3.92839,0.0638 -4.94922,0.1914 -0.34636,0.0456 -0.56966,0.0456 -0.66992,0 -0.082,-0.0456 -0.12305,-0.15495 -0.12305,-0.32812 0,-0.22787 0.33724,-0.42383 1.01172,-0.58789 0.41015,-0.10938 0.61523,-0.64258 0.61523,-1.59961 l 0,-4.19727 c 0,-1.0664 -0.28711,-1.68163 -0.86132,-1.8457 -0.48308,-0.13671 -0.77702,-0.23697 -0.88184,-0.30078 -0.10482,-0.0638 -0.15723,-0.16861 -0.15723,-0.31446 0,-0.16405 0.47396,-0.5104 1.42188,-1.03906 1.0026,-0.56509 1.61783,-0.84764 1.8457,-0.84766 0.1914,2e-5 0.35319,0.27573 0.48535,0.82715 0.13216,0.55144 0.2347,0.82716 0.30762,0.82715 0.10026,1e-5 0.37825,-0.14127 0.83398,-0.42383 0.5651,-0.35546 1.07552,-0.61978 1.53125,-0.79297 0.74739,-0.29165 1.51757,-0.43748 2.31055,-0.4375 0.63801,2e-5 1.194,0.13673 1.66797,0.41016 0.32811,0.1823 0.62434,0.43295 0.88867,0.75195 0.21874,0.27345 0.32811,0.41017 0.32813,0.41016 -2e-5,1e-5 0.23696,-0.13671 0.71093,-0.41016 0.55598,-0.319 1.0983,-0.56965 1.62696,-0.75195 0.77472,-0.27343 1.52667,-0.41014 2.25586,-0.41016 2.49737,2e-5 3.74607,1.37176 3.74609,4.11524 l 0,4.42969 c -2e-5,0.51953 0.12303,0.88867 0.36914,1.10742 0.21873,0.18229 0.64711,0.33724 1.28516,0.46484 0.48305,0.0911 0.72458,0.22787 0.72461,0.41016 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2859"" />
      <path
         d=""m 309.94937,160.17062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41015,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2861"" />
      <path
         d=""m 319.49234,161.18234 c -1e-5,0.4375 -0.40105,0.8112 -1.20312,1.1211 -0.71095,0.27343 -1.431,0.41015 -2.16016,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43294,-0.28027 -0.99805,-0.41699 -0.14583,-0.0365 -0.21875,-0.17773 -0.21875,-0.42383 0,-0.26432 0.0547,-0.42382 0.16407,-0.47852 0.98437,-0.48306 1.84114,-1.34895 2.57031,-2.59765 0.10026,-0.17317 0.29622,-0.22786 0.58789,-0.16407 0.20052,0.0638 0.30533,0.18231 0.31445,0.35547 l 0.0547,1.70899 c 0,0.12761 0.0228,0.21876 0.0684,0.27343 0.0638,0.0821 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17317,1e-5 0.17317,0.2142 0,0.64258 -0.20965,0.51954 -0.51954,0.7793 -0.92969,0.7793 l -2.06445,0 c -0.35548,0 -0.57423,0.0593 -0.65625,0.17773 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c 0,1.13022 0.10026,1.84571 0.30079,2.14649 0.26431,0.38281 0.87955,0.57422 1.8457,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69726,-0.15722 0.72461,-0.15723 0.10936,1e-5 0.16405,0.0684 0.16406,0.20508 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2863"" />
      <path
         d=""m 326.34195,146.64914 c -10e-6,0.41929 -0.15723,0.80893 -0.47168,1.16894 -0.31446,0.36005 -0.65853,0.54006 -1.03223,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05273,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41016,-0.99805 0,-0.40102 0.16634,-0.77472 0.49903,-1.12109 0.33267,-0.34634 0.69042,-0.51951 1.07324,-0.51953 0.92968,2e-5 1.39452,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15496,0.41472 -0.32813,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69336,-0.0729 -4.00586,0.0547 -0.35547,0.0365 -0.57877,0.0228 -0.66992,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13672,-0.4375 0,-0.20963 0.24154,-0.38281 0.72461,-0.51953 0.52864,-0.15495 0.79297,-0.66081 0.79297,-1.51758 l 0,-3.58203 c 0,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20052,-0.40103 -0.61524,-0.70637 -1.24414,-0.91601 -0.28255,-0.10025 -0.42383,-0.25064 -0.42383,-0.45117 0,-0.26432 0.20508,-0.46028 0.61524,-0.58789 0.76562,-0.23697 1.44465,-0.55143 2.03711,-0.94336 0.47395,-0.32812 0.76562,-0.49218 0.875,-0.49219 0.36457,10e-6 0.54231,0.23699 0.5332,0.71094 -0.0365,2.38802 -0.0547,4.82162 -0.0547,7.30078 0,0.59245 0.0866,1.01627 0.25977,1.27148 0.1914,0.28255 0.55598,0.48308 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2865"" />
      <path
         d=""m 351.9357,162.09836 c -2e-5,0.30078 -0.1413,0.44206 -0.42383,0.42383 -1.85939,-0.13672 -3.59116,-0.13672 -5.19531,0 -0.35549,0.0273 -0.53322,-0.13217 -0.5332,-0.47852 -2e-5,-0.27344 0.24151,-0.41927 0.72461,-0.4375 0.61065,-0.0365 0.91599,-0.5332 0.91601,-1.49023 l 0,-3.63672 c -2e-5,-2.04166 -0.82944,-3.06249 -2.48828,-3.0625 -0.87502,1e-5 -1.6771,0.15951 -2.40625,0.47851 -0.66538,0.28256 -1.00262,0.56512 -1.01172,0.84766 l -0.0547,5.42773 c -10e-6,0.56511 0.0684,0.93881 0.20508,1.1211 0.10025,0.1276 0.32356,0.21875 0.66992,0.27344 0.80207,0.13671 1.20311,0.30533 1.20313,0.50585 -2e-5,0.17318 -0.0228,0.29167 -0.0684,0.35547 -0.0547,0.0911 -0.21877,0.13216 -0.49219,0.12305 -1.03907,-0.0365 -2.55209,-0.0182 -4.53906,0.0547 -0.28256,0.009 -0.46485,-0.0137 -0.54688,-0.0684 -0.082,-0.0547 -0.12305,-0.18229 -0.12304,-0.38281 -10e-6,-0.23698 0.25975,-0.38282 0.77929,-0.4375 0.5651,-0.0638 0.84765,-0.57878 0.84766,-1.54493 l 0,-3.71875 c -1e-5,-1.00259 -0.22788,-1.77733 -0.68359,-2.32421 -0.40106,-0.49218 -0.91147,-0.73828 -1.53125,-0.73829 -0.91147,10e-6 -1.73178,0.18458 -2.46094,0.55371 -0.72917,0.36915 -1.09376,0.76336 -1.09375,1.18262 l 0,4.99024 c -10e-6,0.5651 0.14583,0.95703 0.4375,1.17578 0.26432,0.20052 0.74283,0.32357 1.43555,0.36914 0.37369,0.0182 0.56054,0.14583 0.56054,0.38281 0,0.26432 -0.1504,0.39649 -0.45117,0.39649 -2.27865,0 -3.92839,0.0638 -4.94922,0.1914 -0.34635,0.0456 -0.56966,0.0456 -0.66992,0 -0.082,-0.0456 -0.12305,-0.15495 -0.12305,-0.32812 0,-0.22787 0.33724,-0.42383 1.01172,-0.58789 0.41016,-0.10938 0.61523,-0.64258 0.61524,-1.59961 l 0,-4.19727 c -10e-6,-1.0664 -0.28712,-1.68163 -0.86133,-1.8457 -0.48308,-0.13671 -0.77702,-0.23697 -0.88184,-0.30078 -0.10482,-0.0638 -0.15723,-0.16861 -0.15722,-0.31446 -1e-5,-0.16405 0.47395,-0.5104 1.42187,-1.03906 1.0026,-0.56509 1.61784,-0.84764 1.8457,-0.84766 0.19141,2e-5 0.35319,0.27573 0.48536,0.82715 0.13215,0.55144 0.23469,0.82716 0.30761,0.82715 0.10026,1e-5 0.37825,-0.14127 0.83399,-0.42383 0.56509,-0.35546 1.07551,-0.61978 1.53125,-0.79297 0.74738,-0.29165 1.51757,-0.43748 2.31054,-0.4375 0.63801,2e-5 1.194,0.13673 1.66797,0.41016 0.32812,0.1823 0.62434,0.43295 0.88867,0.75195 0.21874,0.27345 0.32812,0.41017 0.32813,0.41016 -10e-6,1e-5 0.23697,-0.13671 0.71094,-0.41016 0.55597,-0.319 1.09829,-0.56965 1.62695,-0.75195 0.77472,-0.27343 1.52668,-0.41014 2.25586,-0.41016 2.49738,2e-5 3.74607,1.37176 3.74609,4.11524 l 0,4.42969 c -2e-5,0.51953 0.12303,0.88867 0.36914,1.10742 0.21873,0.18229 0.64712,0.33724 1.28516,0.46484 0.48305,0.0911 0.72459,0.22787 0.72461,0.41016 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2867"" />
      <path
         d=""m 363.48843,160.17062 c -10e-6,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -1e-5,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2869"" />
      <path
         d=""m 374.04312,159.52805 c -10e-6,0.96614 -0.37143,1.73405 -1.11426,2.30371 -0.74284,0.56966 -1.75684,0.85449 -3.04199,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28516,-0.45117 -0.0729,-0.1276 -0.10937,-0.75195 -0.10937,-1.87305 0,-0.48307 0.10937,-0.73372 0.32812,-0.75195 0.21875,-0.0273 0.4056,0.0911 0.56055,0.35547 0.68359,1.19401 1.78645,1.79101 3.30859,1.79101 1.28515,0 1.92773,-0.44661 1.92774,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31902,-0.30078 -0.93881,-0.65169 -1.85938,-1.05274 -1.33073,-0.59244 -2.2194,-1.11197 -2.66601,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13476,-2.29687 0.70182,-0.52864 1.64062,-0.79296 2.81641,-0.79297 0.73827,1e-5 1.41275,0.0593 2.02344,0.17774 0.65624,0.1185 0.99803,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60157,-0.15039 -0.72006,-1.17577 -1.63151,-1.76366 -2.73437,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87305,1.20312 0,0.44662 0.16862,0.80209 0.50586,1.06641 0.30078,0.22787 1.00716,0.58334 2.11914,1.0664 1.16666,0.50131 1.95963,0.95248 2.37891,1.35352 0.54686,0.51953 0.8203,1.2168 0.82031,2.0918 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2871"" />
      <path
         d=""m 394.4689,161.155 c -1e-5,0.19141 -0.34864,0.48079 -1.0459,0.86816 -0.69727,0.38737 -1.25554,0.58106 -1.6748,0.58106 -0.35548,0 -0.66993,-0.17318 -0.94336,-0.51953 -0.27345,-0.34636 -0.46485,-0.51953 -0.57422,-0.51953 -0.082,0 -0.51498,0.18684 -1.29883,0.56054 -0.78386,0.3737 -1.57227,0.56055 -2.36523,0.56055 -0.7474,0 -1.37175,-0.21875 -1.87305,-0.65625 -0.54687,-0.48307 -0.82031,-1.13932 -0.82031,-1.96875 0,-1.57682 1.80468,-2.70703 5.41406,-3.39063 0.61979,-0.11848 0.93424,-0.36913 0.94336,-0.75195 l 0.0274,-0.875 c 0.0547,-1.49478 -0.60613,-2.24218 -1.98243,-2.24219 -0.39193,1e-5 -0.76335,0.35092 -1.11425,1.05274 -0.35092,0.70183 -0.8545,1.08008 -1.51075,1.13476 -0.7474,0.0729 -1.12109,-0.24153 -1.12109,-0.94336 0,-0.43749 0.55599,-0.9479 1.66797,-1.53125 1.16666,-0.61066 2.28775,-0.916 3.36328,-0.91601 1.85025,10e-6 2.76627,0.87957 2.74805,2.63867 l -0.0547,5.63281 c -0.009,0.59245 0.24153,0.88868 0.75195,0.88867 0.10025,1e-5 0.29166,-0.0228 0.57422,-0.0684 0.28254,-0.0456 0.4466,-0.0684 0.49219,-0.0684 0.26431,0 0.39647,0.17773 0.39648,0.5332 z m -4.21093,-3.11719 c 0.009,-0.22786 -0.0433,-0.37825 -0.15723,-0.45117 -0.11394,-0.0729 -0.29395,-0.0866 -0.54004,-0.041 -2.19662,0.39194 -3.29493,1.10743 -3.29492,2.14649 -1e-5,1.04818 0.56965,1.57226 1.70898,1.57226 0.45573,0 0.92513,-0.0866 1.40821,-0.25976 0.56509,-0.20052 0.84764,-0.44206 0.84765,-0.72461 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2873"" />
      <path
         d=""m 415.11343,156.58859 c -10e-6,1.70443 -0.57195,3.15137 -1.71582,4.34082 -1.14389,1.18946 -2.47689,1.78418 -3.99902,1.78418 -0.92058,0 -1.80925,-0.16406 -2.66602,-0.49218 -0.0912,-0.0365 -0.13672,0.18684 -0.13671,0.66992 l 0,4.11523 c -1e-5,0.66536 0.54231,1.09375 1.62695,1.28516 0.50129,0.0911 0.81803,0.17545 0.95019,0.25293 0.13216,0.0775 0.19824,0.20735 0.19825,0.38965 -10e-6,0.30988 -0.20509,0.45116 -0.61524,0.42382 -1.91407,-0.12761 -3.5957,-0.082 -5.04492,0.13672 -0.30078,0.0456 -0.48763,0.0456 -0.56055,0 -0.0729,-0.0456 -0.10937,-0.16862 -0.10937,-0.36914 0,-0.15495 0.25976,-0.3418 0.7793,-0.56054 0.44661,-0.1823 0.66991,-0.6198 0.66992,-1.3125 l 0,-12.0586 c -10e-6,-0.97525 -0.26889,-1.58593 -0.80664,-1.83203 -0.63803,-0.28254 -0.95704,-0.51496 -0.95703,-0.69727 -10e-6,-0.20051 0.18684,-0.3509 0.56054,-0.45117 0.48307,-0.11848 0.97982,-0.32811 1.49024,-0.6289 0.42838,-0.24609 0.68814,-0.36913 0.77929,-0.36914 0.27344,1e-5 0.49674,0.25066 0.66993,0.75195 0.2552,0.72918 0.42382,1.09376 0.50585,1.09375 0.0182,1e-5 0.41016,-0.21418 1.17579,-0.64258 0.83853,-0.46483 1.65884,-0.69725 2.46093,-0.69726 1.30338,1e-5 2.3789,0.36915 3.22657,1.10742 1.0117,0.86589 1.51756,2.11915 1.51757,3.75976 z m -2.32421,1.09375 c -2e-5,-1.48567 -0.36916,-2.64322 -1.10743,-3.47265 -0.60157,-0.6927 -1.30795,-1.03906 -2.11914,-1.03907 -0.62891,10e-6 -1.23047,0.21876 -1.80468,0.65625 -0.75652,0.56512 -1.13478,1.35353 -1.13477,2.36524 l 0,3.86914 c -10e-6,0.24609 0.34635,0.50586 1.03906,0.7793 0.74739,0.30078 1.55859,0.45117 2.4336,0.45117 1.79556,0 2.69334,-1.20313 2.69336,-3.60938 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2875"" />
      <path
         d=""m 429.20914,156.95773 c -2e-5,1.58594 -0.58791,2.92807 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43555 0.96613,0.92969 1.4492,2.1875 1.44922,3.77343 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2877"" />
      <path
         d=""m 441.19937,160.70383 c -10e-6,0.33724 -0.46941,0.74739 -1.4082,1.23047 -1.02084,0.51953 -2.028,0.77929 -3.02149,0.77929 -1.54948,0 -2.81641,-0.4375 -3.80078,-1.3125 -1.02995,-0.92968 -1.54492,-2.18749 -1.54492,-3.77343 0,-1.70443 0.59245,-3.12174 1.77734,-4.25196 1.15755,-1.10285 2.57943,-1.65428 4.26563,-1.65429 1.02082,1e-5 1.9095,0.14584 2.66602,0.4375 0.69269,0.27344 1.03905,0.56511 1.03906,0.875 -1e-5,0.20964 -0.17091,0.52865 -0.5127,0.95703 -0.3418,0.42839 -0.62208,0.64258 -0.84082,0.64257 -0.13673,1e-5 -0.45118,-0.19595 -0.94336,-0.58789 -0.92058,-0.72915 -1.64063,-1.09374 -2.16015,-1.09375 -0.82032,10e-6 -1.4948,0.30991 -2.02344,0.92969 -0.55599,0.67449 -0.83399,1.60417 -0.83399,2.78906 0,1.431 0.40104,2.57488 1.20313,3.43164 0.72916,0.77475 1.60872,1.16211 2.63867,1.16211 1.02083,0 1.98241,-0.28255 2.88477,-0.84765 0.082,-0.0547 0.19139,-0.082 0.32812,-0.082 0.1914,0 0.2871,0.12305 0.28711,0.36914 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2879"" />
      <path
         d=""m 456.73062,161.98898 c -10e-6,0.31901 -0.21421,0.48763 -0.64258,0.50586 -0.63803,0.009 -1.47201,0.0547 -2.50195,0.13672 -0.51043,0.10026 -0.87501,0.0365 -1.09375,-0.1914 -1.44011,-1.54948 -2.66147,-3.17188 -3.66406,-4.86719 -0.082,-0.14583 -0.18686,-0.21875 -0.31446,-0.21875 -0.15495,0 -0.42383,0.13672 -0.80664,0.41015 -0.42839,0.23699 -0.64258,0.57423 -0.64257,1.01172 -1e-5,0.3099 0.009,0.75652 0.0273,1.33985 0.0182,0.58333 0.16406,0.96614 0.4375,1.14843 0.1914,0.12761 0.63346,0.22787 1.32617,0.30079 0.42838,0.0547 0.64257,0.21419 0.64258,0.47851 -10e-6,0.20964 -0.0342,0.33952 -0.10254,0.38965 -0.0684,0.0501 -0.24838,0.0615 -0.54004,0.0342 -0.91146,-0.082 -2.45183,-0.0365 -4.62109,0.13672 -0.54688,0.0456 -0.8431,-0.0228 -0.88867,-0.20508 -0.0182,-0.0638 -0.0274,-0.15495 -0.0274,-0.27344 0,-0.28255 0.278,-0.49674 0.83399,-0.64258 0.5013,-0.1276 0.75195,-0.71549 0.75195,-1.76367 l 0,-11.94922 c 0,-0.74738 -0.0729,-1.26691 -0.21875,-1.55859 -0.20052,-0.37368 -0.61979,-0.66535 -1.25781,-0.875 -0.30079,-0.10024 -0.45118,-0.24152 -0.45117,-0.42383 -10e-6,-0.2643 0.21419,-0.46938 0.64257,-0.61523 0.68359,-0.22785 1.33529,-0.5423 1.95508,-0.94336 0.5013,-0.32811 0.8112,-0.49217 0.92969,-0.49219 0.37369,2e-5 0.56054,0.237 0.56055,0.71094 -1e-5,-0.0638 -0.005,0.38739 -0.0137,1.35351 -0.009,0.66538 -0.0137,1.55861 -0.0137,2.67969 l 0.0274,8.55859 c -1e-5,0.23699 0.0638,0.35548 0.1914,0.35547 0.13672,1e-5 0.34635,-0.11848 0.62891,-0.35547 0.7565,-0.59244 1.68619,-1.36718 2.78906,-2.32421 0.21874,-0.22786 0.32812,-0.41015 0.32813,-0.54688 -1e-5,-0.24608 -0.36915,-0.41926 -1.10743,-0.51953 -0.31901,-0.0365 -0.4694,-0.21418 -0.45117,-0.5332 0.0273,-0.319 0.18684,-0.45572 0.47852,-0.41016 0.65624,0.0912 1.61327,0.14129 2.87109,0.15039 0.87499,0.009 1.74543,0.0137 2.61133,0.0137 0.28254,0.009 0.42381,0.17775 0.42383,0.50586 -2e-5,0.30991 -0.22332,0.47853 -0.66992,0.50586 -0.70184,0.0273 -1.36265,0.18686 -1.98243,0.47852 -0.86589,0.39193 -1.79102,1.08008 -2.77539,2.06445 -0.0729,0.0547 -0.10938,0.12305 -0.10937,0.20508 -1e-5,0.12761 0.15494,0.43295 0.46484,0.91601 1.13932,1.73178 2.21484,3.03972 3.22656,3.92383 0.64713,0.55599 1.25325,0.83399 1.81836,0.83399 0.41926,0 0.67903,0.0296 0.7793,0.0889 0.10025,0.0592 0.15038,0.21648 0.15039,0.47168 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2881"" />
      <path
         d=""m 468.26968,160.17062 c -10e-6,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -1e-5,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2883"" />
      <path
         d=""m 477.81265,161.18234 c -1e-5,0.4375 -0.40105,0.8112 -1.20312,1.1211 -0.71095,0.27343 -1.431,0.41015 -2.16016,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43294,-0.28027 -0.99804,-0.41699 -0.14584,-0.0365 -0.21875,-0.17773 -0.21875,-0.42383 0,-0.26432 0.0547,-0.42382 0.16406,-0.47852 0.98437,-0.48306 1.84114,-1.34895 2.57031,-2.59765 0.10026,-0.17317 0.29622,-0.22786 0.58789,-0.16407 0.20052,0.0638 0.30534,0.18231 0.31446,0.35547 l 0.0547,1.70899 c 0,0.12761 0.0228,0.21876 0.0684,0.27343 0.0638,0.0821 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17317,1e-5 0.17317,0.2142 0,0.64258 -0.20964,0.51954 -0.51954,0.7793 -0.92969,0.7793 l -2.06445,0 c -0.35547,0 -0.57422,0.0593 -0.65625,0.17773 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c -10e-6,1.13022 0.10025,1.84571 0.30078,2.14649 0.26432,0.38281 0.87955,0.57422 1.8457,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69726,-0.15722 0.72461,-0.15723 0.10937,1e-5 0.16405,0.0684 0.16406,0.20508 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2885"" />
      <path
         d=""m 267.56656,187.18898 c -2e-5,0.31901 -0.21421,0.48763 -0.64258,0.50586 -0.63803,0.009 -1.47202,0.0547 -2.50195,0.13672 -0.51043,0.10026 -0.87501,0.0365 -1.09375,-0.19141 -1.44012,-1.54947 -2.66147,-3.17187 -3.66406,-4.86718 -0.082,-0.14583 -0.18686,-0.21875 -0.31446,-0.21875 -0.15495,0 -0.42383,0.13672 -0.80664,0.41015 -0.42839,0.23699 -0.64258,0.57423 -0.64258,1.01172 0,0.3099 0.009,0.75652 0.0274,1.33985 0.0182,0.58333 0.16405,0.96614 0.4375,1.14843 0.1914,0.12761 0.63345,0.22787 1.32617,0.30078 0.42838,0.0547 0.64257,0.2142 0.64258,0.47852 -10e-6,0.20964 -0.0342,0.33952 -0.10254,0.38965 -0.0684,0.0501 -0.24838,0.0615 -0.54004,0.0342 -0.91147,-0.082 -2.45183,-0.0365 -4.62109,0.13672 -0.54688,0.0456 -0.8431,-0.0228 -0.88868,-0.20508 -0.0182,-0.0638 -0.0273,-0.15495 -0.0273,-0.27344 0,-0.28255 0.27799,-0.49674 0.83398,-0.64258 0.5013,-0.1276 0.75195,-0.71549 0.75196,-1.76367 l 0,-11.94922 c -1e-5,-0.74738 -0.0729,-1.26691 -0.21875,-1.55859 -0.20053,-0.37368 -0.6198,-0.66535 -1.25782,-0.875 -0.30078,-0.10024 -0.45117,-0.24152 -0.45117,-0.42383 0,-0.2643 0.21419,-0.46938 0.64258,-0.61523 0.68359,-0.22785 1.33528,-0.5423 1.95508,-0.94336 0.5013,-0.32811 0.81119,-0.49217 0.92969,-0.49219 0.37369,2e-5 0.56054,0.237 0.56054,0.71094 0,-0.0638 -0.005,0.38739 -0.0137,1.35351 -0.009,0.66538 -0.0137,1.55861 -0.0137,2.67969 l 0.0273,8.55859 c 0,0.23699 0.0638,0.35548 0.19141,0.35547 0.13671,1e-5 0.34635,-0.11848 0.62891,-0.35547 0.7565,-0.59244 1.68619,-1.36718 2.78906,-2.32422 0.21874,-0.22785 0.32811,-0.41014 0.32812,-0.54687 -10e-6,-0.24608 -0.36915,-0.41926 -1.10742,-0.51953 -0.31902,-0.0365 -0.46941,-0.21418 -0.45117,-0.5332 0.0273,-0.319 0.18684,-0.45572 0.47852,-0.41016 0.65624,0.0912 1.61327,0.14129 2.87109,0.15039 0.87499,0.009 1.74543,0.0137 2.61133,0.0137 0.28254,0.009 0.42381,0.17775 0.42383,0.50586 -2e-5,0.30991 -0.22333,0.47853 -0.66993,0.50586 -0.70183,0.0274 -1.36264,0.18686 -1.98242,0.47852 -0.86589,0.39193 -1.79102,1.08008 -2.77539,2.06445 -0.0729,0.0547 -0.10938,0.12305 -0.10937,0.20508 -1e-5,0.12761 0.15494,0.43295 0.46484,0.91601 1.13931,1.73178 2.21483,3.03972 3.22656,3.92383 0.64713,0.55599 1.25324,0.83399 1.81836,0.83399 0.41926,0 0.67902,0.0296 0.7793,0.0889 0.10024,0.0592 0.15037,0.21647 0.15039,0.47168 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2887"" />
      <path
         d=""m 283.31656,187.4214 c -2e-5,0.28256 -0.20509,0.41016 -0.61524,0.38282 -1.95964,-0.10026 -3.44532,-0.11849 -4.45703,-0.0547 -0.51954,0.0365 -0.80209,-0.0273 -0.84765,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0274,-0.23242 -10e-6,-0.18229 0.26432,-0.34635 0.79297,-0.49219 0.48306,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.81121,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65626,0.37371 -0.98438,0.76108 -0.98438,1.16211 l 0,5.00391 c 0,0.85677 0.56055,1.33528 1.68164,1.43554 0.42838,0.0365 0.64258,0.17318 0.64258,0.41016 0,0.22786 -0.0593,0.36458 -0.17773,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46485,0.0137 -1.43099,-0.0547 -2.90755,0.0182 -4.42968,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61524,0.041 -0.18229,-0.0365 -0.27344,-0.17773 -0.27343,-0.42382 -10e-6,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27344,-1.33984 -0.1276,-0.13671 -0.55143,-0.32812 -1.27148,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51041,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98437,-0.51953 0.24609,1e-5 0.41016,0.28029 0.49219,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55011,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64256,0.33724 1.27148,0.46484 0.41015,0.082 0.61522,0.23242 0.61524,0.45117 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2889"" />
      <path
         d=""m 289.48257,171.84914 c 0,0.41928 -0.15723,0.80893 -0.47168,1.16894 -0.31445,0.36004 -0.65853,0.54006 -1.03222,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05274,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41015,-0.99805 -1e-5,-0.40102 0.16634,-0.77472 0.49902,-1.12109 0.33268,-0.34634 0.69043,-0.51951 1.07324,-0.51953 0.92969,2e-5 1.39453,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15495,0.41471 -0.32812,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69337,-0.0729 -4.00586,0.0547 -0.35547,0.0365 -0.57878,0.0228 -0.66992,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13672,-0.4375 0,-0.20963 0.24153,-0.38281 0.72461,-0.51953 0.52864,-0.15495 0.79296,-0.66081 0.79297,-1.51758 l 0,-3.58203 c -1e-5,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20053,-0.40103 -0.61524,-0.70637 -1.24414,-0.91601 -0.28256,-0.10026 -0.42383,-0.25065 -0.42383,-0.45118 0,-0.26431 0.20507,-0.46027 0.61523,-0.58789 0.76562,-0.23697 1.44466,-0.55142 2.03711,-0.94336 0.47395,-0.32811 0.76562,-0.49217 0.875,-0.49218 0.36458,1e-5 0.54231,0.23699 0.5332,0.71093 -0.0365,2.38803 -0.0547,4.82162 -0.0547,7.30079 -10e-6,0.59245 0.0866,1.01627 0.25976,1.27148 0.1914,0.28255 0.55599,0.48307 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2891"" />
      <path
         d=""m 303.00406,169.01906 c -10e-6,0.38283 -0.17319,0.82945 -0.51953,1.33984 -0.34637,0.51044 -0.6198,0.76565 -0.82031,0.76563 -0.24611,2e-5 -0.50587,-0.12303 -0.7793,-0.36914 -0.57423,-0.41014 -1.08009,-0.61522 -1.51758,-0.61524 -1.73178,2e-5 -2.59766,1.21226 -2.59766,3.63672 l 0,2.93946 c 0,0.45574 0.39193,0.6517 1.17579,0.58789 l 1.73632,-0.13672 c 0.68359,-0.0547 1.05729,0.0547 1.1211,0.32812 0.0182,0.0912 0.0273,0.22332 0.0273,0.39649 -10e-6,0.3737 -0.0911,0.60613 -0.27344,0.69726 -0.10938,0.0638 -0.39193,0.0957 -0.84765,0.0957 l -1.73633,0 c -0.77475,1e-5 -1.17579,0.16407 -1.20313,0.49218 -0.0182,0.19142 -0.0182,2.17384 0,5.94727 0,0.51042 0.23698,0.875 0.71094,1.09375 0.35546,0.17318 0.94791,0.29167 1.77735,0.35547 0.32811,0.0273 0.52635,0.0661 0.59472,0.11621 0.0684,0.0501 0.10253,0.19824 0.10254,0.44433 -10e-6,0.28256 -0.0387,0.45118 -0.11621,0.50586 -0.0775,0.0547 -0.27117,0.0729 -0.58105,0.0547 -2.01433,-0.10937 -3.82358,-0.082 -5.42774,0.082 -0.41927,0.0456 -0.67448,0.0456 -0.76562,0 -0.0912,-0.0456 -0.13672,-0.20507 -0.13672,-0.47851 0,-0.22787 0.26432,-0.41472 0.79297,-0.56055 0.6289,-0.17318 0.94335,-0.6289 0.94336,-1.36719 l 0,-5.31836 c -10e-6,-0.55598 -0.0866,-0.94335 -0.25977,-1.16211 -0.11849,-0.14582 -0.34636,-0.27342 -0.68359,-0.38281 -0.52865,-0.16405 -0.79297,-0.42382 -0.79297,-0.7793 0,-0.24608 0.10937,-0.40103 0.32812,-0.46484 0.0729,-0.0182 0.30078,-0.0319 0.6836,-0.041 0.32812,-0.009 0.5332,-0.082 0.61523,-0.21875 0.0547,-0.10025 0.082,-0.34635 0.082,-0.73829 l 0,-2.17382 c 0,-1.73176 0.71094,-3.14908 2.13281,-4.25196 1.35807,-1.04816 3.02604,-1.57224 5.00391,-1.57226 0.8203,2e-5 1.23046,0.25067 1.23047,0.75195 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2893"" />
      <path
         d=""m 312.84781,185.37062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.3763,0 -2.53385,-0.45117 -3.47265,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74543,0.28712 2.5293,0.86133 0.70181,0.51042 1.16665,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35547 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33985,0.95703 l -6.30273,1.87304 c 0.41015,2.16928 1.52213,3.25391 3.33594,3.25391 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24024,-5.48242 c 0,-0.50129 -0.2028,-0.94107 -0.60839,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32812 3.71875,-1.12109 c 0.60156,-0.17317 0.90234,-0.48762 0.90234,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2895"" />
      <path
         d=""m 326.72476,171.84914 c 0,0.41928 -0.15723,0.80893 -0.47168,1.16894 -0.31446,0.36004 -0.65853,0.54006 -1.03222,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05274,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41015,-0.99805 -10e-6,-0.40102 0.16633,-0.77472 0.49902,-1.12109 0.33268,-0.34634 0.69042,-0.51951 1.07324,-0.51953 0.92968,2e-5 1.39453,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15496,0.41471 -0.32812,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69337,-0.0729 -4.00586,0.0547 -0.35548,0.0365 -0.57878,0.0228 -0.66993,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13671,-0.4375 -10e-6,-0.20963 0.24153,-0.38281 0.7246,-0.51953 0.52865,-0.15495 0.79297,-0.66081 0.79297,-1.51758 l 0,-3.58203 c 0,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20052,-0.40103 -0.61523,-0.70637 -1.24414,-0.91601 -0.28255,-0.10026 -0.42383,-0.25065 -0.42383,-0.45118 0,-0.26431 0.20508,-0.46027 0.61524,-0.58789 0.76562,-0.23697 1.44466,-0.55142 2.03711,-0.94336 0.47395,-0.32811 0.76562,-0.49217 0.875,-0.49218 0.36458,1e-5 0.54231,0.23699 0.5332,0.71093 -0.0365,2.38803 -0.0547,4.82162 -0.0547,7.30079 0,0.59245 0.0866,1.01627 0.25977,1.27148 0.1914,0.28255 0.55598,0.48307 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2897"" />
      <path
         d=""m 338.55093,184.72804 c -10e-6,0.96615 -0.37142,1.73406 -1.11425,2.30372 -0.74285,0.56966 -1.75685,0.85449 -3.042,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10937,-0.73372 0.32813,-0.75195 0.21874,-0.0273 0.40559,0.0911 0.56054,0.35547 0.68359,1.19401 1.78646,1.79101 3.3086,1.79101 1.28514,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39193 -0.14584,-0.72005 -0.4375,-0.98438 -0.31902,-0.30077 -0.93881,-0.65168 -1.85937,-1.05273 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13477,-2.29687 0.70181,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17773 0.65624,0.1185 0.99804,0.26434 1.02539,0.4375 0.0729,0.51043 0.2233,1.24871 0.45117,2.21485 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17578 -1.63152,-1.76367 -2.73438,-1.76368 -1.2487,1e-5 -1.87305,0.40106 -1.87304,1.20313 -10e-6,0.44662 0.16861,0.80209 0.50585,1.06641 0.30078,0.22787 1.00716,0.58334 2.11915,1.0664 1.16665,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.8203,1.2168 0.82031,2.09179 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2899"" />
      <path
         d=""m 362.44937,187.4214 c -10e-6,0.28256 -0.20509,0.41016 -0.61523,0.38282 -1.95965,-0.10026 -3.44533,-0.11849 -4.45703,-0.0547 -0.51955,0.0365 -0.8021,-0.0273 -0.84766,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0273,-0.23242 -1e-5,-0.18229 0.26431,-0.34635 0.79296,-0.49219 0.48307,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.8112,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65625,0.37371 -0.98438,0.76108 -0.98437,1.16211 l 0,5.00391 c -10e-6,0.85677 0.56054,1.33528 1.68164,1.43554 0.42838,0.0365 0.64257,0.17318 0.64258,0.41016 -10e-6,0.22786 -0.0593,0.36458 -0.17774,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46484,0.0137 -1.431,-0.0547 -2.90756,0.0182 -4.42969,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61523,0.041 -0.1823,-0.0365 -0.27344,-0.17773 -0.27344,-0.42382 0,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27343,-1.33984 -0.12761,-0.13671 -0.55144,-0.32812 -1.27149,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51042,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98438,-0.51953 0.24609,1e-5 0.41015,0.28029 0.49218,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55012,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64257,0.33724 1.27149,0.46484 0.41014,0.082 0.61522,0.23242 0.61523,0.45117 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2901"" />
      <path
         d=""m 375.39664,182.15773 c -2e-5,1.58594 -0.58791,2.92806 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43554 0.96613,0.9297 1.4492,2.18751 1.44922,3.77344 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2903"" />
      <path
         d=""m 385.17203,186.38234 c -1e-5,0.4375 -0.40105,0.8112 -1.20313,1.1211 -0.71094,0.27343 -1.43099,0.41015 -2.16015,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43295,-0.28027 -0.99805,-0.417 -0.14583,-0.0364 -0.21875,-0.17772 -0.21875,-0.42382 0,-0.26432 0.0547,-0.42382 0.16406,-0.47852 0.98438,-0.48306 1.84115,-1.34895 2.57032,-2.59766 0.10025,-0.17316 0.29622,-0.22785 0.58789,-0.16406 0.20051,0.0638 0.30533,0.18231 0.31445,0.35547 l 0.0547,1.70898 c -1e-5,0.12762 0.0228,0.21877 0.0684,0.27344 0.0638,0.082 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17316,1e-5 0.17316,0.2142 0,0.64258 -0.20965,0.51954 -0.51954,0.7793 -0.92969,0.77929 l -2.06445,0 c -0.35548,1e-5 -0.57423,0.0593 -0.65625,0.17774 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c 0,1.13021 0.10026,1.84571 0.30078,2.14649 0.26432,0.38281 0.87955,0.57422 1.84571,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69725,-0.15722 0.72461,-0.15723 0.10936,1e-5 0.16405,0.0684 0.16406,0.20508 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2905"" />
      <path
         d=""m 404.23062,185.37062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35547 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87304 c 0.41015,2.16928 1.52213,3.25391 3.33594,3.25391 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32812 3.71875,-1.12109 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2907"" />
      <path
         d=""m 420.63687,187.4214 c -10e-6,0.28256 -0.20509,0.41016 -0.61523,0.38282 -1.95965,-0.10026 -3.44533,-0.11849 -4.45703,-0.0547 -0.51955,0.0365 -0.8021,-0.0273 -0.84766,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0273,-0.23242 -1e-5,-0.18229 0.26431,-0.34635 0.79296,-0.49219 0.48307,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.8112,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65625,0.37371 -0.98438,0.76108 -0.98437,1.16211 l 0,5.00391 c -10e-6,0.85677 0.56054,1.33528 1.68164,1.43554 0.42838,0.0365 0.64257,0.17318 0.64258,0.41016 -10e-6,0.22786 -0.0593,0.36458 -0.17774,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46484,0.0137 -1.431,-0.0547 -2.90756,0.0182 -4.42969,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61523,0.041 -0.1823,-0.0365 -0.27344,-0.17773 -0.27344,-0.42382 0,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27343,-1.33984 -0.12761,-0.13671 -0.55144,-0.32812 -1.27149,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51042,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98438,-0.51953 0.24609,1e-5 0.41015,0.28029 0.49218,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55012,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64257,0.33724 1.27149,0.46484 0.41014,0.082 0.61522,0.23242 0.61523,0.45117 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2909"" />
      <path
         d=""m 433.58414,182.15773 c -2e-5,1.58594 -0.58791,2.92806 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43554 0.96613,0.9297 1.4492,2.18751 1.44922,3.77344 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2911"" />
      <path
         d=""m 448.65054,186.51906 c -10e-6,0.18229 -0.4284,0.46029 -1.28515,0.83398 -0.72918,0.31902 -1.09376,0.47852 -1.09375,0.47852 -0.1185,0 -0.37143,-0.20508 -0.75879,-0.61523 -0.38738,-0.41016 -0.65854,-0.61524 -0.81348,-0.61524 -0.082,0 -0.55144,0.19141 -1.4082,0.57422 -0.85678,0.38281 -1.60873,0.57422 -2.25586,0.57422 -1.36719,0 -2.31967,-0.25977 -2.85742,-0.7793 -0.58334,-0.55599 -0.87501,-1.56315 -0.875,-3.02148 l 0,-2.74805 c -10e-6,-0.76562 -0.0775,-1.30338 -0.23242,-1.61328 -0.20964,-0.3828 -0.63347,-0.67447 -1.27149,-0.875 -0.20964,-0.0638 -0.31445,-0.17773 -0.31445,-0.3418 0,-0.18228 0.17773,-0.34178 0.5332,-0.47851 0.67448,-0.26432 1.3444,-0.5332 2.00977,-0.80664 0.46484,-0.1914 0.80208,-0.2871 1.01172,-0.28711 0.319,1e-5 0.47851,0.2142 0.47851,0.64258 0,10e-6 -0.0137,0.4808 -0.041,1.44238 -0.0274,0.96159 -0.041,1.87533 -0.041,2.74121 l 0,1.64062 c -10e-6,1.11199 0.21874,1.87305 0.65625,2.28321 0.39192,0.36458 1.10741,0.54687 2.14648,0.54687 1.60416,0 2.40624,-0.82031 2.40625,-2.46094 l 0,-2.43359 c -10e-6,-0.88411 -0.0798,-1.45149 -0.23925,-1.70215 -0.15952,-0.25064 -0.58563,-0.46711 -1.27832,-0.64941 -0.20053,-0.082 -0.30079,-0.2233 -0.30079,-0.42383 0,-0.20963 0.12304,-0.36002 0.36915,-0.45117 1.8867,-0.68358 2.92121,-1.02538 3.10351,-1.02539 0.35546,1e-5 0.53319,0.20509 0.5332,0.61523 -10e-6,-0.009 -0.0137,0.44891 -0.041,1.37403 -0.0274,0.92513 -0.041,1.82064 -0.041,2.68652 l 0,3.44531 c -1e-5,0.64714 0.47395,1.00716 1.42188,1.08008 0.31899,0.0273 0.4785,0.15039 0.47851,0.36914 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2913"" />
      <path
         d=""m 462.54117,178.58937 c -0.0912,0.67449 -0.32814,1.01173 -0.71094,1.01172 -0.13673,1e-5 -0.39194,-0.0273 -0.76562,-0.082 -0.16408,-0.0182 -0.27801,-0.0273 -0.3418,-0.0273 -0.12762,0.009 -0.19142,0.0912 -0.19141,0.24609 -1e-5,0.0456 0.009,0.18686 0.0273,0.42383 0.0182,0.23699 0.0273,0.47852 0.0273,0.72461 -1e-5,1.97787 -1.28061,3.32227 -3.8418,4.0332 -1.51302,0.41927 -2.26953,0.75651 -2.26953,1.01172 0,0.26432 0.56054,0.4694 1.68164,0.61523 l 2.13282,0.28711 c 1.194,0.15495 2.06899,0.37826 2.625,0.66993 0.8841,0.46484 1.32615,1.18033 1.32617,2.14648 -2e-5,1.35807 -0.77931,2.51562 -2.33789,3.47266 -1.51303,0.92056 -3.27215,1.38085 -5.27735,1.38086 -1.23958,-1e-5 -2.22624,-0.25066 -2.95996,-0.75196 -0.73372,-0.50131 -1.10059,-1.16667 -1.10058,-1.99609 -1e-5,-1.25782 0.87499,-2.46094 2.625,-3.60938 -0.80209,-0.32812 -1.20313,-0.84309 -1.20313,-1.54492 0,-0.65625 0.74739,-1.25325 2.24219,-1.79101 -2.15105,-0.57422 -3.22657,-1.83203 -3.22656,-3.77344 -1e-5,-1.21223 0.43977,-2.21711 1.31933,-3.01465 0.87956,-0.79752 1.98925,-1.19628 3.3291,-1.19629 0.95703,10e-6 1.89127,0.21876 2.80274,0.65625 0.60155,0.28256 1.35806,0.41017 2.26953,0.38281 l 1.20312,-0.0273 c 0.30989,-0.009 0.50129,0.0319 0.57422,0.12305 0.0729,0.0912 0.0866,0.30079 0.041,0.6289 z m -4.08789,2.55664 c -1e-5,-2.11457 -0.91147,-3.17186 -2.73438,-3.17187 -1.54948,1e-5 -2.32422,0.97983 -2.32422,2.93945 0,1.94141 0.85677,2.91212 2.57032,2.91211 0.71093,10e-6 1.30337,-0.25065 1.77734,-0.75195 0.47395,-0.5013 0.71093,-1.14388 0.71094,-1.92774 z m 2.16015,9.32422 c -10e-6,-0.69271 -0.83855,-1.16211 -2.51562,-1.4082 l -2.7207,-0.38281 c -0.25522,-0.0456 -0.61069,-0.11394 -1.06641,-0.20508 -0.96615,0.77474 -1.44922,1.73632 -1.44922,2.88476 0,1.29427 0.875,1.9414 2.625,1.94141 1.35807,-1e-5 2.5703,-0.32357 3.63672,-0.9707 0.99348,-0.59245 1.49022,-1.21225 1.49023,-1.85938 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2915"" />
      <path
         d=""m 478.3732,187.35304 c -2e-5,0.30079 -0.20509,0.44206 -0.61523,0.42383 -2.28778,-0.082 -3.77345,-0.10026 -4.45704,-0.0547 -0.33725,0.0273 -0.53777,0.0319 -0.60156,0.0137 -0.17319,-0.0456 -0.25977,-0.19141 -0.25976,-0.4375 -1e-5,-0.17318 0.25975,-0.33724 0.77929,-0.49219 0.34635,-0.10937 0.5651,-0.27799 0.65625,-0.50586 0.0456,-0.1276 0.0683,-0.41927 0.0684,-0.875 l 0,-3.69141 c -1e-5,-2.1328 -0.90235,-3.19921 -2.70703,-3.19921 -0.80209,0 -1.55404,0.19141 -2.25586,0.57421 -0.66537,0.3646 -0.99805,0.72462 -0.99805,1.08008 l 0,5.20899 c 0,0.875 0.56055,1.37174 1.68165,1.49023 0.42837,0.0365 0.64257,0.17318 0.64257,0.41016 0,0.18229 -0.0319,0.30078 -0.0957,0.35547 -0.0638,0.0547 -0.2461,0.0775 -0.54687,0.0684 -1.44923,-0.0547 -2.92579,-0.0182 -4.42969,0.10937 -0.32813,0.0273 -0.53321,0.0319 -0.61524,0.0137 -0.18229,-0.0365 -0.27344,-0.17773 -0.27343,-0.42383 -1e-5,-0.20052 0.25976,-0.36914 0.77929,-0.50586 0.48307,-0.13671 0.72461,-0.63346 0.72461,-1.49023 l 0,-12.37305 c 0,-0.72003 -0.0729,-1.24412 -0.21875,-1.57226 -0.20964,-0.43749 -0.62891,-0.76105 -1.25781,-0.97071 -0.2461,-0.082 -0.36914,-0.2324 -0.36914,-0.45117 0,-0.15493 0.18685,-0.31443 0.56055,-0.47851 0.5013,-0.22785 1.13932,-0.56053 1.91406,-0.99805 0.5013,-0.28253 0.84309,-0.42381 1.02539,-0.42383 0.33723,2e-5 0.50585,0.23244 0.50586,0.69727 -1e-5,-0.009 -0.0137,0.44435 -0.041,1.36035 -0.0274,0.91603 -0.041,1.80698 -0.041,2.67285 l 0,4.67578 c -10e-6,0.50131 0.0729,0.75196 0.21875,0.75196 -0.082,0 0.37597,-0.26204 1.37402,-0.78614 0.99804,-0.52408 1.94368,-0.78612 2.83691,-0.78613 2.42447,1e-5 3.64583,1.34441 3.66407,4.0332 l 0.0273,4.6211 c 0.009,0.92057 0.57876,1.43554 1.70899,1.54492 0.41014,0.0365 0.61521,0.17318 0.61523,0.41015 z""
         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2917"" />
    </g>
    <g
       style=""font-size:40px;font-style:normal;font-weight:normal;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Vera Sans""
       id=""text3850"">
      <path
         d=""m 229.85182,43.77803 c -0.79695,3.140714 -1.28913,8.414146 -1.47656,15.820313 -7e-5,1.453199 -0.65632,2.179761 -1.96875,2.179687 -1.31257,7.4e-5 -2.22663,-0.632738 -2.74219,-1.898437 -1.40631,-3.421796 -2.74225,-5.812419 -4.00781,-7.171875 -1.50006,-1.593666 -3.49225,-2.554603 -5.97656,-2.882813 -2.67193,-0.421789 -9.32818,-0.632726 -19.96875,-0.632812 -2.43754,8.6e-5 -4.03129,0.257898 -4.78125,0.773437 -0.46879,0.32821 -0.70316,1.031335 -0.70313,2.109375 l 0,31.851563 c -3e-5,1.078175 0.67966,1.5938 2.03906,1.546875 4.17184,-0.04682 10.21871,-0.328075 18.14063,-0.84375 1.54682,-0.187449 2.58979,-0.691355 3.12891,-1.511719 0.539,-0.820259 1.06634,-2.941351 1.58203,-6.363281 0.32806,-1.87494 1.42963,-2.601502 3.30468,-2.179688 1.59369,0.328186 2.27338,1.054747 2.03907,2.179688 -1.31256,6.375052 -1.73444,14.671919 -1.26563,24.890627 0.0468,1.21878 -0.72662,1.87503 -2.32031,1.96875 -1.31256,0.14065 -2.13287,-0.56247 -2.46094,-2.10938 -1.2188,-5.859333 -3.48052,-8.988236 -6.78515,-9.386716 -3.30474,-0.398394 -8.68364,-0.597612 -16.13672,-0.597656 -0.84379,4.4e-5 -1.26566,0.304731 -1.26563,0.914062 l 0,31.64063 c -3e-5,2.34375 0.86716,3.9375 2.60156,4.78125 1.35934,0.70313 4.28903,1.33594 8.78907,1.89843 2.29683,0.23438 3.30464,1.24219 3.02343,3.02344 -0.28129,1.54688 -2.34379,2.15625 -6.1875,1.82813 -11.1094,-0.89063 -20.27345,-0.84375 -27.49218,0.14062 -2.01564,0.28125 -3.02345,-0.53906 -3.02344,-2.46094 -1e-5,-1.21874 1.0078,-1.92187 3.02344,-2.10937 4.59373,-0.51562 6.8906,-4.54687 6.89062,-12.09375 l 0,-60.187502 c -2e-5,-3.093671 -0.5508,-5.472575 -1.65234,-7.136719 -1.10158,-1.663977 -3.15236,-3.175695 -6.15235,-4.535156 -1.87501,-0.843661 -2.57813,-1.992098 -2.10937,-3.445313 0.23436,-0.890532 0.60936,-1.382719 1.125,-1.476562 0.46874,-0.140532 1.71092,-0.04678 3.72656,0.28125 2.95311,0.468842 9.91404,0.703217 20.88281,0.703125 12.93746,9.2e-5 24.11713,-0.281158 33.53907,-0.84375 3.14055,-0.187407 4.71086,0.07041 4.71093,0.773437 -7e-5,0.187592 -0.0235,0.375092 -0.0703,0.5625 z""
         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2830"" />
      <path
         d=""m 275.55495,133.14522 c -4e-5,1.875 -1.05473,2.69531 -3.16407,2.46094 -6.46877,-0.60938 -14.48439,-0.51563 -24.04687,0.28125 -1.92189,0.18749 -3.10548,0.14062 -3.55078,-0.14063 -0.44532,-0.28125 -0.66798,-1.05469 -0.66797,-2.32031 -1e-5,-1.125 1.27733,-2.07422 3.83203,-2.84766 2.55467,-0.77343 3.83202,-3.08202 3.83203,-6.92578 l 0,-63.632812 c -1e-5,-3.796796 -0.55079,-6.585856 -1.65234,-8.367188 -1.10158,-1.781164 -3.03517,-3.163975 -5.80078,-4.148437 -1.45313,-0.515537 -2.1797,-1.242099 -2.17969,-2.179688 -1e-5,-1.406158 1.05468,-2.460845 3.16406,-3.164062 3.18749,-1.031156 6.49217,-2.624904 9.91406,-4.78125 2.81248,-1.687401 4.59373,-2.53115 5.34375,-2.53125 1.73435,1e-4 2.60154,1.195412 2.60157,3.585937 -3e-5,-0.187403 -0.0938,2.156345 -0.28125,7.03125 -0.14065,4.64071 -0.18753,9.211018 -0.14063,13.710938 l 0.28125,62.789062 c -2e-5,2.85939 0.7031,4.9336 2.10938,6.22266 1.40622,1.28906 3.82028,2.14453 7.24218,2.5664 2.10934,0.23438 3.16403,1.03126 3.16407,2.39063 z""
         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2832"" />
      <path
         d=""m 339.67995,128.43428 c -7e-5,0.98438 -1.79303,2.47266 -5.37891,4.46484 -3.58599,1.99219 -6.45708,2.98828 -8.61328,2.98829 -1.82817,-10e-6 -3.44536,-0.89063 -4.85156,-2.67188 -1.40629,-1.78125 -2.39067,-2.67187 -2.95313,-2.67187 -0.42191,0 -2.64847,0.96094 -6.67969,2.88281 -4.03128,1.92187 -8.08596,2.88281 -12.16406,2.88281 -3.84377,0 -7.0547,-1.125 -9.63281,-3.375 -2.81251,-2.48437 -4.21876,-5.85937 -4.21875,-10.125 -1e-5,-8.10935 9.28123,-13.92185 27.84375,-17.4375 3.18746,-0.60934 4.80465,-1.89841 4.85156,-3.86719 l 0.14063,-4.499997 c 0.28121,-7.687454 -3.11723,-11.5312 -10.19532,-11.53125 -2.01565,5e-5 -3.9258,1.804735 -5.73046,5.414062 -1.80471,3.609416 -4.39456,5.554727 -7.76954,5.835938 -3.84376,0.375038 -5.76563,-1.242148 -5.76562,-4.851563 -1e-5,-2.249954 2.85936,-4.874951 8.57812,-7.875 5.99998,-3.14057 11.7656,-4.710881 17.29688,-4.710937 9.51558,5.6e-5 14.22651,4.523489 14.13281,13.570312 l -0.28125,28.968755 c -0.0469,3.04688 1.24214,4.57032 3.86719,4.57031 0.51557,1e-5 1.49994,-0.11718 2.95312,-0.35156 1.45307,-0.23437 2.29682,-0.35156 2.53125,-0.35157 1.35932,1e-5 2.039,0.91407 2.03907,2.74219 z M 318.0237,112.40303 c 0.0468,-1.17185 -0.2227,-1.94529 -0.8086,-2.32031 -0.58597,-0.37498 -1.51175,-0.44529 -2.77734,-0.21094 -11.2969,2.01565 -16.94533,5.69533 -16.94531,11.03906 -2e-5,5.39064 2.92966,8.08595 8.78906,8.08594 2.34372,1e-5 4.75778,-0.44531 7.24219,-1.33594 2.90621,-1.03124 4.35933,-2.27342 4.35937,-3.72656 z""
         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2834"" />
      <path
         d=""m 392.13307,120.06709 c -5e-5,4.96876 -1.9102,8.91798 -5.73047,11.84766 -3.82035,2.92969 -9.03519,4.39453 -15.64453,4.39453 -4.40627,0 -8.81252,-0.46875 -13.21875,-1.40625 -3.79688,-0.84375 -6.00001,-1.61719 -6.60937,-2.32031 -0.37501,-0.65625 -0.56251,-3.86718 -0.5625,-9.63281 -1e-5,-2.48436 0.56249,-3.77343 1.6875,-3.86719 1.12499,-0.14061 2.08592,0.46876 2.88281,1.82812 3.51561,6.14064 9.18748,9.21095 17.01562,9.21094 6.60934,1e-5 9.91403,-2.29687 9.91407,-6.89062 -4e-5,-2.01562 -0.75004,-3.70311 -2.25,-5.0625 -1.64066,-1.54686 -4.82816,-3.35155 -9.5625,-5.41407 -6.84377,-3.04685 -11.41408,-5.71872 -13.71094,-8.01562 -2.48439,-2.43747 -3.72657,-5.718716 -3.72656,-9.843752 -1e-5,-5.062455 1.9453,-8.999951 5.83593,-11.8125 3.60936,-2.718695 8.43748,-4.078069 14.48438,-4.078125 3.79684,5.6e-5 7.26559,0.304743 10.40625,0.914062 3.37496,0.60943 5.13277,1.359429 5.27344,2.25 0.37495,2.625051 1.14839,6.421922 2.32031,11.390625 0.14058,0.609416 -0.51567,1.101603 -1.96875,1.476563 -1.54692,0.328165 -2.57817,0.07035 -3.09375,-0.773438 -3.70317,-6.046828 -8.39066,-9.070262 -14.0625,-9.070312 -6.4219,5e-5 -9.63283,2.062548 -9.63281,6.1875 -2e-5,2.296916 0.86716,4.12504 2.60156,5.484375 1.54685,1.171912 5.17966,3.000035 10.89844,5.484372 5.99996,2.57816 10.07808,4.89847 12.23437,6.96094 2.81245,2.6719 4.2187,6.25783 4.21875,10.75781 z""
         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2836"" />
      <path
         d=""m 473.69557,132.72334 c -7e-5,1.64063 -1.10163,2.50782 -3.30469,2.60157 -3.28131,0.0469 -7.57037,0.28124 -12.86718,0.70312 -2.62506,0.51562 -4.50006,0.1875 -5.625,-0.98437 -7.4063,-7.96875 -13.68754,-16.31249 -18.84375,-25.03125 -0.42191,-0.74998 -0.96097,-1.12498 -1.61719,-1.125 -0.79691,2e-5 -2.17972,0.70315 -4.14844,2.10937 -2.20315,1.21877 -3.30471,2.95315 -3.30469,5.20313 -2e-5,1.59376 0.0469,3.89064 0.14063,6.89062 0.0937,3.00001 0.84372,4.96876 2.25,5.90625 0.98435,0.65626 3.25778,1.17188 6.82031,1.54688 2.20309,0.28125 3.30465,1.10156 3.30469,2.46093 -4e-5,1.07813 -0.17582,1.7461 -0.52734,2.00391 -0.3516,0.25781 -1.27738,0.31641 -2.77735,0.17578 -4.68753,-0.42187 -12.60939,-0.1875 -23.76562,0.70313 -2.81251,0.23437 -4.33595,-0.11719 -4.57032,-1.05469 -0.0937,-0.32813 -0.14063,-0.79688 -0.14062,-1.40625 -1e-5,-1.45312 1.42968,-2.55469 4.28906,-3.30469 2.57811,-0.65624 3.86718,-3.67968 3.86719,-9.07031 l 0,-61.453127 c -1e-5,-3.843671 -0.37501,-6.515543 -1.125,-8.015625 -1.03126,-1.92179 -3.18751,-3.421788 -6.46875,-4.5 -1.54688,-0.515536 -2.32032,-1.242098 -2.32031,-2.179688 -1e-5,-1.359283 1.10155,-2.413969 3.30468,-3.164062 3.51562,-1.17178 6.86718,-2.788966 10.05469,-4.851563 2.57811,-1.6874 4.17186,-2.531149 4.78125,-2.53125 1.92185,1.01e-4 2.88279,1.21885 2.88281,3.65625 -2e-5,-0.328027 -0.0235,1.992283 -0.0703,6.960938 -0.0469,3.421962 -0.0703,8.015707 -0.0703,13.78125 l 0.14062,44.015627 c -2e-5,1.21878 0.3281,1.82815 0.98438,1.82812 0.7031,3e-5 1.78122,-0.60934 3.23437,-1.82812 3.8906,-3.046842 8.67184,-7.031213 14.34375,-11.953127 1.12496,-1.17183 1.68746,-2.109329 1.6875,-2.8125 -4e-5,-1.265577 -1.89848,-2.156201 -5.69531,-2.671875 -1.64066,-0.18745 -2.4141,-1.101512 -2.32031,-2.742188 0.14059,-1.64057 0.9609,-2.343695 2.46094,-2.109375 3.37495,0.468805 8.29682,0.726617 14.76562,0.773438 4.49994,0.04693 8.9765,0.07037 13.42969,0.07031 1.45306,0.04693 2.17962,0.914116 2.17969,2.601563 -7e-5,1.5938 -1.14851,2.460986 -3.44532,2.601562 -3.60943,0.140674 -7.00787,0.960986 -10.19531,2.460938 -4.45317,2.015669 -9.21098,5.554728 -14.27344,10.617187 -0.37504,0.281286 -0.56254,0.632845 -0.5625,1.054685 -4e-5,0.65629 0.79684,2.2266 2.39063,4.71094 5.85933,8.90627 11.39057,15.63283 16.59375,20.17969 3.32806,2.85938 6.44525,4.28907 9.35156,4.28906 2.15618,1e-5 3.49212,0.15235 4.00781,0.45703 0.51556,0.30469 0.77337,1.11329 0.77344,2.42578 z""
         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
         id=""path2838"" />
    </g>
  </g>
</svg>
","@@ -0,0 +1,329 @@
+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc=""http://purl.org/dc/elements/1.1/""
+   xmlns:cc=""http://creativecommons.org/ns#""
+   xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#""
+   xmlns:svg=""http://www.w3.org/2000/svg""
+   xmlns=""http://www.w3.org/2000/svg""
+   xmlns:sodipodi=""http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd""
+   xmlns:inkscape=""http://www.inkscape.org/namespaces/inkscape""
+   width=""460""
+   height=""180""
+   id=""svg2""
+   version=""1.1""
+   inkscape:version=""0.47 r22583""
+   sodipodi:docname=""logo.svg"">
+  <defs
+     id=""defs4"">
+    <inkscape:perspective
+       sodipodi:type=""inkscape:persp3d""
+       inkscape:vp_x=""0 : 526.18109 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_z=""744.09448 : 526.18109 : 1""
+       inkscape:persp3d-origin=""372.04724 : 350.78739 : 1""
+       id=""perspective10"" />
+    <inkscape:perspective
+       id=""perspective2824""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2840""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2878""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2894""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2910""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2926""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective2976""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective3020""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective3036""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective3052""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+    <inkscape:perspective
+       id=""perspective3866""
+       inkscape:persp3d-origin=""0.5 : 0.33333333 : 1""
+       inkscape:vp_z=""1 : 0.5 : 1""
+       inkscape:vp_y=""0 : 1000 : 0""
+       inkscape:vp_x=""0 : 0.5 : 1""
+       sodipodi:type=""inkscape:persp3d"" />
+  </defs>
+  <sodipodi:namedview
+     id=""base""
+     pagecolor=""#ffffff""
+     bordercolor=""#666666""
+     borderopacity=""1.0""
+     inkscape:pageopacity=""0.0""
+     inkscape:pageshadow=""2""
+     inkscape:zoom=""0.98994949""
+     inkscape:cx=""240.32415""
+     inkscape:cy=""-37.836532""
+     inkscape:document-units=""px""
+     inkscape:current-layer=""layer1""
+     showgrid=""false""
+     inkscape:window-width=""1680""
+     inkscape:window-height=""998""
+     inkscape:window-x=""-8""
+     inkscape:window-y=""-8""
+     inkscape:window-maximized=""1"" />
+  <metadata
+     id=""metadata7"">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="""">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource=""http://purl.org/dc/dcmitype/StillImage"" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label=""Layer 1""
+     inkscape:groupmode=""layer""
+     id=""layer1""
+     transform=""translate(-27.820801,-24.714976)"">
+    <path
+       style=""fill:#000000""
+       d=""M 96.944917,182.03377 C 89.662681,176.30608 81.894549,170.81448 76.586317,163.08166 65.416842,149.44499 56.816875,133.6567 50.937585,117.06515 47.383955,106.27654 46.166898,94.709824 41.585799,84.338096 c -4.792287,-7.533044 0.821224,-15.767897 9.072722,-18.16242 3.673742,-0.705104 10.133327,-4.170258 2.335951,-1.693539 -6.990592,5.128871 -7.667129,-4.655603 -0.498823,-5.27517 4.892026,-0.650249 6.692895,-4.655044 5.019966,-8.260251 -5.251326,-3.424464 12.733737,-7.18801 3.684373,-12.297799 -9.426987,-10.170666 13.186339,-12.128546 7.607283,-0.577786 -1.335447,8.882061 15.801226,-1.627907 11.825117,8.628945 4.041283,4.925694 15.133562,1.1211 14.85838,8.031392 5.887092,0.404678 7.907562,5.358061 13.433992,5.738347 5.72759,2.586557 16.1108,4.624792 18.0598,11.079149 -5.68242,4.498756 -18.84089,-9.292674 -19.47305,3.160397 1.71659,18.396078 1.27926,37.346439 8.00986,54.864989 3.18353,10.60759 10.9012,18.95779 17.87109,27.21946 6.66875,8.09126 15.70186,13.78715 24.90885,18.58338 8.07647,3.80901 16.78383,6.33528 25.58583,7.92044 3.5701,-2.7307 9.87303,-12.8828 15.44238,-8.60188 0.26423,4.81007 -11.0541,10.05512 -0.53248,9.5235 6.17819,-1.86378 10.46336,4.77803 15.55099,-1.21289 4.68719,5.55206 19.48197,-3.54734 16.14693,7.80115 -4.50972,2.90955 -11.08689,1.15142 -15.60404,5.15397 -7.44757,-3.71979 -13.37691,3.32843 -21.6219,2.43707 -9.15641,1.64002 -18.4716,2.30204 -27.75473,2.31642 -15.22952,-1.20328 -30.78158,-1.71049 -45.26969,-7.01291 -8.16166,-2.37161 -16.12649,-7.01887 -23.299683,-11.66829 z m 12.862043,5.5729 c 7.9696,3.44651 15.76243,7.07889 24.49656,8.17457 13.85682,1.92727 28.16653,4.89163 42.07301,2.18757 -6.2939,-2.84199 -12.80077,1.10719 -19.07096,-2.0322 -7.52033,1.61821 -15.59049,-0.41223 -23.23574,-1.41189 -8.69395,-3.87259 -18.0762,-6.53549 -26.21772,-11.56219 -10.173155,-3.71578 5.26142,4.76524 8.00873,5.45214 6.35952,3.60969 -6.99343,-1.85044 -8.87589,-3.35101 -5.32648,-2.9879 -6.00529,-2.36357 -0.52745,0.67085 1.10332,0.64577 2.19359,1.32226 3.34946,1.87216 z M 94.642259,176.88976 c 7.722781,2.86052 -0.03406,-5.43082 -3.572941,-4.94904 -1.567906,-2.72015 -5.9903,-4.43854 -2.870721,-5.89973 -5.611524,1.9481 -5.878319,-7.40814 -8.516004,-6.07139 -5.936516,-1.87454 -2.310496,-8.51501 -9.381929,-12.59292 -0.645488,-4.29697 -7.02577,-8.02393 -9.060801,-14.50525 -0.898786,-3.31843 -7.208336,-12.84783 -3.332369,-3.97927 3.300194,8.53747 9.106618,15.84879 13.93868,23.15175 3.752083,6.95328 8.182497,14.22026 15.015767,18.55788 2.303436,2.20963 4.527452,5.59533 7.780318,6.28797 z M 72.39456,152.46355 c 0.26956,-1.16626 1.412424,2.52422 0,0 z m 31.49641,27.85526 c 1.71013,-0.76577 -2.45912,-0.96476 0,0 z m 4.19228,1.52924 c -0.43419,-2.1116 -1.91376,1.18074 0,0 z m 5.24749,2.18891 c 2.49828,-2.37871 -3.85009,-1.49983 0,0 z m 8.99389,5.01274 c 1.51811,-2.2439 -4.85872,-0.84682 0,0 z m -17.2707,-12.03933 c 3.88031,-2.51023 -5.01186,-0.0347 0,0 z m 3.9366,1.96293 c -0.11004,-1.32709 -1.40297,0.59432 0,0 z m 19.67473,12.28006 c 3.16281,1.99601 18.46961,4.3749 8.88477,0.81847 -1.60377,0.33811 -17.77263,-4.57336 -8.88477,-0.81847 z M 97.430958,166.92721 c -0.307503,-1.33094 -4.909341,-1.4694 0,0 z m 9.159302,5.33813 c 2.38371,-1.66255 -4.94757,-1.28235 0,0 z m 7.70426,4.72382 c 3.42065,-1.28963 -5.54907,-1.29571 0,0 z M 93.703927,162.86805 c 3.711374,2.84621 14.967683,0.36473 5.683776,-1.69906 -4.225516,-2.2524 -13.74889,-3.79415 -7.25757,1.35821 l 1.573785,0.34088 9e-6,-3e-5 z m 25.808723,15.75216 c 1.54595,-2.63388 -6.48298,-1.50411 0,0 z m -7.84249,-6.23284 c 9.0752,2.56719 -7.63142,-5.739 -2.23911,-0.94466 l 1.19513,0.54082 1.04399,0.4039 -1e-5,-6e-5 z m 15.72354,9.0878 c 8.59474,0.082 -7.76304,-1.18486 0,1e-5 l 0,-1e-5 z M 90.396984,157.89545 c -0.335695,-1.60094 -2.120962,0.13419 0,0 z m 51.535396,31.73502 c 0.2292,-2.89141 -2.80486,2.15157 0,0 z m -36.86817,-22.75299 c -0.51986,-1.52251 -2.68548,-0.0622 0,0 z m -13.852128,-9.98649 c 4.934237,-0.29629 -6.755322,-2.17418 0,0 z M 74.802387,146.28394 c -0.614146,-2.36536 -5.369213,-4.2519 0,0 z m 43.079323,27.33941 c -0.90373,-1.0307 -0.4251,0.22546 0,0 z m 26.81408,16.45475 c -0.086,-1.57503 -1.46039,0.59616 0,0 z m -29.18712,-18.90528 c 0.48266,-2.02932 -4.20741,-0.61442 0,0 z M 95.532612,158.51286 c 3.670785,-0.39305 -5.880434,-2.48161 0,0 z M 129.32396,179.51 c 5.72042,-2.26627 -5.57541,-1.10635 0,0 z m -17.57682,-11.93145 c 6.59278,0.85002 -7.84442,-4.48425 -1.44651,-0.4773 l 1.4465,0.47734 1e-5,-4e-5 z m 22.91296,14.0886 c 6.15514,-3.67975 4.12588,8.61677 10.44254,1.0388 6.23086,-4.54942 -5.38086,5.62451 2.29838,0.81116 5.55359,-3.71438 13.75643,1.76075 18.93848,3.5472 3.72659,-0.18307 7.34938,3.22236 11.16973,1.15059 7.3542,-1.98082 -14.38097,-2.93789 -8.68344,-6.4523 -6.72914,1.95848 -11.70093,-2.33483 -15.01213,-6.64508 -7.54812,-1.74298 -16.27548,-5.602 -20.04257,-12.28184 -1.5359,-2.50802 2.21884,0.35333 -1.32586,-3.74638 -4.54834,-4.04546 -6.81948,-8.63766 -9.87278,-13.5552 -3.64755,-1.94587 -4.07249,-7.67345 -4.44123,-0.19201 0.0289,-4.72164 -4.40393,-7.89964 -5.48589,-6.57859 -0.0194,-4.54721 4.74396,-2.26787 1.40945,-5.63228 -0.71771,-4.71302 -3.08085,-9.6241 -3.79115,-14.9453 -1.1036,-2.56502 -0.15541,-8.05863 -3.76662,-2.25204 -1.31566,6.13669 -0.43668,-7.54129 1.6093,-3.03083 2.68543,-4.60251 -0.9641,-4.0612 -1.11361,-3.42211 1.74931,-3.88333 1.10719,-9.39159 -0.45644,-7.29023 0.93213,-4.11586 1.47259,-15.147529 -1.3951,-13.192579 1.73833,-4.303958 3.29668,-19.694077 -4.24961,-13.826325 -3.058358,0.04294 -8.354541,1.110195 -10.858032,2.355243 7.849502,4.326857 -0.789543,1.562577 -3.984808,0.874879 -0.416343,4.003642 -3.58119,2.272086 -7.535123,2.311339 6.315273,0.781339 -3.075253,6.458962 -6.698132,4.253506 -4.705102,2.248756 4.060621,7.862038 0.0944,9.597586 0.487433,2.616581 -7.208227,-0.944906 -6.603832,5.097711 -4.56774,-1.92155 -0.628961,7.16796 1.656273,4.09382 7.768882,2.10261 5.469108,6.89631 5.666947,11.44992 -1.265833,2.6534 -6.249495,-6.23691 -1.109939,-5.82517 -4.054715,-6.58674 -4.485232,-2.38081 -7.854566,0.67911 -0.783857,0.22222 8.5944,4.35376 2.709059,6.3967 5.177884,0.79894 5.325199,5.33008 6.379284,8.19735 3.11219,3.24152 2.475226,-3.57931 6.199071,0.31623 -2.356488,-3.4705 -12.48183,-9.77839 -4.329567,-7.7553 -0.04358,-3.49291 -1.474412,-6.30951 1.02322,-6.24118 2.473367,-4.47926 -2.590385,11.044 2.984725,5.35124 1.543285,-0.67388 1.92554,-4.48494 4.699544,0.35989 4.029096,3.96363 1.45533,6.83577 -4.228162,3.20648 1.016828,3.44946 7.603062,4.68217 6.365348,10.07646 1.3121,4.7444 3.147844,2.99695 4.747999,2.72266 1.25523,4.60973 1.968016,1.2201 2.027559,-0.97355 5.747357,1.23033 4.401142,4.62773 6.199456,7.00134 3.960416,1.78761 -5.668696,-12.11713 1.130659,-4.18106 7.153577,6.4586 2.682797,9.15464 -3.736856,8.11995 4.063129,-0.32824 5.373423,5.49305 10.455693,5.28853 4.63456,2.20477 7.77237,10.67291 -0.21613,7.1478 -2.77074,-2.49821 -12.575734,-5.5801 -4.56731,-0.82823 7.39657,3.42523 13.27117,5.47432 20.40487,9.77384 5.10535,3.64464 7.31104,7.81908 9.24607,8.64541 -4.29084,2.04946 -12.93089,-1.63655 -6.51514,-2.76618 -4.00168,-0.72894 -8.50258,-2.75259 -4.66961,2.2333 3.25926,2.72127 11.54708,2.43298 13.0328,2.74132 -1.25934,2.77488 -3.4207,2.99556 0.0516,3.21078 -3.87375,2.06438 1.24216,2.38403 1.60114,3.56362 z m -7.9215,-22.36993 c -2.35682,-2.46475 -2.9662,-7.08134 -0.41852,-3.06426 1.30648,0.52466 4.18523,7.54428 0.41857,3.06426 l -5e-5,0 z m 25.79733,16.38693 c 1.47004,-0.0952 0.0427,1.11681 0,0 z m -29.51867,-22.43039 c -0.0904,-3.72637 0.8525,2.87419 0,0 z m -2.56392,-3.44965 c -2.96446,-5.72787 3.73721,1.62212 0,0 z M 89.382646,128.35916 c 1.7416,-0.46446 0.856841,2.97864 0,0 z m 24.728294,13.40357 c 1.06957,-4.01654 1.25692,3.37014 0,0 z M 96.64115,129.61525 c -1.231543,-2.21638 2.576009,2.07865 0,0 z m 14.99279,4.80618 c -2.80851,-6.29223 1.98836,-3.43699 0.62135,1.03124 l -0.62135,-1.03124 0,0 z M 85.778757,117.17864 c -1.255624,-2.06432 -3.332663,-8.12135 -2.663982,-9.97042 0.604935,3.0114 6.403914,12.95956 2.844571,4.12096 -3.933386,-7.40908 4.701805,2.40491 5.590052,4.2529 0.413624,1.83837 -2.426789,-0.50225 -0.502192,3.80828 -3.509809,-4.90766 -2.071967,2.71088 -5.268449,-2.21172 z m -7.990701,-5.50612 c 0.328938,-4.79981 1.829262,3.29132 0,0 z m 3.594293,1.23728 c 1.715175,-3.62282 2.908243,5.05052 0,0 z m -8.64616,-6.68847 c -2.974956,-2.95622 -5.127809,-5.68132 0.139193,-1.83474 2.029482,0.0792 -4.509002,-6.19705 0.488751,-1.99305 5.25531,0.95822 2.5951,8.61674 -0.627944,3.82779 z m 4.541717,-0.11873 c 1.727646,-1.71203 0.917172,1.6853 0,0 z m 2.794587,0.8959 c -2.619181,-4.9094 3.178801,2.05822 0,0 z m -5.55546,-5.30909 c -8.64844,-7.696511 10.867309,4.02451 1.4129,1.4269 l -1.412955,-1.42683 5.5e-5,-7e-5 z m 24.77908,14.39717 c -3.742506,-2.24398 -0.991777,-15.79747 0.284503,-6.52785 3.638294,-1.17695 -0.200879,4.78728 2.512784,4.73208 -0.42767,3.76305 -1.64169,5.11594 -2.797287,1.79577 z m 9.165207,5.41684 c 0.36705,-4.08462 0.77249,2.79262 0,0 z m -1.59198,-1.57295 c 0.41206,-1.74497 0.0426,2.05487 0,0 z M 76.213566,99.16032 c -5.556046,-7.665657 16.147323,7.75413 3.558556,1.9443 -1.315432,-0.34404 -2.898208,-0.46688 -3.558556,-1.9443 z m 17.649112,9.35749 c -0.525779,-6.45461 1.174169,1.06991 -1.92e-4,-2e-5 l 1.92e-4,2e-5 z m 13.399762,8.59585 c 1.03698,-3.67668 0.0773,2.43221 0,0 z M 77.064685,96.23472 c 3.302172,-0.706291 13.684695,5.79939 4.150224,1.85832 -1.059396,-1.17279 -3.317802,-0.63994 -4.150224,-1.85832 z m 28.356745,14.13312 c 0.35296,-6.60002 1.97138,-3.94233 0.0122,0.94474 l -0.0121,-0.94473 -5e-5,-1e-5 z M 79.52277,93.938099 c 1.345456,-1.97361 -3.571631,-8.923063 0.708795,-2.492797 1.849543,1.469605 5.355103,2.461959 2.260017,3.080216 4.867744,4.294162 -1.187244,1.163612 -2.968812,-0.587419 z m 24.49612,14.368161 c 0.92952,-7.51843 0.81971,4.40485 0,0 z M 76.712755,86.993902 c 1.027706,-0.439207 0.542746,1.369335 0,0 z m 6.389622,3.803092 c 1.644416,-3.450522 3.03351,3.848297 0,0 z m 18.023553,10.026276 c -0.0174,-1.3252 0.34003,1.92765 0,0 z m -1.04404,-2.31139 c -2.501612,-6.171646 2.32693,3.26759 0,0 z m -1.536003,-4.046372 c -0.419906,-2.550188 1.427129,3.203862 -7.3e-5,-9e-6 l 7.3e-5,9e-6 z m 2.499773,-4.063514 c -1.71663,-3.025123 2.16777,-13.331073 2.60122,-6.939418 -1.81185,4.980256 -0.52268,7.766309 0.74129,1.086388 2.33417,-5.257159 -0.50421,10.374054 -3.34255,5.853057 l 4e-5,-2.7e-5 z m 2.56889,-15.326649 c 0.74833,-0.918921 0.16609,1.107082 0,0 z m -4.290016,84.534235 c -1.017552,-0.88802 0.127775,0.56506 0,0 z m 8.837726,4.47065 c 4.91599,1.26135 4.89086,-0.76487 0.44782,-1.36683 -2.3898,-2.22316 -9.930475,-4.58124 -3.18119,-0.27586 0.44699,1.13227 1.85944,1.10589 2.73337,1.64269 z M 90.708067,152.48725 c 2.708244,2.01956 10.201213,5.72375 3.858186,0.76868 2.138588,-2.48467 -4.093336,-3.80722 -2.026067,-5.46927 -5.258175,-3.21755 -4.147962,-2.93133 -0.464111,-2.8301 -6.319385,-2.82462 0.912163,-2.61333 0.571661,-4.06067 -2.436706,-0.48126 -12.103074,-4.29664 -6.416395,0.31341 -5.780887,-2.94751 -1.377603,1.09799 -3.12488,0.67029 -5.911336,-1.61178 5.264392,4.50224 -0.938845,2.98448 3.391327,2.6875 9.128301,6.88393 1.433786,2.84407 -1.013816,1.45934 5.506273,3.67136 7.106665,4.77911 z m 9.243194,5.31013 c 11.238769,3.62163 -5.510018,-4.4246 0,0 z m 47.316399,28.66432 c 0.14496,-2.22965 -1.53604,1.90201 0,0 z m 4.86324,2.04679 c 2.59297,-2.51255 0.106,4.00222 4.29655,-0.61509 0.0453,-3.30544 -0.12904,-5.25783 -4.81563,-1.24252 -1.29194,0.71648 -1.86871,3.76288 0.51908,1.85761 z M 74.932378,140.02637 c -0.796355,-3.1304 -5.581949,-3.11418 0,0 z m 5.193029,3.40294 c -1.928397,-3.19739 -6.880525,-2.89469 0,0 z m 29.543373,17.81697 c 2.8844,2.56199 13.24761,1.87984 3.50331,0.31527 -1.44321,-2.13386 -9.16415,-1.6203 -3.50331,-0.31527 z m 40.61236,25.08153 c 4.43933,-3.72512 -4.30122,1.66183 0,0 z m 9.2328,6.34473 c 0.0277,-1.19543 -1.91352,0.52338 0,0 z m 0.0142,-1.6736 c 4.91602,-5.20866 -4.76346,0.30807 -4e-5,0 l 4e-5,0 z M 62.15981,129.33339 c -4.189944,-5.97826 -2.604586,-8.66544 -6.645136,-13.54677 -0.764913,-3.73279 -6.931672,-12.20326 -3.189579,-3.22947 3.42754,5.24836 4.446054,13.37434 9.834715,16.77624 z m 95.82635,60.00977 c 9.04429,-5.84575 -3.7125,-2.54641 0,0 z m 6.9041,2.70461 c 4.52911,-3.88867 -2.86491,-0.81334 0,0 z M 73.393094,133.41838 c 1.296204,-1.92838 -3.347642,-0.24666 0,0 z m 90.055596,56.78275 c 4.38526,-2.82746 -1.01036,-2.39335 -0.79483,0.26003 l 0.79484,-0.26003 -1e-5,0 z m -59.51386,-37.51178 c -0.15075,-1.90924 -2.31574,0.16206 0,0 z m 3.67794,2.11629 c -1.16888,-2.36318 -1.79716,0.37121 0,0 z m 62.8725,37.30625 c 5.61806,-4.05283 -3.4056,-0.77594 -1.17927,0.76785 l 1.17927,-0.76785 0,0 z m -2.15131,-1.03979 c 4.57663,-3.83506 -4.83183,1.69954 0,0 z m 10.99163,7.31983 c 3.0728,-2.05816 -3.73316,-0.66575 0,0 z M 76.211249,132.02781 c 4.118965,0.92286 16.460394,10.1439 9.179466,0.63772 -3.728991,-1.10384 -1.492605,-10.21906 -5.29621,-8.60579 2.552972,4.2649 2.100461,6.08018 -3.259642,3.3914 -6.736808,-3.28853 -3.785888,1.6297 -2.469293,2.98518 -1.794185,0.40772 2.373226,1.5572 1.845679,1.59149 z m -18.76588,-14.82026 c 0.737407,-3.04991 -6.789814,-16.77881 -3.554464,-6.87916 1.167861,2.07373 1.049123,6.00387 3.554464,6.87916 z m 34.443451,21.23513 c -2.120989,-1.77378 -0.100792,-0.25103 0,0 z m 5.222997,1.21548 c -0.0027,-3.23079 -5.77326,-1.31196 0,0 z m 45.261473,28.53321 c -0.86326,-2.20739 -3.41229,-0.0512 8e-5,4e-5 l -8e-5,-4e-5 z m 2.17351,1.58769 c -0.32087,-1.23546 -1.25399,0.23848 0,0 z m 17.94015,11.3001 c 1.72546,-1.27472 -2.15318,-0.1628 0,0 z M 66.819057,119.6006 c 4.935243,-1.91072 -5.28775,-1.36248 0,0 z m 71.569733,45.08937 c -0.0549,-3.19499 -3.14622,0.79264 0,0 z M 64.869152,115.05675 c 3.170167,-1.07084 -2.932663,-0.70531 0,0 z m 9.201532,4.45726 c -0.0575,-1.05014 -0.973336,0.39747 0,0 z m 112.231406,68.82181 c 4.0765,-0.8265 13.36606,2.07489 14.86752,-1.08086 -4.95044,-0.12019 -17.12734,-3.49263 -17.70346,0.80479 l 1.08368,0.17072 1.75226,0.10534 0,1e-5 z M 76.995161,120.25099 c 0.07087,-3.23755 -2.524669,-0.12092 0,0 z M 52.801998,103.4687 c -1.098703,-6.16843 -4.178791,-0.93357 0,0 z m 5.769195,1.45013 c 0.07087,-1.9807 -5.280562,-1.78224 0,0 z m 3.296917,1.61923 c -0.953019,-0.77196 -0.745959,0.97521 0,0 z m 20.744719,13.30775 c 0.976615,-0.89718 -2.312116,-0.66455 0,0 z M 59.672204,102.88617 c -0.557624,-4.65897 -6.681999,-0.69805 0,0 z M 47.844441,95.21166 c -0.168219,-2.150189 -1.152625,0.81111 0,0 z m 1.759336,-1.328672 c -0.28703,-2.549584 -1.510515,0.324387 0,0 z m 9.720792,5.802442 c 4.110486,-1.61465 -7.487254,-3.33984 -0.839893,-0.30506 l 0.839893,0.30506 z m 130.097601,80.35913 c 2.63092,-2.4121 -3.34373,-0.74577 0,0 z m 15.71669,8.14691 c 1.05433,-3.1186 -2.65452,0.41058 0,0 z M 60.318012,94.590436 c 0.433018,-3.016773 -3.258762,0.59902 0,0 z M 46.487687,85.324242 c -0.742965,-4.25911 -0.64134,-11.735065 6.465133,-9.208583 -9.485962,1.883339 6.56534,11.790095 4.538357,3.968363 3.988626,0.195294 7.802669,-2.357284 5.709487,1.516403 7.85876,-0.867958 13.307129,-7.682612 20.898169,-6.72768 5.913058,-0.782493 12.378182,-1.375955 18.750257,-3.756157 5.23905,-0.37743 10.28235,-6.018062 7.41068,-9.361383 -7.14456,-0.604513 -14.62339,0.289393 -22.520112,1.858993 -8.750559,1.819117 -16.699014,5.275307 -25.528125,6.758866 -8.605891,1.15604 1.730998,3.185165 -0.734074,3.637227 -4.490681,1.558136 5.355488,2.608852 -0.582182,4.251428 C 57.228283,77.56448 53.411411,76.304535 54.977788,72.440196 46.7341,73.50992 39.490264,76.931325 46.003276,85.320342 l 0.484402,0.0037 9e-6,-2.56e-4 z m 19.864291,-10.1168 c 1.932856,-7.120464 10.355229,5.859274 3.168052,0.945776 -0.858453,-0.642457 -2.2703,-1.166588 -3.168052,-0.945776 z m 0.376038,-3.452197 c 2.789661,-2.078257 1.482964,1.16516 0,0 z m 3.542213,0.05622 c 0.251833,-3.27648 8.108752,1.73455 1.295517,1.179499 l -1.295517,-1.179499 0,0 z m 4.84543,-1.948193 c 1.769481,-2.067535 0.50862,1.83906 0,0 z m 1.239563,-0.83005 c 2.946379,-3.540216 16.68561,-2.259413 6.628966,-0.34519 -2.695543,-2.029363 -4.761797,1.196575 -6.628966,0.34519 z m 17.930017,-2.763886 c -0.448199,-9.670222 8.907771,3.436477 0,0 z m 5.087539,-0.02784 c 1.860022,-4.873906 7.218072,-1.955774 0.860732,-0.979407 0.13805,0.518656 -0.18642,2.516173 -0.860732,0.979407 z M 58.311842,92.088739 c 5.55753,-3.403212 -5.899945,-2.952541 0,0 l 0,0 z m 4.109214,1.141866 c 1.948513,-2.071884 -4.233857,-0.840369 0,0 z M 50.313395,84.63767 c 3.175569,-2.439416 -3.757842,-0.927473 0,0 z M 214.41578,187.30012 c 0.0918,-2.83019 -2.42718,1.27537 0,0 z m -16.67487,-11.37935 c 0.47417,-3.25845 -2.14286,0.28408 0,0 z m 21.26022,12.47672 c 4.43994,0.015 13.45265,-1.37884 3.79217,-1.37442 -1.51594,0.23641 -8.83311,0.18571 -3.79216,1.37439 l -1e-5,3e-5 z M 66.035603,91.23339 c 3.593258,-0.246807 5.621861,-3.963629 -0.694932,-3.749977 -9.789949,-1.013541 8.637508,3.352129 -1.255898,2.10383 -1.329368,0.880346 1.873606,1.889721 1.95083,1.646147 z m 3.164618,1.601748 c -0.375177,-2.307063 -1.111156,1.225591 0,0 z m 3.753896,-10.009901 c 1.559281,-1.934055 -2.157697,-0.517053 0,0 z M 61.003998,62.84999 c 6.412879,-2.181631 15.182392,-4.633087 18.210335,1.074184 -3.081589,-3.70893 -1.24361,-7.360157 1.666959,-1.937407 4.115576,5.486669 6.175915,-2.495489 3.499086,-4.335821 3.050468,3.790246 6.520044,5.581281 2.042429,0.239564 4.865693,-5.852929 -9.742712,0.766433 -13.063105,0.699775 -1.597564,0.717062 -16.493576,3.79889 -12.355704,4.259705 z m 3.75831,-7.197834 c 3.657324,-2.760416 12.648968,1.641989 6.879078,-2.743367 -0.564117,-0.498292 -12.636077,3.325475 -6.879078,2.743367 z m 13.333489,0.550473 c 4.280389,0.109225 -1.84632,-5.750287 3.254304,-3.095159 -0.837696,-2.736627 -5.938558,-3.248956 -8.432316,-4.342312 -1.410474,2.502054 2.870977,7.471102 5.178012,7.437471 z M 67.100291,44.099162 c 1.480803,-2.007406 -2.59521,1.017699 0,0 z m 5.449586,1.304353 c 6.897867,-0.914901 -1.758292,-2.970542 -1.389954,-0.07352 l 1.389954,0.07352 0,-9e-6 z M 62.374386,37.441437 c -4.856866,-6.340205 9.133987,1.065769 4.199411,-5.572646 -4.153254,-3.307245 -8.144297,3.721775 -4.199411,5.572646 z m 62.330124,33.572802 c 2.22762,-3.948988 -9.19697,-5.323011 -1.5009,-1.399578 0.70858,0.236781 0.54821,1.6727 1.5009,1.399578 z""
+       id=""path2900"" />
+    <g
+       style=""font-size:28px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:end;line-height:89.99999762%;writing-mode:lr-tb;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+       id=""text3844"">
+      <path
+         d=""m 166.92789,156.32883 c -2e-5,1.80469 -0.62892,3.31771 -1.88672,4.53906 -1.20314,1.17578 -2.63412,1.76367 -4.29297,1.76367 -0.93881,0 -1.91863,-0.15495 -2.93945,-0.46484 -0.98438,-0.30078 -1.48113,-0.57422 -1.49024,-0.82031 -0.009,-0.20964 -0.005,-0.94336 0.0137,-2.20118 0.0274,-1.54036 0.041,-2.66145 0.041,-3.36328 0,-1.05728 -0.009,-2.59081 -0.0273,-4.60058 -0.0182,-2.00976 -0.0273,-3.34276 -0.0273,-3.99903 0,-0.65623 -0.10026,-1.1074 -0.30078,-1.35351 -0.18229,-0.21874 -0.57878,-0.39191 -1.18945,-0.51953 -0.23698,-0.082 -0.35547,-0.23241 -0.35547,-0.45118 0,-0.19138 0.17773,-0.35089 0.5332,-0.47851 0.51042,-0.18228 1.14388,-0.48761 1.90039,-0.91602 0.60156,-0.33722 0.97526,-0.50584 1.1211,-0.50586 0.28254,2e-5 0.42382,0.23244 0.42382,0.69727 0,0.0365 -0.0137,0.51043 -0.041,1.42187 -0.0182,0.85679 -0.0228,1.72723 -0.0137,2.61133 l 0.0273,4.73047 c 0,0.44662 0.15494,0.57423 0.46484,0.38281 1.09375,-0.62889 2.23307,-0.94335 3.41797,-0.94336 1.36718,10e-6 2.47916,0.41245 3.33594,1.23731 0.85676,0.82488 1.28514,1.90268 1.28516,3.2334 z m -2.1875,1.21679 c -1e-5,-1.24869 -0.34637,-2.27408 -1.03907,-3.07617 -0.65625,-0.7565 -1.45378,-1.13475 -2.39257,-1.13476 -0.64715,1e-5 -1.28517,0.16863 -1.91407,0.50586 -0.62891,0.33724 -0.94336,0.69271 -0.94336,1.0664 l 0,3.66406 c 0,1.75912 0.9707,2.63868 2.91211,2.63868 1.01171,0 1.82747,-0.32585 2.44727,-0.97754 0.61978,-0.65169 0.92968,-1.5472 0.92969,-2.68653 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2841"" />
+      <path
+         d=""m 179.35562,160.17062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41015,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -1e-5,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2843"" />
+      <path
+         d=""m 191.11343,160.70383 c -1e-5,0.33724 -0.46941,0.74739 -1.4082,1.23047 -1.02084,0.51953 -2.028,0.77929 -3.02148,0.77929 -1.54949,0 -2.81641,-0.4375 -3.80078,-1.3125 -1.02995,-0.92968 -1.54493,-2.18749 -1.54493,-3.77343 0,-1.70443 0.59245,-3.12174 1.77735,-4.25196 1.15755,-1.10285 2.57942,-1.65428 4.26562,-1.65429 1.02083,1e-5 1.9095,0.14584 2.66602,0.4375 0.6927,0.27344 1.03905,0.56511 1.03906,0.875 -1e-5,0.20964 -0.17091,0.52865 -0.5127,0.95703 -0.3418,0.42839 -0.62208,0.64258 -0.84082,0.64257 -0.13672,1e-5 -0.45118,-0.19595 -0.94335,-0.58789 -0.92059,-0.72915 -1.64064,-1.09374 -2.16016,-1.09375 -0.82032,10e-6 -1.4948,0.30991 -2.02344,0.92969 -0.55599,0.67449 -0.83399,1.60417 -0.83398,2.78906 -1e-5,1.431 0.40103,2.57488 1.20312,3.43164 0.72916,0.77475 1.60872,1.16211 2.63867,1.16211 1.02083,0 1.98242,-0.28255 2.88477,-0.84765 0.082,-0.0547 0.1914,-0.082 0.32812,-0.082 0.1914,0 0.2871,0.12305 0.28711,0.36914 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2845"" />
+      <path
+         d=""m 204.26578,161.155 c -1e-5,0.19141 -0.34865,0.48079 -1.0459,0.86816 -0.69728,0.38737 -1.25554,0.58106 -1.67481,0.58106 -0.35547,0 -0.66993,-0.17318 -0.94335,-0.51953 -0.27345,-0.34636 -0.46486,-0.51953 -0.57422,-0.51953 -0.082,0 -0.51498,0.18684 -1.29883,0.56054 -0.78386,0.3737 -1.57227,0.56055 -2.36524,0.56055 -0.7474,0 -1.37174,-0.21875 -1.87304,-0.65625 -0.54688,-0.48307 -0.82032,-1.13932 -0.82032,-1.96875 0,-1.57682 1.80469,-2.70703 5.41407,-3.39063 0.61978,-0.11848 0.93423,-0.36913 0.94336,-0.75195 l 0.0273,-0.875 c 0.0547,-1.49478 -0.60613,-2.24218 -1.98242,-2.24219 -0.39193,1e-5 -0.76335,0.35092 -1.11426,1.05274 -0.35092,0.70183 -0.8545,1.08008 -1.51074,1.13476 -0.7474,0.0729 -1.1211,-0.24153 -1.1211,-0.94336 0,-0.43749 0.55599,-0.9479 1.66797,-1.53125 1.16666,-0.61066 2.28776,-0.916 3.36328,-0.91601 1.85026,10e-6 2.76627,0.87957 2.74805,2.63867 l -0.0547,5.63281 c -0.009,0.59245 0.24153,0.88868 0.75196,0.88867 0.10025,1e-5 0.29165,-0.0228 0.57422,-0.0684 0.28254,-0.0456 0.4466,-0.0684 0.49218,-0.0684 0.26431,0 0.39648,0.17773 0.39649,0.5332 z m -4.21094,-3.11719 c 0.009,-0.22786 -0.0433,-0.37825 -0.15723,-0.45117 -0.11394,-0.0729 -0.29395,-0.0866 -0.54004,-0.041 -2.19662,0.39194 -3.29492,1.10743 -3.29492,2.14649 0,1.04818 0.56966,1.57226 1.70899,1.57226 0.45572,0 0.92512,-0.0866 1.4082,-0.25976 0.5651,-0.20052 0.84765,-0.44206 0.84766,-0.72461 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2847"" />
+      <path
+         d=""m 218.74429,161.31906 c -1e-5,0.18229 -0.4284,0.46029 -1.28515,0.83399 -0.72918,0.31901 -1.09376,0.47851 -1.09375,0.47851 -0.1185,0 -0.37143,-0.20508 -0.75879,-0.61523 -0.38738,-0.41016 -0.65854,-0.61524 -0.81348,-0.61524 -0.082,0 -0.55144,0.19141 -1.4082,0.57422 -0.85678,0.38281 -1.60873,0.57422 -2.25586,0.57422 -1.36719,0 -2.31967,-0.25977 -2.85742,-0.7793 -0.58334,-0.55599 -0.87501,-1.56315 -0.875,-3.02148 l 0,-2.74805 c -1e-5,-0.76562 -0.0775,-1.30338 -0.23242,-1.61328 -0.20964,-0.3828 -0.63347,-0.67447 -1.27149,-0.875 -0.20964,-0.0638 -0.31445,-0.17772 -0.31445,-0.3418 0,-0.18228 0.17773,-0.34178 0.5332,-0.47851 0.67448,-0.26431 1.3444,-0.53319 2.00977,-0.80664 0.46484,-0.1914 0.80208,-0.2871 1.01172,-0.28711 0.319,10e-6 0.47851,0.2142 0.47851,0.64258 0,1e-5 -0.0137,0.4808 -0.041,1.44238 -0.0274,0.9616 -0.041,1.87533 -0.041,2.74121 l 0,1.64063 c -1e-5,1.11198 0.21874,1.87304 0.65625,2.2832 0.39192,0.36458 1.10741,0.54687 2.14648,0.54687 1.60416,0 2.40624,-0.82031 2.40625,-2.46093 l 0,-2.4336 c -1e-5,-0.88411 -0.0798,-1.45149 -0.23925,-1.70215 -0.15952,-0.25064 -0.58563,-0.46711 -1.27832,-0.64941 -0.20053,-0.082 -0.30079,-0.2233 -0.30079,-0.42383 0,-0.20962 0.12304,-0.36002 0.36915,-0.45117 1.8867,-0.68358 2.92121,-1.02538 3.10351,-1.02539 0.35546,1e-5 0.53319,0.20509 0.5332,0.61523 -1e-5,-0.009 -0.0137,0.44891 -0.041,1.37403 -0.0274,0.92513 -0.041,1.82064 -0.041,2.68652 l 0,3.44531 c -1e-5,0.64714 0.47395,1.00717 1.42188,1.08008 0.31899,0.0274 0.4785,0.15039 0.47851,0.36914 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2849"" />
+      <path
+         d=""m 229.34,159.52805 c -1e-5,0.96614 -0.37143,1.73405 -1.11426,2.30371 -0.74285,0.56966 -1.75684,0.85449 -3.04199,0.85449 -0.85678,0 -1.71355,-0.0911 -2.57032,-0.27344 -0.73828,-0.16406 -1.16666,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10938,-0.73372 0.32813,-0.75195 0.21875,-0.0273 0.40559,0.0911 0.56054,0.35547 0.6836,1.19401 1.78646,1.79101 3.3086,1.79101 1.28515,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31901,-0.30078 -0.93881,-0.65169 -1.85937,-1.05274 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48307,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37826,-1.74999 1.13477,-2.29687 0.70182,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17774 0.65624,0.1185 0.99804,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17577 -1.63152,-1.76366 -2.73438,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87304,1.20312 -1e-5,0.44662 0.16861,0.80209 0.50586,1.06641 0.30077,0.22787 1.00715,0.58334 2.11914,1.0664 1.16666,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.82031,1.2168 0.82032,2.0918 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2851"" />
+      <path
+         d=""m 242.08218,160.17062 c -1e-5,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -10e-6,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -1e-5,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2853"" />
+      <path
+         d=""m 259.58218,159.52805 c -10e-6,0.96614 -0.37142,1.73405 -1.11425,2.30371 -0.74285,0.56966 -1.75685,0.85449 -3.042,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10937,-0.73372 0.32813,-0.75195 0.21874,-0.0273 0.40559,0.0911 0.56054,0.35547 0.68359,1.19401 1.78646,1.79101 3.3086,1.79101 1.28514,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31902,-0.30078 -0.93881,-0.65169 -1.85937,-1.05274 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13477,-2.29687 0.70181,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17774 0.65624,0.1185 0.99804,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17577 -1.63152,-1.76366 -2.73438,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87304,1.20312 -1e-5,0.44662 0.16861,0.80209 0.50585,1.06641 0.30078,0.22787 1.00716,0.58334 2.11915,1.0664 1.16665,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.8203,1.2168 0.82031,2.0918 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2855"" />
+      <path
+         d=""m 273.84195,156.95773 c -10e-6,1.58594 -0.5879,2.92807 -1.76367,4.02637 -1.17579,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.74089,0 -3.11719,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77734,1e-5 3.16275,0.47852 4.15625,1.43555 0.96613,0.92969 1.44921,2.1875 1.44922,3.77343 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34636,-2.59309 -1.03906,-3.48633 -0.67449,-0.86588 -1.53126,-1.29882 -2.57032,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65625,0.80209 1.51302,1.20313 2.57031,1.20313 1.0026,0 1.79557,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2857"" />
+      <path
+         d=""m 298.39664,162.09836 c -3e-5,0.30078 -0.1413,0.44206 -0.42383,0.42383 -1.8594,-0.13672 -3.59117,-0.13672 -5.19531,0 -0.35549,0.0273 -0.53322,-0.13217 -0.53321,-0.47852 -10e-6,-0.27344 0.24152,-0.41927 0.72461,-0.4375 0.61066,-0.0365 0.916,-0.5332 0.91602,-1.49023 l 0,-3.63672 c -2e-5,-2.04166 -0.82945,-3.06249 -2.48828,-3.0625 -0.87502,1e-5 -1.6771,0.15951 -2.40625,0.47851 -0.66538,0.28256 -1.00262,0.56512 -1.01172,0.84766 l -0.0547,5.42773 c -10e-6,0.56511 0.0684,0.93881 0.20508,1.1211 0.10025,0.1276 0.32355,0.21875 0.66992,0.27344 0.80207,0.13671 1.20311,0.30533 1.20313,0.50585 -2e-5,0.17318 -0.0228,0.29167 -0.0684,0.35547 -0.0547,0.0911 -0.21877,0.13216 -0.49219,0.12305 -1.03908,-0.0365 -2.5521,-0.0182 -4.53906,0.0547 -0.28257,0.009 -0.46486,-0.0137 -0.54688,-0.0684 -0.082,-0.0547 -0.12305,-0.18229 -0.12305,-0.38281 0,-0.23698 0.25976,-0.38282 0.7793,-0.4375 0.56509,-0.0638 0.84765,-0.57878 0.84766,-1.54493 l 0,-3.71875 c -1e-5,-1.00259 -0.22788,-1.77733 -0.6836,-2.32421 -0.40105,-0.49218 -0.91146,-0.73828 -1.53125,-0.73829 -0.91146,10e-6 -1.73177,0.18458 -2.46093,0.55371 -0.72918,0.36915 -1.09376,0.76336 -1.09375,1.18262 l 0,4.99024 c -10e-6,0.5651 0.14582,0.95703 0.4375,1.17578 0.26431,0.20052 0.74283,0.32357 1.43554,0.36914 0.37369,0.0182 0.56054,0.14583 0.56055,0.38281 -1e-5,0.26432 -0.1504,0.39649 -0.45117,0.39649 -2.27865,0 -3.92839,0.0638 -4.94922,0.1914 -0.34636,0.0456 -0.56966,0.0456 -0.66992,0 -0.082,-0.0456 -0.12305,-0.15495 -0.12305,-0.32812 0,-0.22787 0.33724,-0.42383 1.01172,-0.58789 0.41015,-0.10938 0.61523,-0.64258 0.61523,-1.59961 l 0,-4.19727 c 0,-1.0664 -0.28711,-1.68163 -0.86132,-1.8457 -0.48308,-0.13671 -0.77702,-0.23697 -0.88184,-0.30078 -0.10482,-0.0638 -0.15723,-0.16861 -0.15723,-0.31446 0,-0.16405 0.47396,-0.5104 1.42188,-1.03906 1.0026,-0.56509 1.61783,-0.84764 1.8457,-0.84766 0.1914,2e-5 0.35319,0.27573 0.48535,0.82715 0.13216,0.55144 0.2347,0.82716 0.30762,0.82715 0.10026,1e-5 0.37825,-0.14127 0.83398,-0.42383 0.5651,-0.35546 1.07552,-0.61978 1.53125,-0.79297 0.74739,-0.29165 1.51757,-0.43748 2.31055,-0.4375 0.63801,2e-5 1.194,0.13673 1.66797,0.41016 0.32811,0.1823 0.62434,0.43295 0.88867,0.75195 0.21874,0.27345 0.32811,0.41017 0.32813,0.41016 -2e-5,1e-5 0.23696,-0.13671 0.71093,-0.41016 0.55598,-0.319 1.0983,-0.56965 1.62696,-0.75195 0.77472,-0.27343 1.52667,-0.41014 2.25586,-0.41016 2.49737,2e-5 3.74607,1.37176 3.74609,4.11524 l 0,4.42969 c -2e-5,0.51953 0.12303,0.88867 0.36914,1.10742 0.21873,0.18229 0.64711,0.33724 1.28516,0.46484 0.48305,0.0911 0.72458,0.22787 0.72461,0.41016 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2859"" />
+      <path
+         d=""m 309.94937,160.17062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41015,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2861"" />
+      <path
+         d=""m 319.49234,161.18234 c -1e-5,0.4375 -0.40105,0.8112 -1.20312,1.1211 -0.71095,0.27343 -1.431,0.41015 -2.16016,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43294,-0.28027 -0.99805,-0.41699 -0.14583,-0.0365 -0.21875,-0.17773 -0.21875,-0.42383 0,-0.26432 0.0547,-0.42382 0.16407,-0.47852 0.98437,-0.48306 1.84114,-1.34895 2.57031,-2.59765 0.10026,-0.17317 0.29622,-0.22786 0.58789,-0.16407 0.20052,0.0638 0.30533,0.18231 0.31445,0.35547 l 0.0547,1.70899 c 0,0.12761 0.0228,0.21876 0.0684,0.27343 0.0638,0.0821 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17317,1e-5 0.17317,0.2142 0,0.64258 -0.20965,0.51954 -0.51954,0.7793 -0.92969,0.7793 l -2.06445,0 c -0.35548,0 -0.57423,0.0593 -0.65625,0.17773 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c 0,1.13022 0.10026,1.84571 0.30079,2.14649 0.26431,0.38281 0.87955,0.57422 1.8457,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69726,-0.15722 0.72461,-0.15723 0.10936,1e-5 0.16405,0.0684 0.16406,0.20508 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2863"" />
+      <path
+         d=""m 326.34195,146.64914 c -10e-6,0.41929 -0.15723,0.80893 -0.47168,1.16894 -0.31446,0.36005 -0.65853,0.54006 -1.03223,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05273,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41016,-0.99805 0,-0.40102 0.16634,-0.77472 0.49903,-1.12109 0.33267,-0.34634 0.69042,-0.51951 1.07324,-0.51953 0.92968,2e-5 1.39452,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15496,0.41472 -0.32813,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69336,-0.0729 -4.00586,0.0547 -0.35547,0.0365 -0.57877,0.0228 -0.66992,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13672,-0.4375 0,-0.20963 0.24154,-0.38281 0.72461,-0.51953 0.52864,-0.15495 0.79297,-0.66081 0.79297,-1.51758 l 0,-3.58203 c 0,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20052,-0.40103 -0.61524,-0.70637 -1.24414,-0.91601 -0.28255,-0.10025 -0.42383,-0.25064 -0.42383,-0.45117 0,-0.26432 0.20508,-0.46028 0.61524,-0.58789 0.76562,-0.23697 1.44465,-0.55143 2.03711,-0.94336 0.47395,-0.32812 0.76562,-0.49218 0.875,-0.49219 0.36457,10e-6 0.54231,0.23699 0.5332,0.71094 -0.0365,2.38802 -0.0547,4.82162 -0.0547,7.30078 0,0.59245 0.0866,1.01627 0.25977,1.27148 0.1914,0.28255 0.55598,0.48308 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2865"" />
+      <path
+         d=""m 351.9357,162.09836 c -2e-5,0.30078 -0.1413,0.44206 -0.42383,0.42383 -1.85939,-0.13672 -3.59116,-0.13672 -5.19531,0 -0.35549,0.0273 -0.53322,-0.13217 -0.5332,-0.47852 -2e-5,-0.27344 0.24151,-0.41927 0.72461,-0.4375 0.61065,-0.0365 0.91599,-0.5332 0.91601,-1.49023 l 0,-3.63672 c -2e-5,-2.04166 -0.82944,-3.06249 -2.48828,-3.0625 -0.87502,1e-5 -1.6771,0.15951 -2.40625,0.47851 -0.66538,0.28256 -1.00262,0.56512 -1.01172,0.84766 l -0.0547,5.42773 c -10e-6,0.56511 0.0684,0.93881 0.20508,1.1211 0.10025,0.1276 0.32356,0.21875 0.66992,0.27344 0.80207,0.13671 1.20311,0.30533 1.20313,0.50585 -2e-5,0.17318 -0.0228,0.29167 -0.0684,0.35547 -0.0547,0.0911 -0.21877,0.13216 -0.49219,0.12305 -1.03907,-0.0365 -2.55209,-0.0182 -4.53906,0.0547 -0.28256,0.009 -0.46485,-0.0137 -0.54688,-0.0684 -0.082,-0.0547 -0.12305,-0.18229 -0.12304,-0.38281 -10e-6,-0.23698 0.25975,-0.38282 0.77929,-0.4375 0.5651,-0.0638 0.84765,-0.57878 0.84766,-1.54493 l 0,-3.71875 c -1e-5,-1.00259 -0.22788,-1.77733 -0.68359,-2.32421 -0.40106,-0.49218 -0.91147,-0.73828 -1.53125,-0.73829 -0.91147,10e-6 -1.73178,0.18458 -2.46094,0.55371 -0.72917,0.36915 -1.09376,0.76336 -1.09375,1.18262 l 0,4.99024 c -10e-6,0.5651 0.14583,0.95703 0.4375,1.17578 0.26432,0.20052 0.74283,0.32357 1.43555,0.36914 0.37369,0.0182 0.56054,0.14583 0.56054,0.38281 0,0.26432 -0.1504,0.39649 -0.45117,0.39649 -2.27865,0 -3.92839,0.0638 -4.94922,0.1914 -0.34635,0.0456 -0.56966,0.0456 -0.66992,0 -0.082,-0.0456 -0.12305,-0.15495 -0.12305,-0.32812 0,-0.22787 0.33724,-0.42383 1.01172,-0.58789 0.41016,-0.10938 0.61523,-0.64258 0.61524,-1.59961 l 0,-4.19727 c -10e-6,-1.0664 -0.28712,-1.68163 -0.86133,-1.8457 -0.48308,-0.13671 -0.77702,-0.23697 -0.88184,-0.30078 -0.10482,-0.0638 -0.15723,-0.16861 -0.15722,-0.31446 -1e-5,-0.16405 0.47395,-0.5104 1.42187,-1.03906 1.0026,-0.56509 1.61784,-0.84764 1.8457,-0.84766 0.19141,2e-5 0.35319,0.27573 0.48536,0.82715 0.13215,0.55144 0.23469,0.82716 0.30761,0.82715 0.10026,1e-5 0.37825,-0.14127 0.83399,-0.42383 0.56509,-0.35546 1.07551,-0.61978 1.53125,-0.79297 0.74738,-0.29165 1.51757,-0.43748 2.31054,-0.4375 0.63801,2e-5 1.194,0.13673 1.66797,0.41016 0.32812,0.1823 0.62434,0.43295 0.88867,0.75195 0.21874,0.27345 0.32812,0.41017 0.32813,0.41016 -10e-6,1e-5 0.23697,-0.13671 0.71094,-0.41016 0.55597,-0.319 1.09829,-0.56965 1.62695,-0.75195 0.77472,-0.27343 1.52668,-0.41014 2.25586,-0.41016 2.49738,2e-5 3.74607,1.37176 3.74609,4.11524 l 0,4.42969 c -2e-5,0.51953 0.12303,0.88867 0.36914,1.10742 0.21873,0.18229 0.64712,0.33724 1.28516,0.46484 0.48305,0.0911 0.72459,0.22787 0.72461,0.41016 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2867"" />
+      <path
+         d=""m 363.48843,160.17062 c -10e-6,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -1e-5,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2869"" />
+      <path
+         d=""m 374.04312,159.52805 c -10e-6,0.96614 -0.37143,1.73405 -1.11426,2.30371 -0.74284,0.56966 -1.75684,0.85449 -3.04199,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28516,-0.45117 -0.0729,-0.1276 -0.10937,-0.75195 -0.10937,-1.87305 0,-0.48307 0.10937,-0.73372 0.32812,-0.75195 0.21875,-0.0273 0.4056,0.0911 0.56055,0.35547 0.68359,1.19401 1.78645,1.79101 3.30859,1.79101 1.28515,0 1.92773,-0.44661 1.92774,-1.33984 -1e-5,-0.39192 -0.14584,-0.72005 -0.4375,-0.98437 -0.31902,-0.30078 -0.93881,-0.65169 -1.85938,-1.05274 -1.33073,-0.59244 -2.2194,-1.11197 -2.66601,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13476,-2.29687 0.70182,-0.52864 1.64062,-0.79296 2.81641,-0.79297 0.73827,1e-5 1.41275,0.0593 2.02344,0.17774 0.65624,0.1185 0.99803,0.26433 1.02539,0.4375 0.0729,0.51042 0.2233,1.2487 0.45117,2.21484 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60157,-0.15039 -0.72006,-1.17577 -1.63151,-1.76366 -2.73437,-1.76367 -1.2487,1e-5 -1.87305,0.40105 -1.87305,1.20312 0,0.44662 0.16862,0.80209 0.50586,1.06641 0.30078,0.22787 1.00716,0.58334 2.11914,1.0664 1.16666,0.50131 1.95963,0.95248 2.37891,1.35352 0.54686,0.51953 0.8203,1.2168 0.82031,2.0918 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2871"" />
+      <path
+         d=""m 394.4689,161.155 c -1e-5,0.19141 -0.34864,0.48079 -1.0459,0.86816 -0.69727,0.38737 -1.25554,0.58106 -1.6748,0.58106 -0.35548,0 -0.66993,-0.17318 -0.94336,-0.51953 -0.27345,-0.34636 -0.46485,-0.51953 -0.57422,-0.51953 -0.082,0 -0.51498,0.18684 -1.29883,0.56054 -0.78386,0.3737 -1.57227,0.56055 -2.36523,0.56055 -0.7474,0 -1.37175,-0.21875 -1.87305,-0.65625 -0.54687,-0.48307 -0.82031,-1.13932 -0.82031,-1.96875 0,-1.57682 1.80468,-2.70703 5.41406,-3.39063 0.61979,-0.11848 0.93424,-0.36913 0.94336,-0.75195 l 0.0274,-0.875 c 0.0547,-1.49478 -0.60613,-2.24218 -1.98243,-2.24219 -0.39193,1e-5 -0.76335,0.35092 -1.11425,1.05274 -0.35092,0.70183 -0.8545,1.08008 -1.51075,1.13476 -0.7474,0.0729 -1.12109,-0.24153 -1.12109,-0.94336 0,-0.43749 0.55599,-0.9479 1.66797,-1.53125 1.16666,-0.61066 2.28775,-0.916 3.36328,-0.91601 1.85025,10e-6 2.76627,0.87957 2.74805,2.63867 l -0.0547,5.63281 c -0.009,0.59245 0.24153,0.88868 0.75195,0.88867 0.10025,1e-5 0.29166,-0.0228 0.57422,-0.0684 0.28254,-0.0456 0.4466,-0.0684 0.49219,-0.0684 0.26431,0 0.39647,0.17773 0.39648,0.5332 z m -4.21093,-3.11719 c 0.009,-0.22786 -0.0433,-0.37825 -0.15723,-0.45117 -0.11394,-0.0729 -0.29395,-0.0866 -0.54004,-0.041 -2.19662,0.39194 -3.29493,1.10743 -3.29492,2.14649 -1e-5,1.04818 0.56965,1.57226 1.70898,1.57226 0.45573,0 0.92513,-0.0866 1.40821,-0.25976 0.56509,-0.20052 0.84764,-0.44206 0.84765,-0.72461 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2873"" />
+      <path
+         d=""m 415.11343,156.58859 c -10e-6,1.70443 -0.57195,3.15137 -1.71582,4.34082 -1.14389,1.18946 -2.47689,1.78418 -3.99902,1.78418 -0.92058,0 -1.80925,-0.16406 -2.66602,-0.49218 -0.0912,-0.0365 -0.13672,0.18684 -0.13671,0.66992 l 0,4.11523 c -1e-5,0.66536 0.54231,1.09375 1.62695,1.28516 0.50129,0.0911 0.81803,0.17545 0.95019,0.25293 0.13216,0.0775 0.19824,0.20735 0.19825,0.38965 -10e-6,0.30988 -0.20509,0.45116 -0.61524,0.42382 -1.91407,-0.12761 -3.5957,-0.082 -5.04492,0.13672 -0.30078,0.0456 -0.48763,0.0456 -0.56055,0 -0.0729,-0.0456 -0.10937,-0.16862 -0.10937,-0.36914 0,-0.15495 0.25976,-0.3418 0.7793,-0.56054 0.44661,-0.1823 0.66991,-0.6198 0.66992,-1.3125 l 0,-12.0586 c -10e-6,-0.97525 -0.26889,-1.58593 -0.80664,-1.83203 -0.63803,-0.28254 -0.95704,-0.51496 -0.95703,-0.69727 -10e-6,-0.20051 0.18684,-0.3509 0.56054,-0.45117 0.48307,-0.11848 0.97982,-0.32811 1.49024,-0.6289 0.42838,-0.24609 0.68814,-0.36913 0.77929,-0.36914 0.27344,1e-5 0.49674,0.25066 0.66993,0.75195 0.2552,0.72918 0.42382,1.09376 0.50585,1.09375 0.0182,1e-5 0.41016,-0.21418 1.17579,-0.64258 0.83853,-0.46483 1.65884,-0.69725 2.46093,-0.69726 1.30338,1e-5 2.3789,0.36915 3.22657,1.10742 1.0117,0.86589 1.51756,2.11915 1.51757,3.75976 z m -2.32421,1.09375 c -2e-5,-1.48567 -0.36916,-2.64322 -1.10743,-3.47265 -0.60157,-0.6927 -1.30795,-1.03906 -2.11914,-1.03907 -0.62891,10e-6 -1.23047,0.21876 -1.80468,0.65625 -0.75652,0.56512 -1.13478,1.35353 -1.13477,2.36524 l 0,3.86914 c -10e-6,0.24609 0.34635,0.50586 1.03906,0.7793 0.74739,0.30078 1.55859,0.45117 2.4336,0.45117 1.79556,0 2.69334,-1.20313 2.69336,-3.60938 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2875"" />
+      <path
+         d=""m 429.20914,156.95773 c -2e-5,1.58594 -0.58791,2.92807 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43555 0.96613,0.92969 1.4492,2.1875 1.44922,3.77343 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2877"" />
+      <path
+         d=""m 441.19937,160.70383 c -10e-6,0.33724 -0.46941,0.74739 -1.4082,1.23047 -1.02084,0.51953 -2.028,0.77929 -3.02149,0.77929 -1.54948,0 -2.81641,-0.4375 -3.80078,-1.3125 -1.02995,-0.92968 -1.54492,-2.18749 -1.54492,-3.77343 0,-1.70443 0.59245,-3.12174 1.77734,-4.25196 1.15755,-1.10285 2.57943,-1.65428 4.26563,-1.65429 1.02082,1e-5 1.9095,0.14584 2.66602,0.4375 0.69269,0.27344 1.03905,0.56511 1.03906,0.875 -1e-5,0.20964 -0.17091,0.52865 -0.5127,0.95703 -0.3418,0.42839 -0.62208,0.64258 -0.84082,0.64257 -0.13673,1e-5 -0.45118,-0.19595 -0.94336,-0.58789 -0.92058,-0.72915 -1.64063,-1.09374 -2.16015,-1.09375 -0.82032,10e-6 -1.4948,0.30991 -2.02344,0.92969 -0.55599,0.67449 -0.83399,1.60417 -0.83399,2.78906 0,1.431 0.40104,2.57488 1.20313,3.43164 0.72916,0.77475 1.60872,1.16211 2.63867,1.16211 1.02083,0 1.98241,-0.28255 2.88477,-0.84765 0.082,-0.0547 0.19139,-0.082 0.32812,-0.082 0.1914,0 0.2871,0.12305 0.28711,0.36914 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2879"" />
+      <path
+         d=""m 456.73062,161.98898 c -10e-6,0.31901 -0.21421,0.48763 -0.64258,0.50586 -0.63803,0.009 -1.47201,0.0547 -2.50195,0.13672 -0.51043,0.10026 -0.87501,0.0365 -1.09375,-0.1914 -1.44011,-1.54948 -2.66147,-3.17188 -3.66406,-4.86719 -0.082,-0.14583 -0.18686,-0.21875 -0.31446,-0.21875 -0.15495,0 -0.42383,0.13672 -0.80664,0.41015 -0.42839,0.23699 -0.64258,0.57423 -0.64257,1.01172 -1e-5,0.3099 0.009,0.75652 0.0273,1.33985 0.0182,0.58333 0.16406,0.96614 0.4375,1.14843 0.1914,0.12761 0.63346,0.22787 1.32617,0.30079 0.42838,0.0547 0.64257,0.21419 0.64258,0.47851 -10e-6,0.20964 -0.0342,0.33952 -0.10254,0.38965 -0.0684,0.0501 -0.24838,0.0615 -0.54004,0.0342 -0.91146,-0.082 -2.45183,-0.0365 -4.62109,0.13672 -0.54688,0.0456 -0.8431,-0.0228 -0.88867,-0.20508 -0.0182,-0.0638 -0.0274,-0.15495 -0.0274,-0.27344 0,-0.28255 0.278,-0.49674 0.83399,-0.64258 0.5013,-0.1276 0.75195,-0.71549 0.75195,-1.76367 l 0,-11.94922 c 0,-0.74738 -0.0729,-1.26691 -0.21875,-1.55859 -0.20052,-0.37368 -0.61979,-0.66535 -1.25781,-0.875 -0.30079,-0.10024 -0.45118,-0.24152 -0.45117,-0.42383 -10e-6,-0.2643 0.21419,-0.46938 0.64257,-0.61523 0.68359,-0.22785 1.33529,-0.5423 1.95508,-0.94336 0.5013,-0.32811 0.8112,-0.49217 0.92969,-0.49219 0.37369,2e-5 0.56054,0.237 0.56055,0.71094 -1e-5,-0.0638 -0.005,0.38739 -0.0137,1.35351 -0.009,0.66538 -0.0137,1.55861 -0.0137,2.67969 l 0.0274,8.55859 c -1e-5,0.23699 0.0638,0.35548 0.1914,0.35547 0.13672,1e-5 0.34635,-0.11848 0.62891,-0.35547 0.7565,-0.59244 1.68619,-1.36718 2.78906,-2.32421 0.21874,-0.22786 0.32812,-0.41015 0.32813,-0.54688 -1e-5,-0.24608 -0.36915,-0.41926 -1.10743,-0.51953 -0.31901,-0.0365 -0.4694,-0.21418 -0.45117,-0.5332 0.0273,-0.319 0.18684,-0.45572 0.47852,-0.41016 0.65624,0.0912 1.61327,0.14129 2.87109,0.15039 0.87499,0.009 1.74543,0.0137 2.61133,0.0137 0.28254,0.009 0.42381,0.17775 0.42383,0.50586 -2e-5,0.30991 -0.22332,0.47853 -0.66992,0.50586 -0.70184,0.0273 -1.36265,0.18686 -1.98243,0.47852 -0.86589,0.39193 -1.79102,1.08008 -2.77539,2.06445 -0.0729,0.0547 -0.10938,0.12305 -0.10937,0.20508 -1e-5,0.12761 0.15494,0.43295 0.46484,0.91601 1.13932,1.73178 2.21484,3.03972 3.22656,3.92383 0.64713,0.55599 1.25325,0.83399 1.81836,0.83399 0.41926,0 0.67903,0.0296 0.7793,0.0889 0.10025,0.0592 0.15038,0.21648 0.15039,0.47168 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2881"" />
+      <path
+         d=""m 468.26968,160.17062 c -10e-6,0.39193 -0.52865,0.87956 -1.58593,1.46289 -1.20314,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.0026,-0.95703 -1.50391,-2.23307 -1.5039,-3.82812 -1e-5,-1.80468 0.56054,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33332,-1.53124 3.85547,-1.53125 0.90233,1e-5 1.74543,0.28712 2.52929,0.86133 0.70182,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35548 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44662,0.69271 -1.33984,0.95703 l -6.30274,1.87305 c 0.41016,2.16927 1.52213,3.2539 3.33594,3.2539 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39648,-0.17773 0.58789,-0.17773 0.14583,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.4056,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51562,3.62305 l 0,0.32813 3.71875,-1.1211 c 0.60155,-0.17317 0.90233,-0.48762 0.90234,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2883"" />
+      <path
+         d=""m 477.81265,161.18234 c -1e-5,0.4375 -0.40105,0.8112 -1.20312,1.1211 -0.71095,0.27343 -1.431,0.41015 -2.16016,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43294,-0.28027 -0.99804,-0.41699 -0.14584,-0.0365 -0.21875,-0.17773 -0.21875,-0.42383 0,-0.26432 0.0547,-0.42382 0.16406,-0.47852 0.98437,-0.48306 1.84114,-1.34895 2.57031,-2.59765 0.10026,-0.17317 0.29622,-0.22786 0.58789,-0.16407 0.20052,0.0638 0.30534,0.18231 0.31446,0.35547 l 0.0547,1.70899 c 0,0.12761 0.0228,0.21876 0.0684,0.27343 0.0638,0.0821 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17317,1e-5 0.17317,0.2142 0,0.64258 -0.20964,0.51954 -0.51954,0.7793 -0.92969,0.7793 l -2.06445,0 c -0.35547,0 -0.57422,0.0593 -0.65625,0.17773 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c -10e-6,1.13022 0.10025,1.84571 0.30078,2.14649 0.26432,0.38281 0.87955,0.57422 1.8457,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69726,-0.15722 0.72461,-0.15723 0.10937,1e-5 0.16405,0.0684 0.16406,0.20508 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2885"" />
+      <path
+         d=""m 267.56656,187.18898 c -2e-5,0.31901 -0.21421,0.48763 -0.64258,0.50586 -0.63803,0.009 -1.47202,0.0547 -2.50195,0.13672 -0.51043,0.10026 -0.87501,0.0365 -1.09375,-0.19141 -1.44012,-1.54947 -2.66147,-3.17187 -3.66406,-4.86718 -0.082,-0.14583 -0.18686,-0.21875 -0.31446,-0.21875 -0.15495,0 -0.42383,0.13672 -0.80664,0.41015 -0.42839,0.23699 -0.64258,0.57423 -0.64258,1.01172 0,0.3099 0.009,0.75652 0.0274,1.33985 0.0182,0.58333 0.16405,0.96614 0.4375,1.14843 0.1914,0.12761 0.63345,0.22787 1.32617,0.30078 0.42838,0.0547 0.64257,0.2142 0.64258,0.47852 -10e-6,0.20964 -0.0342,0.33952 -0.10254,0.38965 -0.0684,0.0501 -0.24838,0.0615 -0.54004,0.0342 -0.91147,-0.082 -2.45183,-0.0365 -4.62109,0.13672 -0.54688,0.0456 -0.8431,-0.0228 -0.88868,-0.20508 -0.0182,-0.0638 -0.0273,-0.15495 -0.0273,-0.27344 0,-0.28255 0.27799,-0.49674 0.83398,-0.64258 0.5013,-0.1276 0.75195,-0.71549 0.75196,-1.76367 l 0,-11.94922 c -1e-5,-0.74738 -0.0729,-1.26691 -0.21875,-1.55859 -0.20053,-0.37368 -0.6198,-0.66535 -1.25782,-0.875 -0.30078,-0.10024 -0.45117,-0.24152 -0.45117,-0.42383 0,-0.2643 0.21419,-0.46938 0.64258,-0.61523 0.68359,-0.22785 1.33528,-0.5423 1.95508,-0.94336 0.5013,-0.32811 0.81119,-0.49217 0.92969,-0.49219 0.37369,2e-5 0.56054,0.237 0.56054,0.71094 0,-0.0638 -0.005,0.38739 -0.0137,1.35351 -0.009,0.66538 -0.0137,1.55861 -0.0137,2.67969 l 0.0273,8.55859 c 0,0.23699 0.0638,0.35548 0.19141,0.35547 0.13671,1e-5 0.34635,-0.11848 0.62891,-0.35547 0.7565,-0.59244 1.68619,-1.36718 2.78906,-2.32422 0.21874,-0.22785 0.32811,-0.41014 0.32812,-0.54687 -10e-6,-0.24608 -0.36915,-0.41926 -1.10742,-0.51953 -0.31902,-0.0365 -0.46941,-0.21418 -0.45117,-0.5332 0.0273,-0.319 0.18684,-0.45572 0.47852,-0.41016 0.65624,0.0912 1.61327,0.14129 2.87109,0.15039 0.87499,0.009 1.74543,0.0137 2.61133,0.0137 0.28254,0.009 0.42381,0.17775 0.42383,0.50586 -2e-5,0.30991 -0.22333,0.47853 -0.66993,0.50586 -0.70183,0.0274 -1.36264,0.18686 -1.98242,0.47852 -0.86589,0.39193 -1.79102,1.08008 -2.77539,2.06445 -0.0729,0.0547 -0.10938,0.12305 -0.10937,0.20508 -1e-5,0.12761 0.15494,0.43295 0.46484,0.91601 1.13931,1.73178 2.21483,3.03972 3.22656,3.92383 0.64713,0.55599 1.25324,0.83399 1.81836,0.83399 0.41926,0 0.67902,0.0296 0.7793,0.0889 0.10024,0.0592 0.15037,0.21647 0.15039,0.47168 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2887"" />
+      <path
+         d=""m 283.31656,187.4214 c -2e-5,0.28256 -0.20509,0.41016 -0.61524,0.38282 -1.95964,-0.10026 -3.44532,-0.11849 -4.45703,-0.0547 -0.51954,0.0365 -0.80209,-0.0273 -0.84765,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0274,-0.23242 -10e-6,-0.18229 0.26432,-0.34635 0.79297,-0.49219 0.48306,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.81121,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65626,0.37371 -0.98438,0.76108 -0.98438,1.16211 l 0,5.00391 c 0,0.85677 0.56055,1.33528 1.68164,1.43554 0.42838,0.0365 0.64258,0.17318 0.64258,0.41016 0,0.22786 -0.0593,0.36458 -0.17773,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46485,0.0137 -1.43099,-0.0547 -2.90755,0.0182 -4.42968,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61524,0.041 -0.18229,-0.0365 -0.27344,-0.17773 -0.27343,-0.42382 -10e-6,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27344,-1.33984 -0.1276,-0.13671 -0.55143,-0.32812 -1.27148,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51041,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98437,-0.51953 0.24609,1e-5 0.41016,0.28029 0.49219,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55011,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64256,0.33724 1.27148,0.46484 0.41015,0.082 0.61522,0.23242 0.61524,0.45117 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2889"" />
+      <path
+         d=""m 289.48257,171.84914 c 0,0.41928 -0.15723,0.80893 -0.47168,1.16894 -0.31445,0.36004 -0.65853,0.54006 -1.03222,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05274,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41015,-0.99805 -1e-5,-0.40102 0.16634,-0.77472 0.49902,-1.12109 0.33268,-0.34634 0.69043,-0.51951 1.07324,-0.51953 0.92969,2e-5 1.39453,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15495,0.41471 -0.32812,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69337,-0.0729 -4.00586,0.0547 -0.35547,0.0365 -0.57878,0.0228 -0.66992,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13672,-0.4375 0,-0.20963 0.24153,-0.38281 0.72461,-0.51953 0.52864,-0.15495 0.79296,-0.66081 0.79297,-1.51758 l 0,-3.58203 c -1e-5,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20053,-0.40103 -0.61524,-0.70637 -1.24414,-0.91601 -0.28256,-0.10026 -0.42383,-0.25065 -0.42383,-0.45118 0,-0.26431 0.20507,-0.46027 0.61523,-0.58789 0.76562,-0.23697 1.44466,-0.55142 2.03711,-0.94336 0.47395,-0.32811 0.76562,-0.49217 0.875,-0.49218 0.36458,1e-5 0.54231,0.23699 0.5332,0.71093 -0.0365,2.38803 -0.0547,4.82162 -0.0547,7.30079 -10e-6,0.59245 0.0866,1.01627 0.25976,1.27148 0.1914,0.28255 0.55599,0.48307 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2891"" />
+      <path
+         d=""m 303.00406,169.01906 c -10e-6,0.38283 -0.17319,0.82945 -0.51953,1.33984 -0.34637,0.51044 -0.6198,0.76565 -0.82031,0.76563 -0.24611,2e-5 -0.50587,-0.12303 -0.7793,-0.36914 -0.57423,-0.41014 -1.08009,-0.61522 -1.51758,-0.61524 -1.73178,2e-5 -2.59766,1.21226 -2.59766,3.63672 l 0,2.93946 c 0,0.45574 0.39193,0.6517 1.17579,0.58789 l 1.73632,-0.13672 c 0.68359,-0.0547 1.05729,0.0547 1.1211,0.32812 0.0182,0.0912 0.0273,0.22332 0.0273,0.39649 -10e-6,0.3737 -0.0911,0.60613 -0.27344,0.69726 -0.10938,0.0638 -0.39193,0.0957 -0.84765,0.0957 l -1.73633,0 c -0.77475,1e-5 -1.17579,0.16407 -1.20313,0.49218 -0.0182,0.19142 -0.0182,2.17384 0,5.94727 0,0.51042 0.23698,0.875 0.71094,1.09375 0.35546,0.17318 0.94791,0.29167 1.77735,0.35547 0.32811,0.0273 0.52635,0.0661 0.59472,0.11621 0.0684,0.0501 0.10253,0.19824 0.10254,0.44433 -10e-6,0.28256 -0.0387,0.45118 -0.11621,0.50586 -0.0775,0.0547 -0.27117,0.0729 -0.58105,0.0547 -2.01433,-0.10937 -3.82358,-0.082 -5.42774,0.082 -0.41927,0.0456 -0.67448,0.0456 -0.76562,0 -0.0912,-0.0456 -0.13672,-0.20507 -0.13672,-0.47851 0,-0.22787 0.26432,-0.41472 0.79297,-0.56055 0.6289,-0.17318 0.94335,-0.6289 0.94336,-1.36719 l 0,-5.31836 c -10e-6,-0.55598 -0.0866,-0.94335 -0.25977,-1.16211 -0.11849,-0.14582 -0.34636,-0.27342 -0.68359,-0.38281 -0.52865,-0.16405 -0.79297,-0.42382 -0.79297,-0.7793 0,-0.24608 0.10937,-0.40103 0.32812,-0.46484 0.0729,-0.0182 0.30078,-0.0319 0.6836,-0.041 0.32812,-0.009 0.5332,-0.082 0.61523,-0.21875 0.0547,-0.10025 0.082,-0.34635 0.082,-0.73829 l 0,-2.17382 c 0,-1.73176 0.71094,-3.14908 2.13281,-4.25196 1.35807,-1.04816 3.02604,-1.57224 5.00391,-1.57226 0.8203,2e-5 1.23046,0.25067 1.23047,0.75195 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2893"" />
+      <path
+         d=""m 312.84781,185.37062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43816,0.97071 -3.70508,0.97071 -1.3763,0 -2.53385,-0.45117 -3.47265,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04817,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74543,0.28712 2.5293,0.86133 0.70181,0.51042 1.16665,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35547 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33985,0.95703 l -6.30273,1.87304 c 0.41015,2.16928 1.52213,3.25391 3.33594,3.25391 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24024,-5.48242 c 0,-0.50129 -0.2028,-0.94107 -0.60839,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32812 3.71875,-1.12109 c 0.60156,-0.17317 0.90234,-0.48762 0.90234,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2895"" />
+      <path
+         d=""m 326.72476,171.84914 c 0,0.41928 -0.15723,0.80893 -0.47168,1.16894 -0.31446,0.36004 -0.65853,0.54006 -1.03222,0.54004 -0.42839,2e-5 -0.7793,-0.12759 -1.05274,-0.38281 -0.27344,-0.25519 -0.41016,-0.58787 -0.41015,-0.99805 -10e-6,-0.40102 0.16633,-0.77472 0.49902,-1.12109 0.33268,-0.34634 0.69042,-0.51951 1.07324,-0.51953 0.92968,2e-5 1.39453,0.43752 1.39453,1.3125 z m 1.51758,15.47656 c -0.0456,0.26432 -0.15496,0.41471 -0.32812,0.45117 -0.0456,0.009 -0.26433,0 -0.65625,-0.0273 -1.35808,-0.0911 -2.69337,-0.0729 -4.00586,0.0547 -0.35548,0.0365 -0.57878,0.0228 -0.66993,-0.041 -0.0911,-0.0638 -0.13672,-0.20963 -0.13671,-0.4375 -10e-6,-0.20963 0.24153,-0.38281 0.7246,-0.51953 0.52865,-0.15495 0.79297,-0.66081 0.79297,-1.51758 l 0,-3.58203 c 0,-0.72004 -0.0729,-1.2259 -0.21875,-1.51758 -0.20052,-0.40103 -0.61523,-0.70637 -1.24414,-0.91601 -0.28255,-0.10026 -0.42383,-0.25065 -0.42383,-0.45118 0,-0.26431 0.20508,-0.46027 0.61524,-0.58789 0.76562,-0.23697 1.44466,-0.55142 2.03711,-0.94336 0.47395,-0.32811 0.76562,-0.49217 0.875,-0.49218 0.36458,1e-5 0.54231,0.23699 0.5332,0.71093 -0.0365,2.38803 -0.0547,4.82162 -0.0547,7.30079 0,0.59245 0.0866,1.01627 0.25977,1.27148 0.1914,0.28255 0.55598,0.48307 1.09375,0.60156 0.59244,0.13672 0.86132,0.35092 0.80664,0.64258 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2897"" />
+      <path
+         d=""m 338.55093,184.72804 c -10e-6,0.96615 -0.37142,1.73406 -1.11425,2.30372 -0.74285,0.56966 -1.75685,0.85449 -3.042,0.85449 -0.85677,0 -1.71354,-0.0911 -2.57031,-0.27344 -0.73828,-0.16406 -1.16667,-0.31445 -1.28515,-0.45117 -0.0729,-0.1276 -0.10938,-0.75195 -0.10938,-1.87305 0,-0.48307 0.10937,-0.73372 0.32813,-0.75195 0.21874,-0.0273 0.40559,0.0911 0.56054,0.35547 0.68359,1.19401 1.78646,1.79101 3.3086,1.79101 1.28514,0 1.92772,-0.44661 1.92773,-1.33984 -1e-5,-0.39193 -0.14584,-0.72005 -0.4375,-0.98438 -0.31902,-0.30077 -0.93881,-0.65168 -1.85937,-1.05273 -1.33074,-0.59244 -2.21941,-1.11197 -2.66602,-1.55859 -0.48308,-0.47396 -0.72461,-1.11198 -0.72461,-1.91407 0,-0.98436 0.37825,-1.74999 1.13477,-2.29687 0.70181,-0.52864 1.64062,-0.79296 2.8164,-0.79297 0.73828,1e-5 1.41276,0.0593 2.02344,0.17773 0.65624,0.1185 0.99804,0.26434 1.02539,0.4375 0.0729,0.51043 0.2233,1.24871 0.45117,2.21485 0.0273,0.1185 -0.10027,0.2142 -0.38281,0.28711 -0.30079,0.0638 -0.50131,0.0137 -0.60156,-0.15039 -0.72006,-1.17578 -1.63152,-1.76367 -2.73438,-1.76368 -1.2487,1e-5 -1.87305,0.40106 -1.87304,1.20313 -10e-6,0.44662 0.16861,0.80209 0.50585,1.06641 0.30078,0.22787 1.00716,0.58334 2.11915,1.0664 1.16665,0.50131 1.95962,0.95248 2.3789,1.35352 0.54687,0.51953 0.8203,1.2168 0.82031,2.09179 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2899"" />
+      <path
+         d=""m 362.44937,187.4214 c -10e-6,0.28256 -0.20509,0.41016 -0.61523,0.38282 -1.95965,-0.10026 -3.44533,-0.11849 -4.45703,-0.0547 -0.51955,0.0365 -0.8021,-0.0273 -0.84766,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0273,-0.23242 -1e-5,-0.18229 0.26431,-0.34635 0.79296,-0.49219 0.48307,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.8112,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65625,0.37371 -0.98438,0.76108 -0.98437,1.16211 l 0,5.00391 c -10e-6,0.85677 0.56054,1.33528 1.68164,1.43554 0.42838,0.0365 0.64257,0.17318 0.64258,0.41016 -10e-6,0.22786 -0.0593,0.36458 -0.17774,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46484,0.0137 -1.431,-0.0547 -2.90756,0.0182 -4.42969,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61523,0.041 -0.1823,-0.0365 -0.27344,-0.17773 -0.27344,-0.42382 0,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27343,-1.33984 -0.12761,-0.13671 -0.55144,-0.32812 -1.27149,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51042,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98438,-0.51953 0.24609,1e-5 0.41015,0.28029 0.49218,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55012,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64257,0.33724 1.27149,0.46484 0.41014,0.082 0.61522,0.23242 0.61523,0.45117 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2901"" />
+      <path
+         d=""m 375.39664,182.15773 c -2e-5,1.58594 -0.58791,2.92806 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43554 0.96613,0.9297 1.4492,2.18751 1.44922,3.77344 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2903"" />
+      <path
+         d=""m 385.17203,186.38234 c -1e-5,0.4375 -0.40105,0.8112 -1.20313,1.1211 -0.71094,0.27343 -1.43099,0.41015 -2.16015,0.41015 -1.97787,0 -2.9668,-1.05273 -2.9668,-3.1582 l 0,-4.94922 c 0,-0.6289 -0.0501,-1.01399 -0.15039,-1.15527 -0.10026,-0.14127 -0.43295,-0.28027 -0.99805,-0.417 -0.14583,-0.0364 -0.21875,-0.17772 -0.21875,-0.42382 0,-0.26432 0.0547,-0.42382 0.16406,-0.47852 0.98438,-0.48306 1.84115,-1.34895 2.57032,-2.59766 0.10025,-0.17316 0.29622,-0.22785 0.58789,-0.16406 0.20051,0.0638 0.30533,0.18231 0.31445,0.35547 l 0.0547,1.70898 c -1e-5,0.12762 0.0228,0.21877 0.0684,0.27344 0.0638,0.082 0.20963,0.12306 0.4375,0.12305 l 3.04883,0 c 0.17316,1e-5 0.17316,0.2142 0,0.64258 -0.20965,0.51954 -0.51954,0.7793 -0.92969,0.77929 l -2.06445,0 c -0.35548,1e-5 -0.57423,0.0593 -0.65625,0.17774 -0.0638,0.082 -0.0957,0.30535 -0.0957,0.66992 l 0,4.4707 c 0,1.13021 0.10026,1.84571 0.30078,2.14649 0.26432,0.38281 0.87955,0.57422 1.84571,0.57422 0.319,0 0.70637,-0.0524 1.16211,-0.15723 0.45572,-0.10482 0.69725,-0.15722 0.72461,-0.15723 0.10936,1e-5 0.16405,0.0684 0.16406,0.20508 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2905"" />
+      <path
+         d=""m 404.23062,185.37062 c -10e-6,0.39193 -0.52866,0.87956 -1.58594,1.46289 -1.20313,0.64714 -2.43815,0.97071 -3.70507,0.97071 -1.37631,0 -2.53386,-0.45117 -3.47266,-1.35352 -1.00261,-0.95703 -1.50391,-2.23307 -1.50391,-3.82812 0,-1.80468 0.56055,-3.2539 1.68164,-4.34766 1.04818,-1.02082 2.33333,-1.53124 3.85547,-1.53125 0.90234,1e-5 1.74544,0.28712 2.5293,0.86133 0.70181,0.51042 1.16666,1.09376 1.39453,1.75 0.082,0.22787 0.20507,0.35547 0.36914,0.38281 0.23697,0.0456 0.35546,0.20509 0.35547,0.47852 -1e-5,0.3737 -0.44663,0.69271 -1.33984,0.95703 l -6.30274,1.87304 c 0.41015,2.16928 1.52213,3.25391 3.33594,3.25391 1.04817,0 2.24218,-0.38281 3.58203,-1.14844 0.20051,-0.11848 0.39647,-0.17773 0.58789,-0.17773 0.14582,0 0.21874,0.13216 0.21875,0.39648 z m -3.24023,-5.48242 c -10e-6,-0.50129 -0.20281,-0.94107 -0.6084,-1.31933 -0.40561,-0.37825 -0.90463,-0.56738 -1.49707,-0.56739 -1.67709,1e-5 -2.51563,1.20769 -2.51563,3.62305 l 0,0.32812 3.71875,-1.12109 c 0.60156,-0.17317 0.90234,-0.48762 0.90235,-0.94336 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2907"" />
+      <path
+         d=""m 420.63687,187.4214 c -10e-6,0.28256 -0.20509,0.41016 -0.61523,0.38282 -1.95965,-0.10026 -3.44533,-0.11849 -4.45703,-0.0547 -0.51955,0.0365 -0.8021,-0.0273 -0.84766,-0.19141 -0.0182,-0.0547 -0.0274,-0.13216 -0.0273,-0.23242 -1e-5,-0.18229 0.26431,-0.34635 0.79296,-0.49219 0.48307,-0.13671 0.7246,-0.60611 0.72461,-1.4082 l 0,-3.63672 c -10e-6,-2.08723 -0.90691,-3.13085 -2.7207,-3.13086 -0.8112,1e-5 -1.56316,0.19142 -2.25586,0.57422 -0.65625,0.37371 -0.98438,0.76108 -0.98437,1.16211 l 0,5.00391 c -10e-6,0.85677 0.56054,1.33528 1.68164,1.43554 0.42838,0.0365 0.64257,0.17318 0.64258,0.41016 -10e-6,0.22786 -0.0593,0.36458 -0.17774,0.41016 -0.0547,0.0182 -0.20964,0.0228 -0.46484,0.0137 -1.431,-0.0547 -2.90756,0.0182 -4.42969,0.21875 -0.32813,0.0456 -0.53321,0.0592 -0.61523,0.041 -0.1823,-0.0365 -0.27344,-0.17773 -0.27344,-0.42382 0,-0.21875 0.25976,-0.4056 0.77929,-0.56055 0.48307,-0.14583 0.72461,-0.75195 0.72461,-1.81836 l 0,-4.14258 c 0,-0.70181 -0.0911,-1.14843 -0.27343,-1.33984 -0.12761,-0.13671 -0.55144,-0.32812 -1.27149,-0.57422 -0.18229,-0.0638 -0.27344,-0.1914 -0.27344,-0.38281 0,-0.18229 0.18685,-0.34179 0.56055,-0.47852 0.51042,-0.1914 1.07096,-0.49673 1.68164,-0.91602 0.51041,-0.34634 0.83854,-0.51952 0.98438,-0.51953 0.24609,1e-5 0.41015,0.28029 0.49218,0.84082 0.082,0.56056 0.19596,0.84083 0.3418,0.84082 -0.0729,1e-5 0.39192,-0.26659 1.39453,-0.7998 1.0026,-0.53319 1.99153,-0.79979 2.9668,-0.79981 2.36066,2e-5 3.55012,1.34442 3.56836,4.03321 l 0.0273,4.40234 c -1e-5,0.56511 0.14582,0.97071 0.4375,1.2168 0.21874,0.18229 0.64257,0.33724 1.27149,0.46484 0.41014,0.082 0.61522,0.23242 0.61523,0.45117 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2909"" />
+      <path
+         d=""m 433.58414,182.15773 c -2e-5,1.58594 -0.58791,2.92806 -1.76367,4.02637 -1.1758,1.09831 -2.63413,1.64746 -4.375,1.64746 -1.7409,0 -3.1172,-0.48307 -4.12891,-1.44922 -0.97526,-0.94791 -1.46289,-2.20117 -1.46289,-3.75976 0,-1.61328 0.61523,-2.97135 1.8457,-4.07422 1.19401,-1.0664 2.62044,-1.5996 4.2793,-1.59961 1.77733,1e-5 3.16275,0.47852 4.15625,1.43554 0.96613,0.9297 1.4492,2.18751 1.44922,3.77344 z m -2.40625,0.83399 c -10e-6,-1.43099 -0.34637,-2.59309 -1.03907,-3.48633 -0.67448,-0.86588 -1.53125,-1.29882 -2.57031,-1.29883 -0.96615,1e-5 -1.75456,0.33953 -2.36523,1.01856 -0.61068,0.67904 -0.91602,1.50619 -0.91602,2.48144 0,1.56771 0.35547,2.78907 1.06641,3.66406 0.65624,0.80209 1.51301,1.20313 2.57031,1.20313 1.0026,0 1.79556,-0.33268 2.37891,-0.99805 0.58332,-0.66536 0.87499,-1.52669 0.875,-2.58398 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2911"" />
+      <path
+         d=""m 448.65054,186.51906 c -10e-6,0.18229 -0.4284,0.46029 -1.28515,0.83398 -0.72918,0.31902 -1.09376,0.47852 -1.09375,0.47852 -0.1185,0 -0.37143,-0.20508 -0.75879,-0.61523 -0.38738,-0.41016 -0.65854,-0.61524 -0.81348,-0.61524 -0.082,0 -0.55144,0.19141 -1.4082,0.57422 -0.85678,0.38281 -1.60873,0.57422 -2.25586,0.57422 -1.36719,0 -2.31967,-0.25977 -2.85742,-0.7793 -0.58334,-0.55599 -0.87501,-1.56315 -0.875,-3.02148 l 0,-2.74805 c -10e-6,-0.76562 -0.0775,-1.30338 -0.23242,-1.61328 -0.20964,-0.3828 -0.63347,-0.67447 -1.27149,-0.875 -0.20964,-0.0638 -0.31445,-0.17773 -0.31445,-0.3418 0,-0.18228 0.17773,-0.34178 0.5332,-0.47851 0.67448,-0.26432 1.3444,-0.5332 2.00977,-0.80664 0.46484,-0.1914 0.80208,-0.2871 1.01172,-0.28711 0.319,1e-5 0.47851,0.2142 0.47851,0.64258 0,10e-6 -0.0137,0.4808 -0.041,1.44238 -0.0274,0.96159 -0.041,1.87533 -0.041,2.74121 l 0,1.64062 c -10e-6,1.11199 0.21874,1.87305 0.65625,2.28321 0.39192,0.36458 1.10741,0.54687 2.14648,0.54687 1.60416,0 2.40624,-0.82031 2.40625,-2.46094 l 0,-2.43359 c -10e-6,-0.88411 -0.0798,-1.45149 -0.23925,-1.70215 -0.15952,-0.25064 -0.58563,-0.46711 -1.27832,-0.64941 -0.20053,-0.082 -0.30079,-0.2233 -0.30079,-0.42383 0,-0.20963 0.12304,-0.36002 0.36915,-0.45117 1.8867,-0.68358 2.92121,-1.02538 3.10351,-1.02539 0.35546,1e-5 0.53319,0.20509 0.5332,0.61523 -10e-6,-0.009 -0.0137,0.44891 -0.041,1.37403 -0.0274,0.92513 -0.041,1.82064 -0.041,2.68652 l 0,3.44531 c -1e-5,0.64714 0.47395,1.00716 1.42188,1.08008 0.31899,0.0273 0.4785,0.15039 0.47851,0.36914 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2913"" />
+      <path
+         d=""m 462.54117,178.58937 c -0.0912,0.67449 -0.32814,1.01173 -0.71094,1.01172 -0.13673,1e-5 -0.39194,-0.0273 -0.76562,-0.082 -0.16408,-0.0182 -0.27801,-0.0273 -0.3418,-0.0273 -0.12762,0.009 -0.19142,0.0912 -0.19141,0.24609 -1e-5,0.0456 0.009,0.18686 0.0273,0.42383 0.0182,0.23699 0.0273,0.47852 0.0273,0.72461 -1e-5,1.97787 -1.28061,3.32227 -3.8418,4.0332 -1.51302,0.41927 -2.26953,0.75651 -2.26953,1.01172 0,0.26432 0.56054,0.4694 1.68164,0.61523 l 2.13282,0.28711 c 1.194,0.15495 2.06899,0.37826 2.625,0.66993 0.8841,0.46484 1.32615,1.18033 1.32617,2.14648 -2e-5,1.35807 -0.77931,2.51562 -2.33789,3.47266 -1.51303,0.92056 -3.27215,1.38085 -5.27735,1.38086 -1.23958,-1e-5 -2.22624,-0.25066 -2.95996,-0.75196 -0.73372,-0.50131 -1.10059,-1.16667 -1.10058,-1.99609 -1e-5,-1.25782 0.87499,-2.46094 2.625,-3.60938 -0.80209,-0.32812 -1.20313,-0.84309 -1.20313,-1.54492 0,-0.65625 0.74739,-1.25325 2.24219,-1.79101 -2.15105,-0.57422 -3.22657,-1.83203 -3.22656,-3.77344 -1e-5,-1.21223 0.43977,-2.21711 1.31933,-3.01465 0.87956,-0.79752 1.98925,-1.19628 3.3291,-1.19629 0.95703,10e-6 1.89127,0.21876 2.80274,0.65625 0.60155,0.28256 1.35806,0.41017 2.26953,0.38281 l 1.20312,-0.0273 c 0.30989,-0.009 0.50129,0.0319 0.57422,0.12305 0.0729,0.0912 0.0866,0.30079 0.041,0.6289 z m -4.08789,2.55664 c -1e-5,-2.11457 -0.91147,-3.17186 -2.73438,-3.17187 -1.54948,1e-5 -2.32422,0.97983 -2.32422,2.93945 0,1.94141 0.85677,2.91212 2.57032,2.91211 0.71093,10e-6 1.30337,-0.25065 1.77734,-0.75195 0.47395,-0.5013 0.71093,-1.14388 0.71094,-1.92774 z m 2.16015,9.32422 c -10e-6,-0.69271 -0.83855,-1.16211 -2.51562,-1.4082 l -2.7207,-0.38281 c -0.25522,-0.0456 -0.61069,-0.11394 -1.06641,-0.20508 -0.96615,0.77474 -1.44922,1.73632 -1.44922,2.88476 0,1.29427 0.875,1.9414 2.625,1.94141 1.35807,-1e-5 2.5703,-0.32357 3.63672,-0.9707 0.99348,-0.59245 1.49022,-1.21225 1.49023,-1.85938 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2915"" />
+      <path
+         d=""m 478.3732,187.35304 c -2e-5,0.30079 -0.20509,0.44206 -0.61523,0.42383 -2.28778,-0.082 -3.77345,-0.10026 -4.45704,-0.0547 -0.33725,0.0273 -0.53777,0.0319 -0.60156,0.0137 -0.17319,-0.0456 -0.25977,-0.19141 -0.25976,-0.4375 -1e-5,-0.17318 0.25975,-0.33724 0.77929,-0.49219 0.34635,-0.10937 0.5651,-0.27799 0.65625,-0.50586 0.0456,-0.1276 0.0683,-0.41927 0.0684,-0.875 l 0,-3.69141 c -1e-5,-2.1328 -0.90235,-3.19921 -2.70703,-3.19921 -0.80209,0 -1.55404,0.19141 -2.25586,0.57421 -0.66537,0.3646 -0.99805,0.72462 -0.99805,1.08008 l 0,5.20899 c 0,0.875 0.56055,1.37174 1.68165,1.49023 0.42837,0.0365 0.64257,0.17318 0.64257,0.41016 0,0.18229 -0.0319,0.30078 -0.0957,0.35547 -0.0638,0.0547 -0.2461,0.0775 -0.54687,0.0684 -1.44923,-0.0547 -2.92579,-0.0182 -4.42969,0.10937 -0.32813,0.0273 -0.53321,0.0319 -0.61524,0.0137 -0.18229,-0.0365 -0.27344,-0.17773 -0.27343,-0.42383 -1e-5,-0.20052 0.25976,-0.36914 0.77929,-0.50586 0.48307,-0.13671 0.72461,-0.63346 0.72461,-1.49023 l 0,-12.37305 c 0,-0.72003 -0.0729,-1.24412 -0.21875,-1.57226 -0.20964,-0.43749 -0.62891,-0.76105 -1.25781,-0.97071 -0.2461,-0.082 -0.36914,-0.2324 -0.36914,-0.45117 0,-0.15493 0.18685,-0.31443 0.56055,-0.47851 0.5013,-0.22785 1.13932,-0.56053 1.91406,-0.99805 0.5013,-0.28253 0.84309,-0.42381 1.02539,-0.42383 0.33723,2e-5 0.50585,0.23244 0.50586,0.69727 -1e-5,-0.009 -0.0137,0.44435 -0.041,1.36035 -0.0274,0.91603 -0.041,1.80698 -0.041,2.67285 l 0,4.67578 c -10e-6,0.50131 0.0729,0.75196 0.21875,0.75196 -0.082,0 0.37597,-0.26204 1.37402,-0.78614 0.99804,-0.52408 1.94368,-0.78612 2.83691,-0.78613 2.42447,1e-5 3.64583,1.34441 3.66407,4.0332 l 0.0273,4.6211 c 0.009,0.92057 0.57876,1.43554 1.70899,1.54492 0.41014,0.0365 0.61521,0.17318 0.61523,0.41015 z""
+         style=""line-height:89.99999762%;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2917"" />
+    </g>
+    <g
+       style=""font-size:40px;font-style:normal;font-weight:normal;fill:#000000;fill-opacity:1;stroke:none;font-family:Bitstream Vera Sans""
+       id=""text3850"">
+      <path
+         d=""m 229.85182,43.77803 c -0.79695,3.140714 -1.28913,8.414146 -1.47656,15.820313 -7e-5,1.453199 -0.65632,2.179761 -1.96875,2.179687 -1.31257,7.4e-5 -2.22663,-0.632738 -2.74219,-1.898437 -1.40631,-3.421796 -2.74225,-5.812419 -4.00781,-7.171875 -1.50006,-1.593666 -3.49225,-2.554603 -5.97656,-2.882813 -2.67193,-0.421789 -9.32818,-0.632726 -19.96875,-0.632812 -2.43754,8.6e-5 -4.03129,0.257898 -4.78125,0.773437 -0.46879,0.32821 -0.70316,1.031335 -0.70313,2.109375 l 0,31.851563 c -3e-5,1.078175 0.67966,1.5938 2.03906,1.546875 4.17184,-0.04682 10.21871,-0.328075 18.14063,-0.84375 1.54682,-0.187449 2.58979,-0.691355 3.12891,-1.511719 0.539,-0.820259 1.06634,-2.941351 1.58203,-6.363281 0.32806,-1.87494 1.42963,-2.601502 3.30468,-2.179688 1.59369,0.328186 2.27338,1.054747 2.03907,2.179688 -1.31256,6.375052 -1.73444,14.671919 -1.26563,24.890627 0.0468,1.21878 -0.72662,1.87503 -2.32031,1.96875 -1.31256,0.14065 -2.13287,-0.56247 -2.46094,-2.10938 -1.2188,-5.859333 -3.48052,-8.988236 -6.78515,-9.386716 -3.30474,-0.398394 -8.68364,-0.597612 -16.13672,-0.597656 -0.84379,4.4e-5 -1.26566,0.304731 -1.26563,0.914062 l 0,31.64063 c -3e-5,2.34375 0.86716,3.9375 2.60156,4.78125 1.35934,0.70313 4.28903,1.33594 8.78907,1.89843 2.29683,0.23438 3.30464,1.24219 3.02343,3.02344 -0.28129,1.54688 -2.34379,2.15625 -6.1875,1.82813 -11.1094,-0.89063 -20.27345,-0.84375 -27.49218,0.14062 -2.01564,0.28125 -3.02345,-0.53906 -3.02344,-2.46094 -1e-5,-1.21874 1.0078,-1.92187 3.02344,-2.10937 4.59373,-0.51562 6.8906,-4.54687 6.89062,-12.09375 l 0,-60.187502 c -2e-5,-3.093671 -0.5508,-5.472575 -1.65234,-7.136719 -1.10158,-1.663977 -3.15236,-3.175695 -6.15235,-4.535156 -1.87501,-0.843661 -2.57813,-1.992098 -2.10937,-3.445313 0.23436,-0.890532 0.60936,-1.382719 1.125,-1.476562 0.46874,-0.140532 1.71092,-0.04678 3.72656,0.28125 2.95311,0.468842 9.91404,0.703217 20.88281,0.703125 12.93746,9.2e-5 24.11713,-0.281158 33.53907,-0.84375 3.14055,-0.187407 4.71086,0.07041 4.71093,0.773437 -7e-5,0.187592 -0.0235,0.375092 -0.0703,0.5625 z""
+         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2830"" />
+      <path
+         d=""m 275.55495,133.14522 c -4e-5,1.875 -1.05473,2.69531 -3.16407,2.46094 -6.46877,-0.60938 -14.48439,-0.51563 -24.04687,0.28125 -1.92189,0.18749 -3.10548,0.14062 -3.55078,-0.14063 -0.44532,-0.28125 -0.66798,-1.05469 -0.66797,-2.32031 -1e-5,-1.125 1.27733,-2.07422 3.83203,-2.84766 2.55467,-0.77343 3.83202,-3.08202 3.83203,-6.92578 l 0,-63.632812 c -1e-5,-3.796796 -0.55079,-6.585856 -1.65234,-8.367188 -1.10158,-1.781164 -3.03517,-3.163975 -5.80078,-4.148437 -1.45313,-0.515537 -2.1797,-1.242099 -2.17969,-2.179688 -1e-5,-1.406158 1.05468,-2.460845 3.16406,-3.164062 3.18749,-1.031156 6.49217,-2.624904 9.91406,-4.78125 2.81248,-1.687401 4.59373,-2.53115 5.34375,-2.53125 1.73435,1e-4 2.60154,1.195412 2.60157,3.585937 -3e-5,-0.187403 -0.0938,2.156345 -0.28125,7.03125 -0.14065,4.64071 -0.18753,9.211018 -0.14063,13.710938 l 0.28125,62.789062 c -2e-5,2.85939 0.7031,4.9336 2.10938,6.22266 1.40622,1.28906 3.82028,2.14453 7.24218,2.5664 2.10934,0.23438 3.16403,1.03126 3.16407,2.39063 z""
+         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2832"" />
+      <path
+         d=""m 339.67995,128.43428 c -7e-5,0.98438 -1.79303,2.47266 -5.37891,4.46484 -3.58599,1.99219 -6.45708,2.98828 -8.61328,2.98829 -1.82817,-10e-6 -3.44536,-0.89063 -4.85156,-2.67188 -1.40629,-1.78125 -2.39067,-2.67187 -2.95313,-2.67187 -0.42191,0 -2.64847,0.96094 -6.67969,2.88281 -4.03128,1.92187 -8.08596,2.88281 -12.16406,2.88281 -3.84377,0 -7.0547,-1.125 -9.63281,-3.375 -2.81251,-2.48437 -4.21876,-5.85937 -4.21875,-10.125 -1e-5,-8.10935 9.28123,-13.92185 27.84375,-17.4375 3.18746,-0.60934 4.80465,-1.89841 4.85156,-3.86719 l 0.14063,-4.499997 c 0.28121,-7.687454 -3.11723,-11.5312 -10.19532,-11.53125 -2.01565,5e-5 -3.9258,1.804735 -5.73046,5.414062 -1.80471,3.609416 -4.39456,5.554727 -7.76954,5.835938 -3.84376,0.375038 -5.76563,-1.242148 -5.76562,-4.851563 -1e-5,-2.249954 2.85936,-4.874951 8.57812,-7.875 5.99998,-3.14057 11.7656,-4.710881 17.29688,-4.710937 9.51558,5.6e-5 14.22651,4.523489 14.13281,13.570312 l -0.28125,28.968755 c -0.0469,3.04688 1.24214,4.57032 3.86719,4.57031 0.51557,1e-5 1.49994,-0.11718 2.95312,-0.35156 1.45307,-0.23437 2.29682,-0.35156 2.53125,-0.35157 1.35932,1e-5 2.039,0.91407 2.03907,2.74219 z M 318.0237,112.40303 c 0.0468,-1.17185 -0.2227,-1.94529 -0.8086,-2.32031 -0.58597,-0.37498 -1.51175,-0.44529 -2.77734,-0.21094 -11.2969,2.01565 -16.94533,5.69533 -16.94531,11.03906 -2e-5,5.39064 2.92966,8.08595 8.78906,8.08594 2.34372,1e-5 4.75778,-0.44531 7.24219,-1.33594 2.90621,-1.03124 4.35933,-2.27342 4.35937,-3.72656 z""
+         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2834"" />
+      <path
+         d=""m 392.13307,120.06709 c -5e-5,4.96876 -1.9102,8.91798 -5.73047,11.84766 -3.82035,2.92969 -9.03519,4.39453 -15.64453,4.39453 -4.40627,0 -8.81252,-0.46875 -13.21875,-1.40625 -3.79688,-0.84375 -6.00001,-1.61719 -6.60937,-2.32031 -0.37501,-0.65625 -0.56251,-3.86718 -0.5625,-9.63281 -1e-5,-2.48436 0.56249,-3.77343 1.6875,-3.86719 1.12499,-0.14061 2.08592,0.46876 2.88281,1.82812 3.51561,6.14064 9.18748,9.21095 17.01562,9.21094 6.60934,1e-5 9.91403,-2.29687 9.91407,-6.89062 -4e-5,-2.01562 -0.75004,-3.70311 -2.25,-5.0625 -1.64066,-1.54686 -4.82816,-3.35155 -9.5625,-5.41407 -6.84377,-3.04685 -11.41408,-5.71872 -13.71094,-8.01562 -2.48439,-2.43747 -3.72657,-5.718716 -3.72656,-9.843752 -1e-5,-5.062455 1.9453,-8.999951 5.83593,-11.8125 3.60936,-2.718695 8.43748,-4.078069 14.48438,-4.078125 3.79684,5.6e-5 7.26559,0.304743 10.40625,0.914062 3.37496,0.60943 5.13277,1.359429 5.27344,2.25 0.37495,2.625051 1.14839,6.421922 2.32031,11.390625 0.14058,0.609416 -0.51567,1.101603 -1.96875,1.476563 -1.54692,0.328165 -2.57817,0.07035 -3.09375,-0.773438 -3.70317,-6.046828 -8.39066,-9.070262 -14.0625,-9.070312 -6.4219,5e-5 -9.63283,2.062548 -9.63281,6.1875 -2e-5,2.296916 0.86716,4.12504 2.60156,5.484375 1.54685,1.171912 5.17966,3.000035 10.89844,5.484372 5.99996,2.57816 10.07808,4.89847 12.23437,6.96094 2.81245,2.6719 4.2187,6.25783 4.21875,10.75781 z""
+         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2836"" />
+      <path
+         d=""m 473.69557,132.72334 c -7e-5,1.64063 -1.10163,2.50782 -3.30469,2.60157 -3.28131,0.0469 -7.57037,0.28124 -12.86718,0.70312 -2.62506,0.51562 -4.50006,0.1875 -5.625,-0.98437 -7.4063,-7.96875 -13.68754,-16.31249 -18.84375,-25.03125 -0.42191,-0.74998 -0.96097,-1.12498 -1.61719,-1.125 -0.79691,2e-5 -2.17972,0.70315 -4.14844,2.10937 -2.20315,1.21877 -3.30471,2.95315 -3.30469,5.20313 -2e-5,1.59376 0.0469,3.89064 0.14063,6.89062 0.0937,3.00001 0.84372,4.96876 2.25,5.90625 0.98435,0.65626 3.25778,1.17188 6.82031,1.54688 2.20309,0.28125 3.30465,1.10156 3.30469,2.46093 -4e-5,1.07813 -0.17582,1.7461 -0.52734,2.00391 -0.3516,0.25781 -1.27738,0.31641 -2.77735,0.17578 -4.68753,-0.42187 -12.60939,-0.1875 -23.76562,0.70313 -2.81251,0.23437 -4.33595,-0.11719 -4.57032,-1.05469 -0.0937,-0.32813 -0.14063,-0.79688 -0.14062,-1.40625 -1e-5,-1.45312 1.42968,-2.55469 4.28906,-3.30469 2.57811,-0.65624 3.86718,-3.67968 3.86719,-9.07031 l 0,-61.453127 c -1e-5,-3.843671 -0.37501,-6.515543 -1.125,-8.015625 -1.03126,-1.92179 -3.18751,-3.421788 -6.46875,-4.5 -1.54688,-0.515536 -2.32032,-1.242098 -2.32031,-2.179688 -1e-5,-1.359283 1.10155,-2.413969 3.30468,-3.164062 3.51562,-1.17178 6.86718,-2.788966 10.05469,-4.851563 2.57811,-1.6874 4.17186,-2.531149 4.78125,-2.53125 1.92185,1.01e-4 2.88279,1.21885 2.88281,3.65625 -2e-5,-0.328027 -0.0235,1.992283 -0.0703,6.960938 -0.0469,3.421962 -0.0703,8.015707 -0.0703,13.78125 l 0.14062,44.015627 c -2e-5,1.21878 0.3281,1.82815 0.98438,1.82812 0.7031,3e-5 1.78122,-0.60934 3.23437,-1.82812 3.8906,-3.046842 8.67184,-7.031213 14.34375,-11.953127 1.12496,-1.17183 1.68746,-2.109329 1.6875,-2.8125 -4e-5,-1.265577 -1.89848,-2.156201 -5.69531,-2.671875 -1.64066,-0.18745 -2.4141,-1.101512 -2.32031,-2.742188 0.14059,-1.64057 0.9609,-2.343695 2.46094,-2.109375 3.37495,0.468805 8.29682,0.726617 14.76562,0.773438 4.49994,0.04693 8.9765,0.07037 13.42969,0.07031 1.45306,0.04693 2.17962,0.914116 2.17969,2.601563 -7e-5,1.5938 -1.14851,2.460986 -3.44532,2.601562 -3.60943,0.140674 -7.00787,0.960986 -10.19531,2.460938 -4.45317,2.015669 -9.21098,5.554728 -14.27344,10.617187 -0.37504,0.281286 -0.56254,0.632845 -0.5625,1.054685 -4e-5,0.65629 0.79684,2.2266 2.39063,4.71094 5.85933,8.90627 11.39057,15.63283 16.59375,20.17969 3.32806,2.85938 6.44525,4.28907 9.35156,4.28906 2.15618,1e-5 3.49212,0.15235 4.00781,0.45703 0.51556,0.30469 0.77337,1.11329 0.77344,2.42578 z""
+         style=""font-size:144px;font-family:High Tower Text;-inkscape-font-specification:High Tower Text""
+         id=""path2838"" />
+    </g>
+  </g>
+</svg>
",add missing tag in inkscape,add missing tag in inkscape,add missing tag in inkscape,llm_rectified,0.0,5,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",flask.png,,"PNG

   
IHDR         n֕   sBIT|d   	pHYs  
	  
	u   tEXtSoftware www.inkscape.org<    IDATxweǿgSHB%HлP)&
 **XRDTE4! 	E !$gνwٽ}>s<9s<=3 $p0!0 \͹uV@
,/6a}f~Gؾp-7HASm83bf w883
h<%S> }e.(@ L3#Z@` ,
h<'E82L*sD:OXQs@6ȍIt`Wjaj^(<%4X`IC_I ~707eyW@34OI%3;N;zYdmoKldf33[
=fM@EnVL ,lC1~}}WG#w	mfPbN{8!y@G4JOls
Xc=r3تLsS[50~|*)
T	5k$ڭCf_]rOiڠ]Ll[ĝH)W_^1h/CfP]
 GGLrX<	<R}C
R
F)ym<9=y0:Of~`αűbfo#2ڌT#a>+uw""%{vVlZ-˱¾)e`wGl9P@}!h:LǤpb@-Bj`)rkf$u%tWyLݽHZe]KP^a}iX	܌]2=)3P38zk;\w&CZEwKX+.
2=$$r^A3Soj>>4;P,Q\](`""
GAZ
\\F.mf[v%?)1L$]B
3Orefp8z#fnh:Ɠ]_B̆ Q[l<@ ""
;a%p
p=z 8e4_Fe
`>nArߗI>;ӕzp1WV;p<b95C|`XpLs4I=ht}k=""2Z/kP5	Nw̥FX |*?BK6Ӏ<u̷I7 Kr*Z[l^~}{Ժ֒ET$tߡv)\+=y<v^;aj	]sC3ҵh	TPef?CAaː,óR/?6
ՓN	q?~o0j*G?|*C3Aߍq4QyEw_Za#}݀A3'T@d=_q2_P|ґ;B x
ב9/Wy
c; lAr""ZY!.@NDM{
X'lܣ;az+r-1Y^~XPFr`ihϢ(*J1i&24<Mr
0:W |kYPD:xppJJ2P{.v>Kcc;V<r#}RodA""sȭ<Yv	?v`pqGlS1,0!~W
f@'9׌mAjX`8?i)t2""F""&&ϱcV#Ol-d-D^)%ۅMJ\""SC}N{/5`<3|т+PG+l8yତ2sQPHG?4AtU+p)R>L{3=kvyn(9G*ef}uSe軐S$HWJvH>$=flx]+@Ouf6ϐ^@7L^G7Y3uLCR߁c!s)e(R`S2XL_JL
$U !H}{EX;_Xd&lD9On
((_""HAqNl244\VuIQlH-<EC[1PP~D벵:qqQ*oPx8v73̬62,Q>8\d'5X9jAdrܠ
taFVM6}=3NDdњl;$?bV2@衻ݧV},P6@=  Bdsfv\
Liqi+!l}	 3T+̀)bb&ݶ:ef{ibfفf6pdN+W!i-bwN
%t+RxME;2ɭ>A[^G`\@H|FOd
ʏ""U18;0 ]Ua)@VGs4MiUBB pl%HzEsTF!9ݗGQ""!(a[C 'sǾ""%bxpWw_nf[#g̓;mA3i-ۃW39pk;71M'14ϱh9[Hw_F<0
[x'p+3O{sEQ0ݣ_zTy,C!(%~7/x/
Nm`f܄oz_D׏)T$C	鲢pQ2yoTx$ߠc&!5+/ ˎ'!iCb7^<F?t	*~\{Y2-znAIWs|ucG4V̮ҴR0
&Hcx|%*
ߙɶƾ_JprideBHέУ{0@TfH{?eQv([^G:2̅CPnHJCʟ}Bfy3=%%V8w?ݟ)wcfw""]
`_[أ¾BB0c5tJ5e-r TvTvءYi(g@qYMw ضP PI1/cďLQ<;hn*wYMC/vJ8&Ihj/۞6^4W?ef7""I~ p#Ra*%OOWP˜݁<~qDDdHTH:Or}HdϾ;,7֧:tA
!:61MMTnJZgUݣQ`oPu""W>TABD0uP>*#LI4[9F>
2GNBȪbhVsјZ)`~ujkLgb>R=-j
ᜉ #}V;@""̞E1{Q뮛
m453''Q1+PM #63C]l}3[̚,帤=*TZ+5QC^2lQ(|5Bd9I%ww&kU`8J9no3ofdsd^-@7@EvH=cmqlYAڛ
TFPueMw*""!$O 'YqۇqCqBB T 	( BJL8Hl
 [ˡ/
tmmP3j=5QM=f}? QM6	ۇкfU-oVz3OY$݁)zW(jqQ:1fef߅kq 1z3Bt$e$@BUvҦGCP""ԕ70̢B/3)YA""9
Y<^CywG')f6@טYo5
rwB폑	'HhPH'fZ#ekZ+a-f611lA{OĴ!

Qt O]QC
KGGVPF얤$Bsኰ3KT+bwKY/3;?p՝pSf3+Wo,e!lu𓰭vsdeGPf=
0ZUC*PGCx<JeCs횰NJiTW#'H\-Iƀl Gp}PHGTd5?ÁH,@v]TQ|(`)~d^l}o`J-0̡함SgOTZ3H <Jf=a};8	s\q\0<_\CP7_~aUjpގܛ^f`piR:0w`loJA5'$n?dqX\#S\|ÓB{{ .m;2Ds$6%*0(}S
N
#2}^trXY1g #QHEKDM3RGCGXdf(mG{:J?hrx %t 9UFQ5\q|Ƣ]7Z%4(@).wi0Bx(}U?mE\Oz)ߵ+бoA96b(ƣ,jfvncQdg<QXGn##ԮvVkl{d8	٦NZz
xѯ΂꼇u11 Y*ZUZ[?#ޝ(<	NգrZspDqBY}0K|Pl=	rE:QZCTtCDc7hs$(SƎ] '<hiSPTA%≯gh֭~T~Ơt)
ׄv6Q3{oB<4a+TM-P2E_CN7NܑfVѢRo""xi0Ryo3Cn:gM}<R~VG_~v&s^)=,7gG;@D{u$F	YPr{hJp߱MU;MoE.vcaȱ=n^XP

h!2г(Oi:%bX_W`ȔwO>/vöx-gC{iM*{K#%)}2-ԕhnhwX?hfڂL~sKjCnT!joFߨ2\)I'90tD3*}C_Gg|P
߫kY֙35F|5kP992#wP,j|8ʇܩkhk9A_/kSv$l ʢqIi4<e\ c~a|)KdafQRAW9@fwKP2!Tk.^G5Q/A-~J~Bo5WGc(;
@%҉
}Co9gFp-|+qT$.M7焛RJ9GAr,ds>28I>(G߬:
w%(r0ߠç[̶d0^6
W+*HPj,%_Gf%{}
*s:Q3}<l4}9L/ҽ(29ܻQbߣǝqoְR""cc~ x/%~7ID/N(X}
jKY9Rp6e. 4қІ,f/'lL2}j|w BW?~afy䁎|Z/RmSi-EgRYBN*GmKm\jƔTPʱkk>)}JR5JZ-c聴qHL""KMhijh(ds
[2Ia	ZE35""rCU
t&:Ai"")yfض1eP\`RU%k8͡lr`7`rZTKӉ1JZl۬ e""PMzVWĬ20X;{6yPՓ&7Sʴ_Bxjvchg}u>u^Gco`vEbǧPЂimVl>}cTFT(>nuI=y|gGJi_+%:nZ2:X[6Ʈ(cĥaۙ`舖hmׂLv7g18oy=[ľ)n]1*wsT	l(?u
=""«Qx}P{Ysҩ!b?mlӐ
}E=k\J\s`F5ױ*GCdsc""PʋT!wx\jߎW!=j1J]uAQƶ
:EiUC;*2OGn
Q /(%̯p
M3Z}v:,d6.?9<hp~~
@,bXG!zOp܋|öjomR~kөxr$
CO.{EVmW!YGEۛQ%̪	/by(\Pn Mل ǶoEy^DR6,Ti9J:!l?:Qݏ(jTzvND7z -@\RZϥDR=vк޷2Qz՜ gpˑS}MGPnf}7f bF9/>㘅&ϡB%,?8""cߊW7.I,hfP&ĶEEdZ?jd/ߑ1bJ-hrkSH)UllHcFK+ˊZtP+jd׵.Z7&uj 푮Ob!}RaQ""S=CƼB4ٜ;""JRPc	C5ۍlJ`PZR۔J9JvvfTGSr<I7	JWb'E]k;֪O\zzcpSkQ9tSк*t&rW9]$ں2{k_	do""j	j kq'>|R<I|ՄdARKV&$~Dv:phAw{L""M,O\C$cH_`6Zk=d<
rV8-fi:4Rj0mЍԏgc,Bv臑Kh̆PhDͣ<j
DᲷz:l,݉lJ8qc:qX9nzТ}B{#HYα\6dvs;}P~EjnJ.o(;M՘݋쟅lL.GkucP4Z_Oi*Q/'y*lh4sO=9`?pYeJ1J)a-J汤W39é<ϼGmܴ,ZinAjD\fk>C-t@Hf^@ΐ9Ƀ)5JQ=:zVr,E(*c~vSdI 9hf_EyIJ2p5_  6IDAT(eDUXZмfuIRa5h'
7'+@IEfW(cspB5dk~~:u
\+}ݻ:+lGHv4$(aTvThEۗ;l~Y6F""[dw\fΣ5d64PM`G6Ño_@
tDunNk2G&H'x:m̛ G;PZ1ivtTLvB:{6ٵ$gnь	=-Y>&43ynZrd!h!Bk(9NTR2E-Ao][rGXBېiI(^\VU'qM(tHp;Q*	6yG7>*0Z=kCO
&}US}8UJ9vuiJ>zȾ2vʙZ w|k}pFd6cV޺CQݎwXM&X?>t6{D%""kOz""Hʝژ2UH(f#$= >jf{Z肆3Y{ R1V!)F(FzDYP/R~45ly-o:
0SqoS`cmCe+]cAˏ#?FrdmnFTq1nٿ8y*<UɔBU?R""YcNJ[5>tG(F֕H%*RfH*7Vf8Y""jfE,Ge8Zwn
&+7S@Fp!S(ŐxB\r5:qbhEH]J%pJ6!JeH7|_ʱ3nJx~Iy|oPG4WXC:j4Z	|L	Ii=AyXtנ	j%izu/Wu(J/P)ffYOF:H
(x,3#$|9gAI6Fܓi7CW9n:ROlg#U(+iw%~Pj#/<4ݗǎ1G$iNCza)Pf""0+#]'l{Ti<|ˑc2rLFq32F#4x""_p9 CMA.gZlFk&T5_hk>h>27nߑז#&%f>p𨻿PO'C猠w(Yw6%枞|Í	Nd{
t[fЃ<|.CP""B&܂JG!;s""sj""
$FЖA2/sPԑ(,&B֘X,V U	b8
n0o\ia3@6楱ϥmː1*4a	Jz9^`n2i=$+1~""vD;s.??m@Y:_C    IENDB`","Binary files /dev/null and b/docs/_static/flask.png differ
",add missing tags to the diff output,add missing tags to the diff output,add missing tags to the diff output,llm_rectified,0.0,7,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",logo-full.png,,"PNG

   
IHDR        >j9   sBIT|d   	pHYs  
A  
AC   tEXtSoftware www.inkscape.org<    IDATxu$g%HEwH	,Hp	`5[laqݗ,,+fsnOTUWUWWթ:uܝ""af  wCB+QD=N~~ ^6,D%JXQ;$3p
p*x ݿ+%J(cPipo2,%J(CЧ>
W_@pM	L,V`%Jt\fS>)`f Gnvqo[bQ$nq)5)D6[oo_J$a6tD絥R-Ba,;w8xJ1EYD`f˛

(kOJ$fv:':sZ lr4@筒)w_Kb@X`F5K +p(0C]R.Bb=;JtEWDWf4SM$RDUN~?u-
%H ""<HJfVx%J
 l֪DOMmf6Nhaڂw8:%p܊rK(
f]!$H%̖6s3sf1ZE}'Yu65V	-$3[X""q}ݲS-djVG$
j7l3[8Xɬz%)L&łGf
+
ٻ~M+8̦GD?	7o/)G`Ůj'xݫ57l-,DRTٞHT\L6	
~D4X
(	Rstb`ᚻ*>1
8b;)0)C(!Ղ\2TJ	VH븚3nGeH<lv`/	R44ORCUþ~T'F 6[IAd=vץ Hϻ;+1	ݿ ,*˂6( Np`""
3vT""#uR@.Qdx%ߊfv@ʮu/4M쯈V++4lFWBp}`0tb&H ~%2a*	RpB oG=e״ 3{\I\6֧<ĈEm'潀fnnF!)ɀýz!FM{SO3{N/@*y](B ]\cf.4w~w/En' '_
fsP`:f@B/Fִ
f|P?Im)d9/wH%2LmQچB@#Fx	8+g~ݽ	ف[ըS
fp)isl|x0$cg.EաĤ2:Ȃgķ()r?+2,84ga)
'јEW.kwM:2t]pI]Vե]( V'Sd4pO1=:8̖I9[s$}pa19-!JΑdٕhwH""H˧CgCk!#?I""[Ðə 3*.~fn""I	YpvIHIJ4Nhzi3teQ|)fvgAVA6	aw5^$w LR[p/R[C9̊ hc/ź|I
BI,L9Q1\o[)*Ӑ=,~kf%bp1fF""I|ݢ>ɑ$H%La]itjr#ː""Y]$m_
=bd+""6p!DWᫌ&3$3̶5;S<qD7fr}w?&O>!v7Xy}f֌<nñ)Q%A*1UnL,;3Bmtxt|2""V [s*fd]>z&UHo\gӖh/&YkuwHfv*KVG恞E;Ot=af7óK g9;0FaG	iAv;*BO#oYYQ%j=!397D,D&_SNo`pHE'f[3{m""߳R]-Z%v 	U^2kQFf>
fڍ7Qqn:휻@""o!ӂ}S!x$':}~DLvN,3K=
S
<ww*p]zDQ[z)M
$n>2'*D7ͻG_!ÂN0 ~[R=;	>>~!4D.qVqE]z,v	>vB!Ȕ{lmf::ݫ_29ED/,clfu3֧Ĥ 
~V f6X|8`ZG>Dv6Xw48pm
9+ѣQ
5
L:)8(-\r#%""@]ǡqf67""  C/G{> 7of;BY+ff y~<JDDg+93[	8sHq`ob4M#Iқ.#
#kf+#Q34X'(ѳ&%vHf7rm]Ġ<<<
<=p
38	d\4G#E$E2[skr0 ~ց ?Fz0Y~1M/$X_ x6{Ӯ!ر[ \""[U}E鍑kǢ!QH`3;'d/1iM%%z\? .4GvO	B HuSdhw?iٷ6ޚ IqrSBٞ&@2> C;6J]I2w%IEn8ﱠÑkiޙ
Խ*\X!q-jKW/ϰ{$\قȔnb%D&=E;3N^@Fg@_Y,5[&'g3[ݽOfY/D""A40Y>EE3NTA/*nTI=n(Q+FFOx8)aO[ 73bLAgL}̇,:OT$M!pf5%3)`φ\֠^Z;P] ?q
tB/3""s;ŐQԓz9w#sEdd'ٴvșޢ4Ƌx ߎ?Cl_hf[!{NqEnyGٮhGxYR_0
ФE-af[GD)5z)&fv1#?GS577zcChwn;>0MQ(Jtz$A2}|&NB;`Mw6p`ZA&W\88~ifgms	q
<0MQVXjĀ7Q(Cp~*3o%Q~$""v(F2!<3r2:ݟ͙_t&ཛྷϖhVK	{""24e\NǄLrV$;]O >FRL҉%jGo-C#ݷ_vRw_ZfBΝR$
^RJ4b]u46ƚٻt[&tkA`H0ji4sH:
{VֹL,  [8r3OOՒ
תd7＊Ʉ):?jqT̦FHӂNJ;uEDj`""|tP8,!m#YT7%΃O[9bgfv~|dI=Rq?ȳQ:y'?ܝnޔti낔/>Q9E\#녲,B
WEXJyGt66紻)u_~;׺.cW
|Zpo%X|%g՘o[y~PY}2||v8ofv27i}Szc
/ڛ:꘦SU=ؤJxɲ	3̶7ǐ?YXL8'g.Tfv`;y\
<SfCꢗ^IȢAb ]]<9ߑp~LJafӠ,Yvv
`3CKCɲZ4fv
!pYs3[etle=t1v``Y&CKH\ĞoD,j2s'"")?
 1fv""SR7rM+j!e)l}l:Z3jp]t&bdcpMG4\}L8q""lIqg/^KjPbc8pUyԕ7h
u4GB 
~]
ԫ!u	)濝]c&˙#Eg9sGr SfSr-2#QɧO<>XP`<6+Rwrv\}BeE]\MЪ?kή_op!wzwu F/e,0Y Rid|~
\z,dwEf1Y?e}F[	G|OCn;#SCQeѭu^R%,;3cfW  7(Y&2U>ݏE;oRBsz7 ;xi""r$,'~<~D6?sm_~
n""H.+$T.W%fmfWzWk*SE1 (]utZg`_MZ̦ˑYބ>QG\
g
CZwCYz<vC ũ8vpM^3
QC]#UM@~Q<Pwݿp;(	RwG΁6z8H)=+˙^lQ'kfq	/ɖk 3iwaQ8:$wMyu2gQC,n;3&	4IDD%d\pۑoQbI%mv
^yM:AI:c@^xe)V%/sFG8&͍Tm橑}`w__oZHt%S Hl
ý:<d,= jpMNݿ0lwuw9%8DpQ""xWq5bU01+OUpݹ	h>v4'V(톒y2)@[WtTU6pJ[ɐَGі*VZ=
ff+/2>ZC>|'_p}Rg9>݇5ZP%}1y+9
eH3CpS\>6n&hL{UhH1z	ؕ7 =FKhEc*憪Yo7^5[
HgQ,R'>""9Rb'+
HHw""L~@U5c
.8p6b3dLʁF
qs|3kR,z13ɠW#SOU%c}FPo%K^)*!%#gՈ#Sv~j)GvTp[Q턙MBuR(΅GʂU񽁝ٓ7!f:t-=cl&$(	Rnf#}$Jw?""9	<mI)n/pYf[,1oHv6[;߱A@$y=V@]DwoFc$H>̞""Ąj  E͘;7mj߽JpUFQm@<z0GⷦƆb'""Nw_
	Hlaf{70BOC^RRjVagx̶bmz""C~ff;MCoEw FP X]vI!iLl3R1	)XqjSQ%:S-	RvW Ds=̂l۽jf;`VtdM.V]Z1ܓ馅Aֳ.t=U (V1ىHWH3;5ZٴYg|>M[} $J4`I5C̬	,P`:v""H$D˓&H1'?7Gxb {;:	1ZάWC0 [ /IgՁ.)V03P|N1T$:33[9y'LJ5Z%:YnH:Iaf$35YWӳOFDhhbr;wsWw{!o
TLB}#
=#d?7GM3h.O0f̶AU
WP3bKPujjܠX$0Àl-3̎0y|=˝X|i}l@.""K{3@!VuGE)#̲-]N̖4hp!<h-Po%wH[Y""if7""t9Y
q+4,JA4] ,2/>\W
[+F*3[[ǐ[fAmU#HsjT:HRZtva%Ύ+\\$:mGl@B<rc%&	LT)Mt3{) K60{!K#z3DdN;=ԛ}:ȃ}ww?]^|DOYD0Axn p~JfǠp/	R""Э	hfif<Ie-\R-w,
Cgϙ-ȿ;a/3[ݕI}qt ڡbDw{luw0(^w4]ͷ[:ZiMbQDXVb$H%@j0)l Q6""	hX!MDUM`""3.dꉈm	HAv4]:@}hP,fmefUyZ-+~,""%A*QV6^
h!8_젹T<Aw&hKi""K"",Lb
`
@L9Rzy}x$M
t[9;Vw?xf͠m}(5WvTu0cY2'	M[g?""L't̚em#3@w*gkNW0^BE8	qCCxk4m""ba^̞xf^k$-X+DܔT1樗oOЙ]onwFY6ԭ/:(G=#W3G!E)jS<lwJ{fx׻kQEGҐWܜy~َUwz;
}M5XɁ켘T;TVVgOΤA=dR5    IDATjZ)?7RNCgM]Х;$3-b?NXp-B~vgNwrπE) TP^*`=~7?3˫4
#l(,w_aTX}C:ud:Y ΍|24ֱ%A*,ofT$aŕ']g%2tK1we%:c*Baw3kѮj	\7'uМۥ:p!C+15{o#l.w  ##߂7)E&VΨQ~Z{:T4KTY|ZD L`.wGt-duҭvHIǮ39јo-""LXH՞Ay<lΙfScjRر<D^0jXU}~H$!x	s^sOJp0cl*~
[1b.ɼHPY kwьW-wu(Gv_7:U1ֽYq-󙆑Cbjwz
X?co !S:
i9)ea_Dܭf+H,Df2\o$;f uK]5.t\˶эgyخ>
I]aM\iyձsːzX <̢Uݯ7h2Wl%6:_Vp8ݓؖ`nn*DG+wH+gL{eG퐒hg'ًL,o˲9[r	Kw'nluWwyjQܗo$Z:4X+
IEf:l3BzDSN~$Nwt}zy(Q-jROxH=r'%.]^cw Fg k-ɛye-""jpFA|$#29Mc?~}/w*nҌ2kBp	Ҕ@BvHFfl[w۶C2fv}-NA
ے#r!""pOzLb
:
,f$A_o`SZ<wr`ngH@+`pMAhAZ)Gw
.;\
`d
gp?vBpIZ>簑8Gw0)3rLFߛٌH:\B}[d>AȓT~EZF""&8dME	ТWz,Hcڵַüuag5͹8ŞfvTVE#5ζ
88tn6$rQ0RG""o
Gm7쒂rqke`JY2,kg%HX͗v-҂hA!Gچ	R`l
TUC̬Me:6%H]3գ?f65m> u)!]XfLڜFHL7O4O)
il)	V}f6fbI~BS+kfyl.?p7׬8f
+%rbCBwwguWw3
EFoyW^Kϩ09pdfY/ $Ձg^dQ<)H3|_\4lfQt
ĒI9%$mC ph8%^&hdEˊjC ES~se<nfσ
f;3;7JcpE)T(^""Eyb[DcP8̎2ݩ7j&Ih82;fEÎJď@*
?mPU]Q^;/Dfзv/g|Vpl;@Y(3Bl!
l3Яo|rv|UPSsFMա/*=2ͳs&甈M@45~""EvXKFQGLO^AphOoF`>7XN?""?2f|-d|
sy5MLZ~6'lyCȄZtp4пBȈg+?XJ~A@E6Ҟ{rja;]MHasvO&]
Mer0RB?>l_s
##@Oyy)b_pFk-!Ad&H_lS`e[@C0[,IlF K{
fn/ns{0fv5j}F""FzEid.pdm͋RċhyxlNK6K1L(w_$6e9sV#Hk5vOIg=lMvO;
*eh-k6FEIӾzo씪 j86BB
y)o52I85މʪrVUYRǫkN!ərr%2۪v y[cM@luѤ}c.k)(]P科Bv?ZS4z!rTĶsBbkѹKHV/2C4MY
R=I6.[뺮mNkClm>߄vX Qn_g
7]D]ߣyY~-+hGD[:I>BgFcI\MmB3),$~G'_""V_rB:YۣN[-ݦAR*45ʝQgS}R chr~<WXQ
N(Nz{ʎAeDY'ҽt>Ϯx%.+;ߋP{ݾ]e'vGjk&sd%Ѳ	,ɐZ>	lF;D-^VW /Zڦ~vf	Y'IiJ!3{9[)$cc=؛3˩ :{u5afs{fϘ
f6#(jx(4L)AQ<p^4$?9RPp'B&]WG܁瀳\</""耾PcH>o`VwAU)4wYn9ٲAZMy0YiyEZH Q?sԆ_'R[	WĽ_ /{^kQFt6p4	W^ũjim$}2c?E{CVp`n$Mv :e),h:?\=fַYB{< -sgV""_Sk*gk.+-k`|wk4قh^/ľA11""Fbty;GZZw4˃fsFbND%E2GR=WL䟃X
qY0YDԺf(QD|(t`f!}K[C;AJ""ϙB,Hlw^, 1R,(QD
&s߱QL{]-߼;Of6hf7ET{D%JGGn*gG!a½.""=5:ݯ'W>I<H6b""kYpm"";7kֿD%JtD;$ 3)MLif[zx	qT)gad![e<(2<hhvk)h~ ܌̨ovKa7SG%zlnwe@pf6/Rqw3۳JQ_!$z#VNH/d_w""kDCG E[[`f.ȲE%J464'B*=y{y$EldO""㬵cBʃ;2EzFvj`kw!Tʚݿ
gWg 5Fm.CPfA%JHj^TL%
ψ%[i+Z#.蝔*s-b;-}'tum36XBи,D	 3ofWٓy!1 ڥR*>'Bl!RlCVPe̬H}Íf6EEG w Pϒ%`}[Xu)}$(k+TC
?6~/ܝ![y3;WjfK/}Q(O>βDV1$,t2\bvWwv_~Ϙ4~e`=3[!%w9(2ot&pK07d ~5""/]=$pVZ>ݗuM
F?y6s]WWMdgSqA{3r_2""́U*D^<bfIupϑc G
ԡQDdٕ(f2@*1isL6a]';aQ3̖O=rxoU\>/WG,GuR""
[@f6{mE-ٌ=C_L_nVHb""ͿPd;-!9go,{q.hCy"",rq)MZƳ7!1F_?G+/C
SXUJ/>$yU26*iiN""SX>!p o VI7p?R>XJ9˓s%OBـ#vY]hB{^""f0:aI8o'֞ȺI'kHt&|5;!`#wS< 3
>
}xd<`Olc~s2Q`Ot7,[v,)CKB^eM'H'H{¶	}ЏO}tG/_tt2|h	J'})VC4F`ސןq$
_Z>#HbX}M%ҵrdϯPo)G:
ρ#6)Ԟ S|cmvm"" DF||ߏi,%>ŝR!ۄ52vP+?s#B!B0v;=qqC!8fI	FlwW'Pm ,s53 ce-J^Fqb3XW>0k""b=sD""r#m|ao?3B!~,1Y""zȒ#H}%[R-xp\?{f۔gfCshqw""Q?8AŧnFb|""3[Hw=A`&w)A
Z4 O3},4̀(y2	`PwG)ǻI	?-nL<5Drg
'% Lu>!GmKV(sX!-iW2'}h@
M1>!7Ϧ͉HgL<<m[ŽiR]
Cܴh=;0Qf6&mtxF[MlǠ3ީC\hE='Fhј9Ov_[J,|~Y""s!ca熰g
Dx=2ye""ʼ
ǧQuc}C,h<7Eߤ_=|¦GD҉-6C\Wֆ,618>A۫?VJDj r-s Ccmv6qyJ4
#ֱJep,: 0G""줐ǎ)/L1wFKB$&D-Z	;`vCxzJB'}g:Ł+R⦤B6	q:unDGB~)q{/|S94;.73c[k?LEN:yER6ȬQ<=^D)<3'5N .F٨?>KG""zvĽiax 0
</^E[m1OG<P/J
[gf~K̦vѪl3[<S]v灟9->3}^""qB{4օGl ڕ:a{jĝ
lf'
l73=;E=tYh
^5YI
p7ݿw{wv:`w3UG
x&'TrK@d5 .Kf]X![+Qbw-$ oٟ,xẗ́H׵gR⮏/d O"" qr
rĖqn
+
KEkbfv67 @\L)3zY?v8b7 '}K~V4I&CΨQ]y+\kt}.$, F+}5w?ѥ!V;`f>)DM\s8;7<~6hҺWrc=Ucw<qGu35V!B po͊/e2 
AýA<O~-$pg vyΎXmϘ٢y*lfӛ6fv""Fb*mX>5U,,njDD}joH1km#H>
I~V!tY&EXQҌ5LHDhD4ksVa{ BG(v`Â8m蝸'1}h[po岂^mG)`16
E]}+i&
9%JXA}U`KӚ8.(A:2SuKbwo?vD敏,ZMgW=g9-TLdSfLOQzǻhn8GL0c8?iywHCe,DQz6FP6Ch̦NIyDp$帗ߓԩUemo4^gWA8M#!Q~4*cgt6&ԛ=fRw XuQ#Ou}5&Nzht}($w]x6ZY
M``s$Xei+h7S0lpݯ@+/DBcD#_]JXuwM#!n$;T1MY_U*<7d-y	R'7V?w|3	yo?#5__7.u*eZ܃8D,`xx? .ҢH2I3""hT#̬w*C尫-uXXĊ'İZ<WB쨯#3$/P%~XYQC gY&""3ƞ:6$u,(>Hzy u}bbHʑ8g$6QKЂ#~X}XJ$bEϬv$픐~H,l%*^7

BwډvXҡNGRhN:{+RH9Al/BZCB/~4@JaiH@#ݑW!ix2-g
aqJ$yj7<-fG^GqDx`DN!.)57	xGB2WSDRca*fXC;{!H xt(@N=`yOѮ)mDg@3-G&r+GR$  IDATQ0;
GՙkEAoU5Q=	haʷ%fC;ϩL_tQ#:JF']_A:Lͫd`6cOC+h7;[qam
A!v$РI@_&CJӯ9<Vǧ$Z$*=y9y
wF bJu Mi?MQy:ͧ(>)Y0EBLQ81үǇP,~):f}!b Q9q|
oߑ5}?*RC[/uX/c~G""·P_sR~>P<	ahƇ:Hc:I&%!nJ*9*gt 駈ǨЎ A_^2CD>
ˣV-~'S?UKF+琰THB?F279m	HԶ)fnB+CýC:\	w<ƨ~Mdaԩ!>DAhEP<s ھqWBbhr4>f$.sÇ;͊ا^_f>Kį6].iFрx;yJ6rudf!"":p39lYw{$y
kfMxoM@w(""=h
<O{eoGG,E73"" F.l<D/a\npB˒pDtC%P<%>-<tvl`+¨÷7yQyct
lû~=g{L`dz
4:mXϡynC l'yX%ΈXRY0,4""6ScZ<M`a.O?C^s""XG5%moz#<[486qSD1oomA0nFdNbBXBEhL@:""b\gG|bfC3BhuXD UGw;blHC۪(_#{fDXWa;;](4H(QDOE#H.MnfvP݇ fT׽YC(oxg:""D8XIlbmD=UO
v	 AEV:ɯ"" 3#j.Ǣp&N*oF~'CՐtPu"" ,
f6mT%JA*t;ngHqنHC(v^GbK $m԰:riܗ35295e-u$5qKJFEH)S@ϫ#SUNYy!m5'T,QB7>0)%Tto.'~
{Grh*.qk/>)q^vmR R
qb~&)2=g|U(5\_ ]qHbH@~DbڏƞML3}pzU%{IqW^m돃J/vq G'VȾ,
B.@Z]h>Iɴ&;֧Q0`6&Oa	H jR!sw=
-鸣_Ǔs僌DQ;/!s]\nPiwӂl.SyM$NҮn}D0'H<_i	Қ^I%8@Bedd ?iR#ݪFeh|nz,w+tRoGl5}X2%s=jDE@v
Юa@pj|L<1x~W`w-0-خqoZtCZ`f_l^ŤQ]3s	~#<;4{!y;02>Cg
\?4 b64}S9xoޮ
1/^/}W~@6fu*>aM''&%HRGwY8./4'Sq]h%EH)
V/b+.o6M \nG 1ȇsfChGpfUc=Ytt[}&*Cȗ#]ruT]nGyxY٭\',""è$ݻiA4
o{cs3<aDܧ+r 9ZwGl/vG;y<:<݃n#$5ZDBgC  >Y-SKI֮z
e^&B;_$DF*cd^Ul[G4wٯB_sj(by/!x'ҭӡowӧ{ae:Oъh^8?vfoV7=cymB}hs""+磻].L͇ܦ|<;-r9|AOithvKb$1khFĿM cy
+H|R27+ !Zu9e/zSF\X~bDC~zbUMGI/Ego7z tpry1<8\-7I٘X}BR-$""<' )&-nO#HFCzTHݏ_\1wJYs#b2p""ǣ{&X>`JY!=B?ChHwkd8sQW0*O> ""	zG*1u^#7OX{6R^g\=kwFD=""H/FgHqu|AZύ&àvĳŧ:}ӁCc'zuoD~I""|)KJGs9cxh3>
!8)yfg!hcM{/ߙ
tAvutX\Ovy8znX:9f**0[DTQpxSh	1tSxvbCW:Z}+""#C	hBVoumWT_rnj,50@k.%nVJ\*yGDb*$қ[%>byj?\\dD\=;dbqtRBbe,UO""|thM37p}""r1_"";5FžWH-?3\.ᑞ])CQWNĭ¿R蹹S""&JZpPԈaZ6멸_
W31lZ/p4	Vɳ1
m/ ^7afK2@
ړx
쪛a|1r_r׷s;}d*yWM"".f݌< 5yF.ѹфDm]sÖ^{|½fQ{V5e

m3}	a&J].EcpO#үpU=UR¢<'%Dw̖C4ɣP#.L.j<%P]27GXhf+yfDֿOFC
[gzdiO;NDf|VlDf6
7f0E?\n`f+!~u$vN֫cV6 pU\7g^mat""<0G{h'w@͐~hҿ̆;
DDܓ	,Up}չՅr""Rbٛ?3Fأi
_zr4Gq>2	+!V-NGӻRwݷC~E}oDLH3<QDZO0h9hWĎ<)+3{o'a61Nmt9bf[
f6Kgڄq@Jh2Z4zciw?	bG߇H)K""^{Ebq?>>	bT
R;X2/""4p!hd0ㇺ Ei-U0یlj5B!632kݑ$f8d\ȏ.|~{;{>y甩owɐRBl~=df'<EU:""z!,FވIڈ4eнfvOG!󡅾m@4Rd3ʻe`fr>z/GJM}+֛٫f: ]bf3	̬}1n63nfW@3jf#*3dfS&nwq#RB#3vĻRrO;@2Xt]>6kݑ+O6g 6[6Cfj""q6:,67¿_*S-ۚgUt6fβ}vUHFHݽ\
PZMIXL	KN83J)v}E4 3dp?hw>̳htJJF=F؉
)򽭠omwXʜ)j~QmFe\c`K'JNs{kR>
>J5!sO}$RzWl;whS}{ޫѱ~XOrWA(Qۋ(Pףx)C
,p\C-ep7PHܱQ+{""C?F}R,&V<zF*""P{p`kϗC&<=H}) XoD'*τ'00)wCCHL|9/B14Kqd#VPTd3 EE6kN=N1=?.Ǒt3kzt<~""z|U86.z=SBJRvbV٤qmY+VYwGQOqLjszt}DmVH.ETg߈CeUt>x$gOc,jJ4V""+D	cڱRTGu WFGDM-""#ſ]X둩轩.-?QHLQ{|eE1`͜ͳDBY\!]>SC[`fwm"".EHP݅|LK = ::/Ugf̲Q0bGd؆tݥ.bb]MSVO
jZ4AC6$	rT׆&!?hHd[Bup3""OɩAw?jf	#ҴD:b!3)GC*7p
hb?4CiỬ4k-~Iiz~Cq7N2 N#{)խ4MACʥ_jd=E~f!{VP=ۢ~Jw/S
hGe4<Z""3Haߓtt9Dk3tum>λ sU!?i7$KC+h%{Ww}f6I.ʶZ Y_o7ȧtSw_kfhR}b^kΆ%ހL 3f
d
[Z|o5hZ@/FVN 3~""!
E4V`zQTݯhk&$>H@@~REU'3E'ejiߡ`n@y&Q^\GD|^IنlWf+M['D(	E5n$j)
K%TZ^o
R68~9R|kRae4s'M""n-he,Łm퉧Y18f5٧?اwGЖV			̦""sJwL4}ֶZI FNC	""qd&[5r.2)+6PhyA(""$(]ow""x?p.sd3*=|k8jRNʙQ9F!^7Mo9_@gQ\kf6(ƷCOnaڹn=אr3s>VHp""~F~ނP%R`f)ȿ}pA\A©h>h	gvaafӀH!LpZ#	 0O#-a
bA
9݇3ex(#G=v	辈q#b~̤>JHH@Yz@jG$&P&Dq5;o=Zfj8b\hbC,}6̺(MRB^O4+MsЅR!ώ
 Bj'J
~נ_).'\T@B0N?kkqE?nm&섄sI u""BaTVFRz?TBI=[<>@;^TAۃQLBYiCȾ\̗kJHHhI 620|q,x=ZY9^s=2eh0-Y5\`Bٝ{-TτH!p.DWJh8SeBgob%$$t4
Yu{    IENDB`","Binary files /dev/null and b/docs/_static/logo-full.png differ
",add missing tags to the diff output,add missing tags to the diff output,add missing tags to the diff output,llm_rectified,0.0,7,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",sidebarintro.html,,"<h3>About Flask</h3>
<p>
  Flask is a micro webdevelopment framework for Python.  You are currently
  looking at the documentation of the development version.  Things are
  not stable yet, but if you have some feedback,
  <a href=""mailto:armin.ronacher@active-4.com"">let me know</a>.
</p>
","@@ -0,0 +1,7 @@
+<h3>About Flask</h3>
+<p>
+  Flask is a micro webdevelopment framework for Python.  You are currently
+  looking at the documentation of the development version.  Things are
+  not stable yet, but if you have some feedback,
+  <a href=""mailto:armin.ronacher@active-4.com"">let me know</a>.
+</p>
",add missing tags to missing-config.rb,add missing tags to missing-config.rb,add missing tags to missing-config.rb,llm_rectified,0.0,5,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",sidebarlogo.html,,"<p class=""logo""><a href=""{{ pathto(master_doc) }}"">
  <img class=""logo"" src=""{{ pathto('_static/flask.png', 1) }}"" alt=""Logo""/>
</a></p>
","@@ -0,0 +1,3 @@
+<p class=""logo""><a href=""{{ pathto(master_doc) }}"">
+  <img class=""logo"" src=""{{ pathto('_static/flask.png', 1) }}"" alt=""Logo""/>
+</a></p>
",add missing logo,add missing logo,add missing logo,llm_rectified,0.0,3,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",flasky.css_t,,"/*
 * flasky.css_t
 * ~~~~~~~~~~~~
 *
 * Sphinx stylesheet -- flasky theme based on nature theme.
 *
 * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 *
 */
 
@import url(""basic.css"");
 
/* -- page layout ----------------------------------------------------------- */
 
body {
    font-family: 'Georgia', serif;
    font-size: 100%;
    background-color: #111;
    color: #555;
    margin: 0;
    padding: 0;
}

div.documentwrapper {
    float: left;
    width: 100%;
}

div.bodywrapper {
    margin: 0 0 0 230px;
}

hr {
    border: 1px solid #B1B4B6;
}
 
div.document {
    background-color: #eee;
}
 
div.body {
    background-color: #ffffff;
    color: #3E4349;
    padding: 0 30px 30px 30px;
    font-size: 0.9em;
}
 
div.footer {
    color: #555;
    width: 100%;
    padding: 13px 0;
    text-align: center;
    font-size: 75%;
}
 
div.footer a {
    color: #444;
    text-decoration: underline;
}
 
div.related {
    background-color: #774117;
    line-height: 32px;
    color: #fff;
    text-shadow: 0px 1px 0 #444;
    font-size: 0.9em;
}
 
div.related a {
    color: #E9D1C1;
}
 
div.sphinxsidebar {
    font-size: 0.75em;
    line-height: 1.5em;
}

div.sphinxsidebarwrapper {
    padding: 20px 0 20px 0;
}

div.sphinxsidebarwrapper p.logo {
    padding: 0 0 10px 0;
    margin: 0;
    text-align: center;
}
 
div.sphinxsidebar h3,
div.sphinxsidebar h4 {
    font-family: 'Georgia', serif;
    color: #222;
    font-size: 1.2em;
    font-weight: normal;
    margin: 0;
    padding: 5px 10px;
    background-color: #ddd;
    text-shadow: 1px 1px 0 white
}

div.sphinxsidebar h4{
    font-size: 1.1em;
}
 
div.sphinxsidebar h3 a {
    color: #444;
}
 
 
div.sphinxsidebar p {
    color: #555;
    padding: 5px 20px;
}
 
div.sphinxsidebar p.topless {
}
 
div.sphinxsidebar ul {
    margin: 10px 20px;
    padding: 0;
    color: #000;
}
 
div.sphinxsidebar a {
    color: #444;
}
 
div.sphinxsidebar input {
    border: 1px solid #ccc;
    font-family: 'Georgia', serif;
    font-size: 1em;
}

div.sphinxsidebar input[type=text]{
    margin-left: 20px;
}
 
/* -- body styles ----------------------------------------------------------- */
 
a {
    color: #003B55;
    text-decoration: none;
}
 
a:hover {
    color: #6D4100;
    text-decoration: underline;
}
 
div.body h1,
div.body h2,
div.body h3,
div.body h4,
div.body h5,
div.body h6 {
    font-family: 'Georiga', serif;
    background-color: #bbb;
    font-weight: normal;
    color: #212224;
    margin: 30px 0px 10px 0px;
    padding: 8px 0 5px 10px;
    text-shadow: 0px 1px 0 white
}
 
div.body h1 { border-top: 20px solid white; margin-top: 0; font-size: 200%; }
div.body h2 { font-size: 150%; background-color: #ddd; }
div.body h3 { font-size: 120%; background-color: #eee; }
div.body h4 { font-size: 110%; background-color: #eee; }
div.body h5 { font-size: 100%; background-color: #eee; }
div.body h6 { font-size: 100%; background-color: #eee; }
 
a.headerlink {
    color: #c60f0f;
    padding: 0 4px;
    text-decoration: none;
}
 
a.headerlink:hover {
    background-color: #c60f0f;
    color: white;
}
 
div.body p, div.body dd, div.body li {
    line-height: 1.5em;
}
 
div.admonition p.admonition-title + p {
    display: inline;
}

div.highlight{
    background-color: white;
}

div.note {
    background-color: #eee;
    border: 1px solid #ccc;
}
 
div.seealso {
    background-color: #ffc;
    border: 1px solid #ff6;
}
 
div.topic {
    background-color: #eee;
}
 
div.warning {
    background-color: #ffe4e4;
    border: 1px solid #f66;
}
 
p.admonition-title {
    display: inline;
}
 
p.admonition-title:after {
    content: "":"";
}
 
pre {
    padding: 10px;
    color: #222;
    line-height: 1.2em;
    border: 1px solid #C6C9CB;
    font-size: 1.1em;
    margin: 1.5em 0 1.5em 0;
    -webkit-box-shadow: 1px 1px 1px #d8d8d8;
    -moz-box-shadow: 1px 1px 1px #d8d8d8;
}
 
tt {
    background-color: #ecf0f3;
    color: #222;
    /* padding: 1px 2px; */
    font-size: 1.1em;
    font-family: monospace;
}
","@@ -0,0 +1,239 @@
+/*
+ * flasky.css_t
+ * ~~~~~~~~~~~~
+ *
+ * Sphinx stylesheet -- flasky theme based on nature theme.
+ *
+ * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+ 
+@import url(""basic.css"");
+ 
+/* -- page layout ----------------------------------------------------------- */
+ 
+body {
+    font-family: 'Georgia', serif;
+    font-size: 100%;
+    background-color: #111;
+    color: #555;
+    margin: 0;
+    padding: 0;
+}
+
+div.documentwrapper {
+    float: left;
+    width: 100%;
+}
+
+div.bodywrapper {
+    margin: 0 0 0 230px;
+}
+
+hr {
+    border: 1px solid #B1B4B6;
+}
+ 
+div.document {
+    background-color: #eee;
+}
+ 
+div.body {
+    background-color: #ffffff;
+    color: #3E4349;
+    padding: 0 30px 30px 30px;
+    font-size: 0.9em;
+}
+ 
+div.footer {
+    color: #555;
+    width: 100%;
+    padding: 13px 0;
+    text-align: center;
+    font-size: 75%;
+}
+ 
+div.footer a {
+    color: #444;
+    text-decoration: underline;
+}
+ 
+div.related {
+    background-color: #774117;
+    line-height: 32px;
+    color: #fff;
+    text-shadow: 0px 1px 0 #444;
+    font-size: 0.9em;
+}
+ 
+div.related a {
+    color: #E9D1C1;
+}
+ 
+div.sphinxsidebar {
+    font-size: 0.75em;
+    line-height: 1.5em;
+}
+
+div.sphinxsidebarwrapper {
+    padding: 20px 0 20px 0;
+}
+
+div.sphinxsidebarwrapper p.logo {
+    padding: 0 0 10px 0;
+    margin: 0;
+    text-align: center;
+}
+ 
+div.sphinxsidebar h3,
+div.sphinxsidebar h4 {
+    font-family: 'Georgia', serif;
+    color: #222;
+    font-size: 1.2em;
+    font-weight: normal;
+    margin: 0;
+    padding: 5px 10px;
+    background-color: #ddd;
+    text-shadow: 1px 1px 0 white
+}
+
+div.sphinxsidebar h4{
+    font-size: 1.1em;
+}
+ 
+div.sphinxsidebar h3 a {
+    color: #444;
+}
+ 
+ 
+div.sphinxsidebar p {
+    color: #555;
+    padding: 5px 20px;
+}
+ 
+div.sphinxsidebar p.topless {
+}
+ 
+div.sphinxsidebar ul {
+    margin: 10px 20px;
+    padding: 0;
+    color: #000;
+}
+ 
+div.sphinxsidebar a {
+    color: #444;
+}
+ 
+div.sphinxsidebar input {
+    border: 1px solid #ccc;
+    font-family: 'Georgia', serif;
+    font-size: 1em;
+}
+
+div.sphinxsidebar input[type=text]{
+    margin-left: 20px;
+}
+ 
+/* -- body styles ----------------------------------------------------------- */
+ 
+a {
+    color: #003B55;
+    text-decoration: none;
+}
+ 
+a:hover {
+    color: #6D4100;
+    text-decoration: underline;
+}
+ 
+div.body h1,
+div.body h2,
+div.body h3,
+div.body h4,
+div.body h5,
+div.body h6 {
+    font-family: 'Georiga', serif;
+    background-color: #bbb;
+    font-weight: normal;
+    color: #212224;
+    margin: 30px 0px 10px 0px;
+    padding: 8px 0 5px 10px;
+    text-shadow: 0px 1px 0 white
+}
+ 
+div.body h1 { border-top: 20px solid white; margin-top: 0; font-size: 200%; }
+div.body h2 { font-size: 150%; background-color: #ddd; }
+div.body h3 { font-size: 120%; background-color: #eee; }
+div.body h4 { font-size: 110%; background-color: #eee; }
+div.body h5 { font-size: 100%; background-color: #eee; }
+div.body h6 { font-size: 100%; background-color: #eee; }
+ 
+a.headerlink {
+    color: #c60f0f;
+    padding: 0 4px;
+    text-decoration: none;
+}
+ 
+a.headerlink:hover {
+    background-color: #c60f0f;
+    color: white;
+}
+ 
+div.body p, div.body dd, div.body li {
+    line-height: 1.5em;
+}
+ 
+div.admonition p.admonition-title + p {
+    display: inline;
+}
+
+div.highlight{
+    background-color: white;
+}
+
+div.note {
+    background-color: #eee;
+    border: 1px solid #ccc;
+}
+ 
+div.seealso {
+    background-color: #ffc;
+    border: 1px solid #ff6;
+}
+ 
+div.topic {
+    background-color: #eee;
+}
+ 
+div.warning {
+    background-color: #ffe4e4;
+    border: 1px solid #f66;
+}
+ 
+p.admonition-title {
+    display: inline;
+}
+ 
+p.admonition-title:after {
+    content: "":"";
+}
+ 
+pre {
+    padding: 10px;
+    color: #222;
+    line-height: 1.2em;
+    border: 1px solid #C6C9CB;
+    font-size: 1.1em;
+    margin: 1.5em 0 1.5em 0;
+    -webkit-box-shadow: 1px 1px 1px #d8d8d8;
+    -moz-box-shadow: 1px 1px 1px #d8d8d8;
+}
+ 
+tt {
+    background-color: #ecf0f3;
+    color: #222;
+    /* padding: 1px 2px; */
+    font-size: 1.1em;
+    font-family: monospace;
+}
",add missing style in css_tonumber.js,add missing style in css_tonumber.js,add missing style in css_tonumber.js,llm_rectified,0.0,5,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",theme.conf,,"[theme]
inherit = basic
stylesheet = flasky.css
","@@ -0,0 +1,3 @@
+[theme]
+inherit = basic
+stylesheet = flasky.css
",add missing space,add missing space,add missing space,llm_rectified,0.0,3,False,100.0,100.0,0,0,0,3,0.0,0,3
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",becomingbig.rst,,".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bringing those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expanding on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large applications consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here some suggestions how Flask can be modified to better accomodate large
scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.
-   switch to explicit request object passing.  This makes it more to type
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does not Flask do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code or something of larger scale.  At one
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and less easy to get started with.
","@@ -0,0 +1,54 @@
+.. _becomingbig:
+
+Becoming Big
+============
+
+Your application is becoming more and more complex?  Flask is really not
+designed for large scale applications and does not attempt to do so, but
+that does not mean you picked the wrong tool in the first place.
+
+Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
+a number of large websites out there and all Flask does is bringing those
+two together.  Being a microframework, Flask is literally a single file.
+What that means for large applications is that it's probably a good idea
+to take the code from Flask and put it into a new module within the
+applications and expanding on that.
+
+What Could Be Improved?
+-----------------------
+
+For instance it makes a lot of sense to change the way endpoints (the
+names of the functions / URL rules) are handled to also take the module
+name into account.  Right now the function name is the URL name, but
+imagine you have a large applications consisting of multiple components.
+In that case, it makes a lot of sense to use dotted names for the URL
+endpoints.
+
+Here some suggestions how Flask can be modified to better accomodate large
+scale applications:
+
+-   implement dotted names for URL endpoints
+-   get rid of the decorator function registering which causes a lot
+    of troubles for applications that have circular dependencies.  It
+    also requires that the whole application is imported when the system
+    initializes or certain URLs will not be available right away.
+-   switch to explicit request object passing.  This makes it more to type
+    (because you now have something to pass around) but it makes it a
+    whole lot easier to debug hairy situations and to test the code.
+-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
+    core framework.
+
+.. _Babel: http://babel.edgewall.org/
+.. _SQLAlchemy: http://www.sqlalchemy.org/
+
+Why does not Flask do all that by Default?
+------------------------------------------
+
+There is a huge difference between a small application that only has to
+handle a couple of requests per second and with an overall code complexity
+of less than 4000 lines of code or something of larger scale.  At one
+point it becomes important to integrate external systems, different
+storage backends and more.
+
+If Flask was designed with all these contingencies in mind, it would be a
+much more complex framework and less easy to get started with.
",add more info about the module type,add more info about the module type,add more info about the module type,llm_rectified,0.0,7,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",conf.py,"# -*- coding: utf-8 -*-
#
# Flask documentation build configuration file, created by
# sphinx-quickstart on Tue Apr  6 15:24:58 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask'
copyright = u'2010, Armin Ronacher'

import pkg_resources

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
release = __import__('pkg_resources').get_distribution('Flask').version
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flaskdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask.tex', u'Flask Documentation',
   u'Armin Ronacher', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
#epub_title = ''
#epub_author = ''
#epub_publisher = ''
#epub_copyright = ''

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

intersphinx_mapping = {
    'http://docs.python.org/dev': None,
    'http://werkzeug.pocoo.org/documentation/dev/': None
}
","# -*- coding: utf-8 -*-
#
# Flask documentation build configuration file, created by
# sphinx-quickstart on Tue Apr  6 15:24:58 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask'
copyright = u'2010, Armin Ronacher'

import pkg_resources

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
release = __import__('pkg_resources').get_distribution('Flask').version
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'flaskext.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'flasky'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.  Do not set, template magic!
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
                 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. "".xhtml"").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flaskdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask.tex', u'Flask Documentation',
   u'Armin Ronacher', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
#epub_title = ''
#epub_author = ''
#epub_publisher = ''
#epub_copyright = ''

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

intersphinx_mapping = {
    'http://docs.python.org/dev': None,
    'http://werkzeug.pocoo.org/documentation/dev/': None
}
","@@ -16,7 +16,7 @@ import sys, os
 # If extensions (or modules to document with autodoc) are in another directory,
 # add these directories to sys.path here. If the directory is relative to the
 # documentation root, use os.path.abspath to make it absolute, like shown here.
-#sys.path.append(os.path.abspath('.'))
+sys.path.append(os.path.abspath('.'))
 
 # -- General configuration -----------------------------------------------------
 
@@ -80,7 +80,7 @@ exclude_patterns = ['_build']
 #show_authors = False
 
 # The name of the Pygments (syntax highlighting) style to use.
-pygments_style = 'sphinx'
+pygments_style = 'flaskext.FlaskyStyle'
 
 # A list of ignored prefixes for module index sorting.
 #modindex_common_prefix = []
@@ -90,7 +90,7 @@ pygments_style = 'sphinx'
 
 # The theme to use for HTML and HTML Help pages.  Major themes that come with
 # Sphinx are currently 'default' and 'sphinxdoc'.
-html_theme = 'nature'
+html_theme = 'flasky'
 
 # Theme options are theme-specific and customize the look and feel of a theme
 # further.  For a list of options available for each theme, see the
@@ -98,7 +98,7 @@ html_theme = 'nature'
 #html_theme_options = {}
 
 # Add any paths that contain custom themes here, relative to this directory.
-#html_theme_path = []
+html_theme_path = ['_themes']
 
 # The name for this set of Sphinx documents.  If None, it defaults to
 # ""<project> v<release> documentation"".
@@ -108,7 +108,7 @@ html_theme = 'nature'
 #html_short_title = None
 
 # The name of an image file (relative to this directory) to place at the top
-# of the sidebar.
+# of the sidebar.  Do not set, template magic!
 #html_logo = None
 
 # The name of an image file (within the static path) to use as favicon of the
@@ -130,7 +130,11 @@ html_static_path = ['_static']
 #html_use_smartypants = True
 
 # Custom sidebar templates, maps document names to template names.
-#html_sidebars = {}
+html_sidebars = {
+    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
+    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
+                 'sourcelink.html', 'searchbox.html']
+}
 
 # Additional templates that should be rendered to pages, maps page names to
 # template names.
",add documentation for docs and docs_docs,add documentation for docs and docs_docs,add documentation for docs and docs_docs,llm_rectified,0.0,6,False,100.0,100.0,0,0,241,245,0.0,0,4
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",flaskext.py,,"# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = ""#f8f8f8""
    default_style = """"

    styles = {
        # No corresponding class for the following:
        #Text:                     """", # class:  ''
        Whitespace:                ""underline #f8f8f8"",      # class: 'w'
        Error:                     ""#a40000 border:#ef2929"", # class: 'err'
        Other:                     ""#000000"",                # class 'x'

        Comment:                   ""italic #8f5902"", # class: 'c'
        Comment.Multiline:         ""italic #8f5902"", # class: 'cm'
        Comment.Preproc:           ""italic #8f5902"", # class: 'cp'
        Comment.Single:            ""italic #8f5902"", # class: 'c1'
        Comment.Special:           ""italic #8f5902"", # class: 'cs'

        Keyword:                   ""bold #004461"",   # class: 'k'
        Keyword.Constant:          ""bold #004461"",   # class: 'kc'
        Keyword.Declaration:       ""bold #004461"",   # class: 'kd'
        Keyword.Namespace:         ""bold #004461"",   # class: 'kn'
        Keyword.Pseudo:            ""bold #004461"",   # class: 'kp'
        Keyword.Reserved:          ""bold #004461"",   # class: 'kr'
        Keyword.Type:              ""bold #004461"",   # class: 'kt'

        Operator:                  ""#582800"",   # class: 'o'
        Operator.Word:             ""bold #004461"",   # class: 'ow' - like keywords

        Punctuation:               ""bold #000000"",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      ""#000000"",        # class: 'n'
        Name.Attribute:            ""#c4a000"",        # class: 'na' - to be revised
        Name.Builtin:              ""#004461"",        # class: 'nb'
        Name.Builtin.Pseudo:       ""#3465a4"",        # class: 'bp'
        Name.Class:                ""#000000"",        # class: 'nc' - to be revised
        Name.Constant:             ""#000000"",        # class: 'no' - to be revised
        Name.Decorator:            ""#999"",           # class: 'nd' - to be revised
        Name.Entity:               ""#ce5c00"",        # class: 'ni'
        Name.Exception:            ""bold #cc0000"",   # class: 'ne'
        Name.Function:             ""#000000"",        # class: 'nf'
        Name.Property:             ""#000000"",        # class: 'py'
        Name.Label:                ""#f57900"",        # class: 'nl'
        Name.Namespace:            ""#000000"",        # class: 'nn' - to be revised
        Name.Other:                ""#000000"",        # class: 'nx'
        Name.Tag:                  ""bold #004461"",   # class: 'nt' - like a keyword
        Name.Variable:             ""#000000"",        # class: 'nv' - to be revised
        Name.Variable.Class:       ""#000000"",        # class: 'vc' - to be revised
        Name.Variable.Global:      ""#000000"",        # class: 'vg' - to be revised
        Name.Variable.Instance:    ""#000000"",        # class: 'vi' - to be revised

        # since the tango light blue does not show up well in text, we choose
        # a pure blue instead.
        Number:                    ""bold #0000cf"",   # class: 'm'
        Number.Float:              ""bold #0000cf"",   # class: 'mf'
        Number.Hex:                ""bold #0000cf"",   # class: 'mh'
        Number.Integer:            ""bold #0000cf"",   # class: 'mi'
        Number.Integer.Long:       ""bold #0000cf"",   # class: 'il'
        Number.Oct:                ""bold #0000cf"",   # class: 'mo'

        Literal:                   ""#000000"",        # class: 'l'
        Literal.Date:              ""#000000"",        # class: 'ld'

        String:                    ""#4e9a06"",        # class: 's'
        String.Backtick:           ""#4e9a06"",        # class: 'sb'
        String.Char:               ""#4e9a06"",        # class: 'sc'
        String.Doc:                ""italic #8f5902"", # class: 'sd' - like a comment
        String.Double:             ""#4e9a06"",        # class: 's2'
        String.Escape:             ""#4e9a06"",        # class: 'se'
        String.Heredoc:            ""#4e9a06"",        # class: 'sh'
        String.Interpol:           ""#4e9a06"",        # class: 'si'
        String.Other:              ""#4e9a06"",        # class: 'sx'
        String.Regex:              ""#4e9a06"",        # class: 'sr'
        String.Single:             ""#4e9a06"",        # class: 's1'
        String.Symbol:             ""#4e9a06"",        # class: 'ss'

        Generic:                   ""#000000"",        # class: 'g'
        Generic.Deleted:           ""#a40000"",        # class: 'gd'
        Generic.Emph:              ""italic #000000"", # class: 'ge'
        Generic.Error:             ""#ef2929"",        # class: 'gr'
        Generic.Heading:           ""bold #000080"",   # class: 'gh'
        Generic.Inserted:          ""#00A000"",        # class: 'gi'
        Generic.Output:            ""italic #000000"", # class: 'go'
        Generic.Prompt:            ""#8f5902"",        # class: 'gp'
        Generic.Strong:            ""bold #000000"",   # class: 'gs'
        Generic.Subheading:        ""bold #800080"",   # class: 'gu'
        Generic.Traceback:         ""bold #a40000"",   # class: 'gt'
    }
","@@ -0,0 +1,96 @@
+# flasky extensions.  flasky pygments style based on tango style
+from pygments.style import Style
+from pygments.token import Keyword, Name, Comment, String, Error, \
+     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal
+
+
+class FlaskyStyle(Style):
+    background_color = ""#f8f8f8""
+    default_style = """"
+
+    styles = {
+        # No corresponding class for the following:
+        #Text:                     """", # class:  ''
+        Whitespace:                ""underline #f8f8f8"",      # class: 'w'
+        Error:                     ""#a40000 border:#ef2929"", # class: 'err'
+        Other:                     ""#000000"",                # class 'x'
+
+        Comment:                   ""italic #8f5902"", # class: 'c'
+        Comment.Multiline:         ""italic #8f5902"", # class: 'cm'
+        Comment.Preproc:           ""italic #8f5902"", # class: 'cp'
+        Comment.Single:            ""italic #8f5902"", # class: 'c1'
+        Comment.Special:           ""italic #8f5902"", # class: 'cs'
+
+        Keyword:                   ""bold #004461"",   # class: 'k'
+        Keyword.Constant:          ""bold #004461"",   # class: 'kc'
+        Keyword.Declaration:       ""bold #004461"",   # class: 'kd'
+        Keyword.Namespace:         ""bold #004461"",   # class: 'kn'
+        Keyword.Pseudo:            ""bold #004461"",   # class: 'kp'
+        Keyword.Reserved:          ""bold #004461"",   # class: 'kr'
+        Keyword.Type:              ""bold #004461"",   # class: 'kt'
+
+        Operator:                  ""#582800"",   # class: 'o'
+        Operator.Word:             ""bold #004461"",   # class: 'ow' - like keywords
+
+        Punctuation:               ""bold #000000"",   # class: 'p'
+
+        # because special names such as Name.Class, Name.Function, etc.
+        # are not recognized as such later in the parsing, we choose them
+        # to look the same as ordinary variables.
+        Name:                      ""#000000"",        # class: 'n'
+        Name.Attribute:            ""#c4a000"",        # class: 'na' - to be revised
+        Name.Builtin:              ""#004461"",        # class: 'nb'
+        Name.Builtin.Pseudo:       ""#3465a4"",        # class: 'bp'
+        Name.Class:                ""#000000"",        # class: 'nc' - to be revised
+        Name.Constant:             ""#000000"",        # class: 'no' - to be revised
+        Name.Decorator:            ""#999"",           # class: 'nd' - to be revised
+        Name.Entity:               ""#ce5c00"",        # class: 'ni'
+        Name.Exception:            ""bold #cc0000"",   # class: 'ne'
+        Name.Function:             ""#000000"",        # class: 'nf'
+        Name.Property:             ""#000000"",        # class: 'py'
+        Name.Label:                ""#f57900"",        # class: 'nl'
+        Name.Namespace:            ""#000000"",        # class: 'nn' - to be revised
+        Name.Other:                ""#000000"",        # class: 'nx'
+        Name.Tag:                  ""bold #004461"",   # class: 'nt' - like a keyword
+        Name.Variable:             ""#000000"",        # class: 'nv' - to be revised
+        Name.Variable.Class:       ""#000000"",        # class: 'vc' - to be revised
+        Name.Variable.Global:      ""#000000"",        # class: 'vg' - to be revised
+        Name.Variable.Instance:    ""#000000"",        # class: 'vi' - to be revised
+
+        # since the tango light blue does not show up well in text, we choose
+        # a pure blue instead.
+        Number:                    ""bold #0000cf"",   # class: 'm'
+        Number.Float:              ""bold #0000cf"",   # class: 'mf'
+        Number.Hex:                ""bold #0000cf"",   # class: 'mh'
+        Number.Integer:            ""bold #0000cf"",   # class: 'mi'
+        Number.Integer.Long:       ""bold #0000cf"",   # class: 'il'
+        Number.Oct:                ""bold #0000cf"",   # class: 'mo'
+
+        Literal:                   ""#000000"",        # class: 'l'
+        Literal.Date:              ""#000000"",        # class: 'ld'
+
+        String:                    ""#4e9a06"",        # class: 's'
+        String.Backtick:           ""#4e9a06"",        # class: 'sb'
+        String.Char:               ""#4e9a06"",        # class: 'sc'
+        String.Doc:                ""italic #8f5902"", # class: 'sd' - like a comment
+        String.Double:             ""#4e9a06"",        # class: 's2'
+        String.Escape:             ""#4e9a06"",        # class: 'se'
+        String.Heredoc:            ""#4e9a06"",        # class: 'sh'
+        String.Interpol:           ""#4e9a06"",        # class: 'si'
+        String.Other:              ""#4e9a06"",        # class: 'sx'
+        String.Regex:              ""#4e9a06"",        # class: 'sr'
+        String.Single:             ""#4e9a06"",        # class: 's1'
+        String.Symbol:             ""#4e9a06"",        # class: 'ss'
+
+        Generic:                   ""#000000"",        # class: 'g'
+        Generic.Deleted:           ""#a40000"",        # class: 'gd'
+        Generic.Emph:              ""italic #000000"", # class: 'ge'
+        Generic.Error:             ""#ef2929"",        # class: 'gr'
+        Generic.Heading:           ""bold #000080"",   # class: 'gh'
+        Generic.Inserted:          ""#00A000"",        # class: 'gi'
+        Generic.Output:            ""italic #000000"", # class: 'go'
+        Generic.Prompt:            ""#8f5902"",        # class: 'gp'
+        Generic.Strong:            ""bold #000000"",   # class: 'gs'
+        Generic.Subheading:        ""bold #800080"",   # class: 'gu'
+        Generic.Traceback:         ""bold #a40000"",   # class: 'gt'
+    }
",add missing style comments,add missing style comments,add missing style comments,llm_rectified,0.0,4,False,100.0,100.0,0,1,0,96,0.0,1,96
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",foreword.rst,,"Foreword
========

Read this before you get started with Flask.  This hopefully answers some
questions about the intention of the project, what it aims at and when you
should or should not be using it.

What does Micro Mean?
---------------------

The micro in microframework for me means on the one hand being small in
size, complexity but on the other hand also that the complexity of the
applications that are written with these frameworks do not exceed a
certain size.  A microframework like Flask sacrifices a few things in
order to be approachable and to be as concise as possible.

For example Flask uses thread local objects internally so that you don't
have to pass objects around from function to function within a request in
order to stay threadsafe.  While this is a really easy approach and saves
you a lot of time, it also does not scale well to large applications.
It's especially painful for more complex unittests and when you suddenly
have to deal with code being executed outside of the context of a request
(for example if you have cronjobs).

Flask provides some tools to deal with the downsides of this approach but
the core problem of this approach obviously stays.  It is also based on
convention over configuration which means that a lot of things are
preconfigured in Flask and will work well for smaller applications but not
so much for larger ones (where and how it looks for templates, static
files etc.)

But don't worry if your application suddenly grows larger than it was
initially and you're afraid Flask might not grow with it.  Even with
larger frameworks you sooner or later will find out that you need
something the framework just cannot do for you without modification.
If you are ever in that situation, check out the :ref:`becomingbig`
chapter.

Target Audience
---------------

Is Flask for you?  Is your application small-ish (less than 4000 lines of
Python code) and does not depend on too complex database structures, Flask
is the Framework for you.  It was designed from the ground up to be easy
to use, based on established principles, good intentions and on top of two
established libraries in widespread usage.

Flask serves two purposes: it's an example of how to create a minimal and
opinionated framework on top of Werkzeug to show how this can be done, and
to provide people with a simple tool to prototype larger applications or
to implement small and medium sized applications.

If you suddenly discover that your application grows larger than
originally intended, head over to the :ref:`becomingbig` section to see
some possible solutions for larger applications.

Satisfied?  Then head over to the :ref:`installation`.
","@@ -0,0 +1,57 @@
+Foreword
+========
+
+Read this before you get started with Flask.  This hopefully answers some
+questions about the intention of the project, what it aims at and when you
+should or should not be using it.
+
+What does Micro Mean?
+---------------------
+
+The micro in microframework for me means on the one hand being small in
+size, complexity but on the other hand also that the complexity of the
+applications that are written with these frameworks do not exceed a
+certain size.  A microframework like Flask sacrifices a few things in
+order to be approachable and to be as concise as possible.
+
+For example Flask uses thread local objects internally so that you don't
+have to pass objects around from function to function within a request in
+order to stay threadsafe.  While this is a really easy approach and saves
+you a lot of time, it also does not scale well to large applications.
+It's especially painful for more complex unittests and when you suddenly
+have to deal with code being executed outside of the context of a request
+(for example if you have cronjobs).
+
+Flask provides some tools to deal with the downsides of this approach but
+the core problem of this approach obviously stays.  It is also based on
+convention over configuration which means that a lot of things are
+preconfigured in Flask and will work well for smaller applications but not
+so much for larger ones (where and how it looks for templates, static
+files etc.)
+
+But don't worry if your application suddenly grows larger than it was
+initially and you're afraid Flask might not grow with it.  Even with
+larger frameworks you sooner or later will find out that you need
+something the framework just cannot do for you without modification.
+If you are ever in that situation, check out the :ref:`becomingbig`
+chapter.
+
+Target Audience
+---------------
+
+Is Flask for you?  Is your application small-ish (less than 4000 lines of
+Python code) and does not depend on too complex database structures, Flask
+is the Framework for you.  It was designed from the ground up to be easy
+to use, based on established principles, good intentions and on top of two
+established libraries in widespread usage.
+
+Flask serves two purposes: it's an example of how to create a minimal and
+opinionated framework on top of Werkzeug to show how this can be done, and
+to provide people with a simple tool to prototype larger applications or
+to implement small and medium sized applications.
+
+If you suddenly discover that your application grows larger than
+originally intended, head over to the :ref:`becomingbig` section to see
+some possible solutions for larger applications.
+
+Satisfied?  Then head over to the :ref:`installation`.
",add more info about application nits,add more info about application nits,add more info about application nits,llm_rectified,0.0,6,False,100.0,0,0,0,0,0,-100.0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",index.rst,"Welcome to Flask
================

Welcome to Flask's documentation.  This documentation is devided into
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   installation
   quickstart
   patterns
   api
","Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :align: right

Welcome to Flask's documentation.  This documentation is devided into
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   patterns
   api
   becomingbig
","@@ -1,6 +1,10 @@
 Welcome to Flask
 ================
 
+.. image:: _static/logo-full.png
+   :alt: The Flask Logo with Subtitle
+   :align: right
+
 Welcome to Flask's documentation.  This documentation is devided into
 different parts.  I would suggest to get started with the
 :ref:`installation` and then heading over to the :ref:`quickstart`.  If
@@ -11,7 +15,9 @@ you want to dive into all the internal parts of Flask, check out the
 .. toctree::
    :maxdepth: 2
 
+   foreword
    installation
    quickstart
    patterns
    api
+   becomingbig
",add more examples to the docs,add more examples to the docs,add more examples to the docs,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
3d719f35f5c1ee4ce3dc01fb2167ef49c0180cf6,"Added docs, fixed some bugs I introduced last commit",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
import os
import sys
import pkg_resources
from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader
from werkzeug import Request, Response, LocalStack, LocalProxy, \
     create_environ, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape


class FlaskRequest(Request):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.
    """"""

    def __init__(self, environ):
        Request.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class FlaskResponse(Response):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects
    request_class = FlaskRequest

    #: the class that is used for response objects
    response_class = FlaskResponse

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []
        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.
        """"""
        reqctx = _request_ctx_stack.top
        context['request'] = reqctx.request
        context['session'] = reqctx.session
        context['g'] = reqctx.g

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path:   (self.package_name, 'static')
            }
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    @cached_property
    def test(self):
        """"""A test client for this application""""""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)
        """"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following:

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index
        """"""
        options['endpoint'] = f.__name__
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a differnt
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        """"""
        def decorator(f):
            self.add_url_rule(f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
import os
import sys
import pkg_resources
from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader
from werkzeug import Request, Response, LocalStack, LocalProxy, \
     create_environ, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape


class FlaskRequest(Request):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.
    """"""

    def __init__(self, environ):
        Request.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class FlaskResponse(Response):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects
    request_class = FlaskRequest

    #: the class that is used for response objects
    response_class = FlaskResponse

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []
        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.
        """"""
        reqctx = _request_ctx_stack.top
        context['request'] = reqctx.request
        context['session'] = reqctx.session
        context['g'] = reqctx.g

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path:   (self.package_name, 'static')
            }
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    @cached_property
    def test(self):
        """"""A test client for this application""""""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)
        """"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a differnt
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -288,7 +288,7 @@ class Flask(object):
         if session is not None:
             session.save_cookie(response, self.session_cookie_name)
 
-    def add_url_rule(self, endpoint, **options):
+    def add_url_rule(self, rule, endpoint, **options):
         """"""Connects a URL rule.  Works exactly like the :meth:`route`
         decorator but does not register the view function for the endpoint.
 
@@ -298,14 +298,14 @@ class Flask(object):
             def index():
                 pass
 
-        Is equivalent to the following:
+        Is equivalent to the following::
 
             def index():
                 pass
             app.add_url_rule('index', '/')
             app.view_functions['index'] = index
         """"""
-        options['endpoint'] = f.__name__
+        options['endpoint'] = endpoint
         options.setdefault('methods', ('GET',))
         self.url_map.add(Rule(rule, **options))
 
@@ -372,7 +372,7 @@ class Flask(object):
                                setting for this rule.  See above.
         """"""
         def decorator(f):
-            self.add_url_rule(f.__name__, **options)
+            self.add_url_rule(rule, f.__name__, **options)
             self.view_functions[f.__name__] = f
             return f
         return decorator
",add more documentation to werkzeug routes,add more documentation to werkzeug routes,add more documentation to werkzeug routes,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
8e9bd5f009bb8756a2a7d76a4b792323eeee49d6,Fixed a typo,index.rst,"Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :align: right

Welcome to Flask's documentation.  This documentation is devided into
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   patterns
   api
   becomingbig
","Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :align: right

Welcome to Flask's documentation.  This documentation is divided into
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   patterns
   api
   becomingbig
","@@ -5,7 +5,7 @@ Welcome to Flask
    :alt: The Flask Logo with Subtitle
    :align: right
 
-Welcome to Flask's documentation.  This documentation is devided into
+Welcome to Flask's documentation.  This documentation is divided into
 different parts.  I would suggest to get started with the
 :ref:`installation` and then heading over to the :ref:`quickstart`.  If
 you want to dive into all the internal parts of Flask, check out the
",add more examples to the docs,add more examples to the docs,add more examples to the docs,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
1fff3e598126a084348ec2c112fdd3bc6b9a1ee0,Fixed a doc display bug and setup.py workaround for dev version.,flasky.css_t,"/*
 * flasky.css_t
 * ~~~~~~~~~~~~
 *
 * Sphinx stylesheet -- flasky theme based on nature theme.
 *
 * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 *
 */
 
@import url(""basic.css"");
 
/* -- page layout ----------------------------------------------------------- */
 
body {
    font-family: 'Georgia', serif;
    font-size: 100%;
    background-color: #555;
    color: #555;
    margin: 0;
    padding: 0;
}

div.documentwrapper {
    float: left;
    width: 100%;
}

div.bodywrapper {
    margin: 0 0 0 230px;
}

hr {
    border: 1px solid #B1B4B6;
}
 
div.document {
    background-color: #eee;
}
 
div.body {
    background-color: #ffffff;
    color: #3E4349;
    padding: 0 30px 30px 30px;
    font-size: 0.9em;
}
 
div.footer {
    color: #ccc;
    padding: 10px;
    font-size: 0.8em;
}
 
div.footer a {
    color: white;
    text-decoration: underline;
}
 
div.related {
    background-color: #774117;
    line-height: 32px;
    color: #fff;
    text-shadow: 0px 1px 0 #444;
    font-size: 0.9em;
}
 
div.related a {
    color: #E9D1C1;
}
 
div.sphinxsidebar {
    font-size: 0.75em;
    line-height: 1.5em;
}

div.sphinxsidebarwrapper {
    padding: 20px 0 20px 0;
}

div.sphinxsidebarwrapper p.logo {
    padding: 0 0 10px 0;
    margin: 0;
    text-align: center;
}
 
div.sphinxsidebar h3,
div.sphinxsidebar h4 {
    font-family: 'Georgia', serif;
    color: #222;
    font-size: 1.2em;
    font-weight: normal;
    margin: 0;
    padding: 5px 10px;
    background-color: #ddd;
    text-shadow: 1px 1px 0 white
}

div.sphinxsidebar h4{
    font-size: 1.1em;
}
 
div.sphinxsidebar h3 a {
    color: #444;
}
 
 
div.sphinxsidebar p {
    color: #555;
    padding: 5px 20px;
}
 
div.sphinxsidebar p.topless {
}
 
div.sphinxsidebar ul {
    margin: 10px 20px;
    padding: 0;
    color: #000;
}
 
div.sphinxsidebar a {
    color: #444;
}
 
div.sphinxsidebar input {
    border: 1px solid #ccc;
    font-family: 'Georgia', serif;
    font-size: 1em;
}

div.sphinxsidebar input[type=text]{
    margin-left: 20px;
}
 
/* -- body styles ----------------------------------------------------------- */
 
a {
    color: #004B6B;
    text-decoration: none;
}
 
a:hover {
    color: #6D4100;
    text-decoration: underline;
}
 
div.body h1,
div.body h2,
div.body h3,
div.body h4,
div.body h5,
div.body h6 {
    font-family: 'Georiga', serif;
    background-color: #bbb;
    font-weight: normal;
    color: #212224;
    margin: 30px 0px 10px 0px;
    padding: 8px 0 5px 10px;
    text-shadow: 0px 1px 0 white;
}
 
div.body h1 { border-top: 20px solid white; margin-top: 0; font-size: 200%; }
div.body h2 { font-size: 150%; background-color: #ddd; }
div.body h3 { font-size: 120%; background-color: #eee; }
div.body h4 { font-size: 110%; background-color: #eee; }
div.body h5 { font-size: 100%; background-color: #eee; }
div.body h6 { font-size: 100%; background-color: #eee; }
 
a.headerlink {
    color: white;
    padding: 0 4px;
    text-decoration: none;
}
 
a.headerlink:hover {
    color: #444;
    background: #eaeaea;
}
 
div.body p, div.body dd, div.body li {
    line-height: 1.5em;
}
 
div.admonition p.admonition-title + p {
    display: inline;
}

div.highlight{
    background-color: white;
}

div.note {
    background-color: #eee;
    border: 1px solid #ccc;
}
 
div.seealso {
    background-color: #ffc;
    border: 1px solid #ff6;
}
 
div.topic {
    background-color: #eee;
}
 
div.warning {
    background-color: #ffe4e4;
    border: 1px solid #f66;
}
 
p.admonition-title {
    display: inline;
}
 
p.admonition-title:after {
    content: "":"";
}

pre, tt {
    font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
    font-size: 0.9em;
}

tt.descname, tt.descclassname {
    font-size: 0.95em;
    -webkit-box-shadow: none;
    -moz-box-shadow: none;
}

tt.descname {
    padding-right: 0.08em;
}

table.docutils {
    border: 1px solid #888;
    -webkit-box-shadow: 2px 2px 1px #d8d8d8;
    -moz-box-shadow: 2px 2px 1px #d8d8d8;
}

table.docutils td, table.docutils th {
    border: 1px solid #888;
    padding: 0.25em 0.7em;
}

table.field-list {
    border: none;
    -webkit-box-shadow: none;
    -moz-box-shadow: none;
}

table.field-list th {
    padding: 0 0.8em 0 0;
}

table.field-list td {
    padding: 0;
}
 
pre {
    background: #FDFDFD;
    padding: 10px;
    color: #222;
    line-height: 1.3em;
    border: 1px solid #f9f9f9;
    margin: 1.5em 3px 1.5em 0;
    -webkit-box-shadow: 2px 2px 1px #d8d8d8;
    -moz-box-shadow: 2px 2px 1px #d8d8d8;
}
 
tt {
    background-color: #ecf0f3;
    color: #222;
    /* padding: 1px 2px; */
    -webkit-box-shadow: 1px 1px 1px #d8d8d8;
    -moz-box-shadow: 1px 1px 1px #d8d8d8;
}

tt.xref, a tt {
    background-color: #FBFBFB;
}

a:hover tt {
    background: #EEE;
}

div.document + div.related {
    background: #aaa;
}

div.document + div.related a {
    color: white;
}
","/*
 * flasky.css_t
 * ~~~~~~~~~~~~
 *
 * Sphinx stylesheet -- flasky theme based on nature theme.
 *
 * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 *
 */
 
@import url(""basic.css"");
 
/* -- page layout ----------------------------------------------------------- */
 
body {
    font-family: 'Georgia', serif;
    font-size: 100%;
    background-color: #555;
    color: #555;
    margin: 0;
    padding: 0;
}

div.documentwrapper {
    float: left;
    width: 100%;
}

div.bodywrapper {
    margin: 0 0 0 230px;
}

hr {
    border: 1px solid #B1B4B6;
}
 
div.document {
    background-color: #eee;
}
 
div.body {
    background-color: #ffffff;
    color: #3E4349;
    padding: 0 30px 30px 30px;
    font-size: 0.9em;
}
 
div.footer {
    color: #ccc;
    padding: 10px;
    font-size: 0.8em;
}
 
div.footer a {
    color: white;
    text-decoration: underline;
}
 
div.related {
    background-color: #774117;
    line-height: 32px;
    color: #fff;
    text-shadow: 0px 1px 0 #444;
    font-size: 0.9em;
}
 
div.related a {
    color: #E9D1C1;
}
 
div.sphinxsidebar {
    font-size: 0.75em;
    line-height: 1.5em;
}

div.sphinxsidebarwrapper {
    padding: 20px 0 20px 0;
}

div.sphinxsidebarwrapper p.logo {
    padding: 0 0 10px 0;
    margin: 0;
    text-align: center;
}
 
div.sphinxsidebar h3,
div.sphinxsidebar h4 {
    font-family: 'Garamond', 'Georgia', serif;
    color: #222;
    font-size: 1.2em;
    font-weight: normal;
    margin: 0;
    padding: 5px 10px;
    background-color: #ddd;
    text-shadow: 1px 1px 0 white
}

div.sphinxsidebar h4 {
    font-size: 1.1em;
}
 
div.sphinxsidebar h3 a {
    color: #444;
}
 
 
div.sphinxsidebar p {
    color: #555;
    padding: 5px 20px;
}
 
div.sphinxsidebar p.topless {
}
 
div.sphinxsidebar ul {
    margin: 10px 20px;
    padding: 0;
    color: #000;
}
 
div.sphinxsidebar a {
    color: #444;
}
 
div.sphinxsidebar input {
    border: 1px solid #ccc;
    font-family: 'Georgia', serif;
    font-size: 1em;
}

div.sphinxsidebar input[type=text]{
    margin-left: 20px;
}
 
/* -- body styles ----------------------------------------------------------- */
 
a {
    color: #004B6B;
    text-decoration: none;
}
 
a:hover {
    color: #6D4100;
    text-decoration: underline;
}
 
div.body h1,
div.body h2,
div.body h3,
div.body h4,
div.body h5,
div.body h6 {
    font-family: 'Garamond', 'Georiga', serif;
    background-color: #bbb;
    font-weight: normal;
    color: #212224;
    margin: 30px 0px 10px 0px;
    padding: 5px 0 5px 10px;
    text-shadow: 0px 1px 0 white;
}
 
div.body h1 { border-top: 20px solid white; margin-top: 0; font-size: 200%; }
div.body h2 { font-size: 150%; background-color: #ddd; }
div.body h3 { font-size: 120%; background-color: #eee; }
div.body h4 { font-size: 110%; background-color: #eee; }
div.body h5 { font-size: 100%; background-color: #eee; }
div.body h6 { font-size: 100%; background-color: #eee; }
 
a.headerlink {
    color: white;
    padding: 0 4px;
    text-decoration: none;
}
 
a.headerlink:hover {
    color: #444;
    background: #eaeaea;
}
 
div.body p, div.body dd, div.body li {
    line-height: 1.5em;
}
 
div.admonition p.admonition-title + p {
    display: inline;
}

div.highlight{
    background-color: white;
}

div.note {
    background-color: #eee;
    border: 1px solid #ccc;
}
 
div.seealso {
    background-color: #ffc;
    border: 1px solid #ff6;
}
 
div.topic {
    background-color: #eee;
}
 
div.warning {
    background-color: #ffe4e4;
    border: 1px solid #f66;
}
 
p.admonition-title {
    display: inline;
}
 
p.admonition-title:after {
    content: "":"";
}

pre, tt {
    font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
    font-size: 0.9em;
}

tt.descname, tt.descclassname {
    font-size: 0.95em;
    -webkit-box-shadow: none;
    -moz-box-shadow: none;
}

tt.descname {
    padding-right: 0.08em;
}

table.docutils {
    border: 1px solid #888;
    -webkit-box-shadow: 2px 2px 1px #d8d8d8;
    -moz-box-shadow: 2px 2px 1px #d8d8d8;
}

table.docutils td, table.docutils th {
    border: 1px solid #888;
    padding: 0.25em 0.7em;
}

table.field-list {
    border: none;
    -webkit-box-shadow: none;
    -moz-box-shadow: none;
}

table.field-list th {
    padding: 0 0.8em 0 0;
}

table.field-list td {
    padding: 0;
}
 
pre {
    background: #FDFDFD;
    padding: 10px;
    color: #222;
    line-height: 1.3em;
    border: 1px solid #f9f9f9;
    margin: 1.5em 3px 1.5em 0;
    -webkit-box-shadow: 2px 2px 1px #d8d8d8;
    -moz-box-shadow: 2px 2px 1px #d8d8d8;
}
 
tt {
    background-color: #ecf0f3;
    color: #222;
    /* padding: 1px 2px; */
    -webkit-box-shadow: 1px 1px 1px #d8d8d8;
    -moz-box-shadow: 1px 1px 1px #d8d8d8;
}

tt.xref, a tt {
    background-color: #FBFBFB;
}

a:hover tt {
    background: #EEE;
}

div.document + div.related {
    background: #aaa;
}

div.document + div.related a {
    color: white;
}
","@@ -86,7 +86,7 @@ div.sphinxsidebarwrapper p.logo {
  
 div.sphinxsidebar h3,
 div.sphinxsidebar h4 {
-    font-family: 'Georgia', serif;
+    font-family: 'Garamond', 'Georgia', serif;
     color: #222;
     font-size: 1.2em;
     font-weight: normal;
@@ -96,7 +96,7 @@ div.sphinxsidebar h4 {
     text-shadow: 1px 1px 0 white
 }
 
-div.sphinxsidebar h4{
+div.sphinxsidebar h4 {
     font-size: 1.1em;
 }
  
@@ -151,12 +151,12 @@ div.body h3,
 div.body h4,
 div.body h5,
 div.body h6 {
-    font-family: 'Georiga', serif;
+    font-family: 'Garamond', 'Georiga', serif;
     background-color: #bbb;
     font-weight: normal;
     color: #212224;
     margin: 30px 0px 10px 0px;
-    padding: 8px 0 5px 10px;
+    padding: 5px 0 5px 10px;
     text-shadow: 0px 1px 0 white;
 }
  
",add missing styling to doc,add missing styling to doc,add missing styling to doc,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
1fff3e598126a084348ec2c112fdd3bc6b9a1ee0,Fixed a doc display bug and setup.py workaround for dev version.,deploying.rst,"Deployment Options
==================

Depending on what you have available there are multiple ways to run Flask
applications.  A very common method is to use the builtin server during
development and maybe behind a proxy for simple applications, but there
are more options available.

If you have a different WSGI server look up the server documentation about
how to use a WSGI app with it.  Just remember that your application object
is the actual WSGI application.


FastCGI
-------

A very popular deployment setup on servers like `lighttpd`_ and `nginx`_
is FastCGI.  To use your WSGI application with any of them you will need
a FastCGI server first.

The most popular one is `flup`_ which we will use for this guide.  Make
sure to have it installed.

Creating a `.fcgi` file
```````````````````````

First you need to create the FastCGI server file.  Let's call it
`yourapplication.fcgi`::

    #!/usr/bin/python
    from flup.server.fcgi import WSGIServer
    from yourapplication import app

    WSGIServer(app).run()

This is enough for Apache to work, however lighttpd and nginx need a
socket to communicate with the FastCGI server.  For that to work you
need to pass the path to the socket to the
:class:`~flup.server.fcgi.WSGIServer`::

    WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()

The path has to be the exact same path you define in the server
config.

Save the `yourapplication.fcgi` file somewhere you will find it again.
It makes sense to have that in `/var/www/yourapplication` or something
similar.

Make sure to set the executable bit on that file so that the servers
can execute it::

    # chmod +x /var/www/yourapplication/yourapplication.fcgi

Configuring lighttpd
````````````````````

A basic FastCGI configuration for lighttpd looks like that::

    fastcgi.server = (""/yourapplication"" =>
        ""yourapplication"" => (
            ""socket"" => ""/tmp/yourapplication-fcgi.sock"",
            ""bin-path"" => ""/var/www/yourapplication/yourapplication.fcgi"",
            ""check-local"" => ""disable""
        )
    )

This configuration binds the application to `/yourapplication`.  If you
want the application to work in the URL root you have to work around a
lighttpd bug with the `~werkzeug.contrib.fixers.LighttpdCGIRootFix` middleware.

Make sure to apply it only if you are mounting the application the URL
root.

Configuring nginx
`````````````````

Installing FastCGI applications on nginx is a bit tricky because by default
some FastCGI parameters are not properly forwarded.

A basic FastCGI configuration for nginx looks like this::

    location /yourapplication/ {
        include fastcgi_params;
        if ($uri ~ ^/yourapplication/(.*)?) {
            set $path_url $1;
        }
        fastcgi_param PATH_INFO $path_url;
        fastcgi_param SCRIPT_NAME /yourapplication;
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

This configuration binds the application to `/yourapplication`.  If you want
to have it in the URL root it's a bit easier because you don't have to figure
out how to calculate `PATH_INFO` and `SCRIPT_NAME`::

    location /yourapplication/ {
        include fastcgi_params;
        fastcgi_param PATH_INFO $fastcgi_script_name;
        fastcgi_param SCRIPT_NAME """";
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

Since Nginx doesn't load FastCGI apps, you have to do it by yourself.  You
can either write an `init.d` script for that or execute it inside a screen
session::

    $ screen
    $ /var/www/yourapplication/yourapplication.fcgi

Debugging
`````````

FastCGI deployments tend to be hard to debug on most webservers.  Very often the
only thing the server log tells you is something along the lines of ""premature
end of headers"".  In order to debug the application the only thing that can
really give you ideas why it breaks is switching to the correct user and
executing the application by hand.

This example assumes your application is called `application.fcgi` and that your
webserver user is `www-data`::

    $ su www-data
    $ cd /var/www/yourapplication
    $ python application.fcgi
    Traceback (most recent call last):
      File ""yourapplication.fcg"", line 4, in <module>
    ImportError: No module named yourapplication

In this case the error seems to be ""yourapplication"" not being on the python
path.  Common problems are:

-   relative paths being used.  Don't rely on the current working directory
-   the code depending on environment variables that are not set by the
    web server.
-   different python interpreters being used.

.. _lighttpd: http://www.lighttpd.net/
.. _nginx: http://nginx.net/
.. _flup: http://trac.saddi.com/flup


mod_wsgi (Apache)
-----------------

If you are using the `Apache`_ webserver you should consider using `mod_wsgi`_.

.. _Apache: http://httpd.apache.org/

Installing `mod_wsgi`
`````````````````````

If you don't have `mod_wsgi` installed yet you have to either install it using
a package manager or compile it yourself.

The mod_wsgi `installation instructions`_ cover installation instructions for
source installations on UNIX systems.

If you are using ubuntu / debian you can apt-get it and activate it as follows::

    # apt-get install libapache2-mod-wsgi

On FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using
pkg_add::

    # pkg_add -r mod_wsgi

If you are using pkgsrc you can install `mod_wsgi` by compiling the
`www/ap2-wsgi` package.

If you encounter segfaulting child processes after the first apache reload you
can safely ignore them.  Just restart the server.

Creating a `.wsgi` file
```````````````````````

To run your application you need a `yourapplication.wsgi` file.  This file
contains the code `mod_wsgi` is executing on startup to get the application
object.  The object called `application` in that file is then used as
application.

For most applications the following file should be sufficient::

    from yourapplication import app as application

If you don't have a factory function for application creation but a singleton
instance you can directly import that one as `application`.

Store that file somewhere where you will find it again (eg:
`/var/www/yourapplication`) and make sure that `yourapplication` and all
the libraries that are in use are on the python load path.  If you don't
want to install it system wide consider using a `virtual python`_ instance.

Configuring Apache
``````````````````

The last thing you have to do is to create an Apache configuration file for
your application.  In this example we are telling `mod_wsgi` to execute the
application under a different user for security reasons:

.. sourcecode:: apache

    <VirtualHost *>
        ServerName example.com

        WSGIDaemonProcess yourapplication user=user1 group=group1 processes=1 threads=5
        WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi

        <Directory /var/www/yourapplication>
            WSGIProcessGroup yourapplication
            WSGIApplicationGroup %{GLOBAL}
            Order deny,allow
            Allow from all
        </Directory>
    </VirtualHost>

For more information consult the `mod_wsgi wiki`_.

.. _mod_wsgi: http://code.google.com/p/modwsgi/
.. _installation instructions: http://code.google.com/p/modwsgi/wiki/QuickInstallationGuide
.. _virtual python: http://pypi.python.org/pypi/virtualenv
.. _mod_wsgi wiki: http://code.google.com/p/modwsgi/wiki/


CGI
---

If all other deployment methods do not work, CGI will work for sure.  CGI
is supported by all major browsers but usually has a less-than-optimal
performance.

This is also the way you can use a Flask application on Google's
`AppEngine`_, there however the execution does happen in a CGI-like
environment.  The application's performance is unaffected because of that.

.. _AppEngine: http://code.google.com/appengine/

Creating a `.cgi` file
``````````````````````

First you need to create the CGI application file.  Let's call it
`yourapplication.cgi`::

    #!/usr/bin/python
    from wsgiref.handlers import CGIHandler
    from yourapplication import app

    CGIHandler().run(app)

If you're running Python 2.4 you will need the :mod:`wsgiref` package.  Python
2.5 and higher ship this as part of the standard library.

Server Setup
````````````

Usually there are two ways to configure the server.  Either just copy the
`.cgi` into a `cgi-bin` (and use `mod_rerwite` or something similar to
rewrite the URL) or let the server point to the file directly.

In Apache for example you can put a like like this into the config:

.. sourcecode:: apache

    ScriptName /app /path/to/the/application.cgi

For more information consult the documentation of your webserver.
","Deployment Options
==================

Depending on what you have available there are multiple ways to run Flask
applications.  A very common method is to use the builtin server during
development and maybe behind a proxy for simple applications, but there
are more options available.

If you have a different WSGI server look up the server documentation about
how to use a WSGI app with it.  Just remember that your application object
is the actual WSGI application.


FastCGI
-------

A very popular deployment setup on servers like `lighttpd`_ and `nginx`_
is FastCGI.  To use your WSGI application with any of them you will need
a FastCGI server first.

The most popular one is `flup`_ which we will use for this guide.  Make
sure to have it installed.

Creating a `.fcgi` file
```````````````````````

First you need to create the FastCGI server file.  Let's call it
`yourapplication.fcgi`::

    #!/usr/bin/python
    from flup.server.fcgi import WSGIServer
    from yourapplication import app

    WSGIServer(app).run()

This is enough for Apache to work, however lighttpd and nginx need a
socket to communicate with the FastCGI server.  For that to work you
need to pass the path to the socket to the
:class:`~flup.server.fcgi.WSGIServer`::

    WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()

The path has to be the exact same path you define in the server
config.

Save the `yourapplication.fcgi` file somewhere you will find it again.
It makes sense to have that in `/var/www/yourapplication` or something
similar.

Make sure to set the executable bit on that file so that the servers
can execute it::

    # chmod +x /var/www/yourapplication/yourapplication.fcgi

Configuring lighttpd
````````````````````

A basic FastCGI configuration for lighttpd looks like that::

    fastcgi.server = (""/yourapplication"" =>
        ""yourapplication"" => (
            ""socket"" => ""/tmp/yourapplication-fcgi.sock"",
            ""bin-path"" => ""/var/www/yourapplication/yourapplication.fcgi"",
            ""check-local"" => ""disable""
        )
    )

This configuration binds the application to `/yourapplication`.  If you
want the application to work in the URL root you have to work around a
lighttpd bug with the :class:`~werkzeug.contrib.fixers.LighttpdCGIRootFix`
middleware.

Make sure to apply it only if you are mounting the application the URL
root.

Configuring nginx
`````````````````

Installing FastCGI applications on nginx is a bit tricky because by default
some FastCGI parameters are not properly forwarded.

A basic FastCGI configuration for nginx looks like this::

    location /yourapplication/ {
        include fastcgi_params;
        if ($uri ~ ^/yourapplication/(.*)?) {
            set $path_url $1;
        }
        fastcgi_param PATH_INFO $path_url;
        fastcgi_param SCRIPT_NAME /yourapplication;
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

This configuration binds the application to `/yourapplication`.  If you want
to have it in the URL root it's a bit easier because you don't have to figure
out how to calculate `PATH_INFO` and `SCRIPT_NAME`::

    location /yourapplication/ {
        include fastcgi_params;
        fastcgi_param PATH_INFO $fastcgi_script_name;
        fastcgi_param SCRIPT_NAME """";
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

Since Nginx doesn't load FastCGI apps, you have to do it by yourself.  You
can either write an `init.d` script for that or execute it inside a screen
session::

    $ screen
    $ /var/www/yourapplication/yourapplication.fcgi

Debugging
`````````

FastCGI deployments tend to be hard to debug on most webservers.  Very often the
only thing the server log tells you is something along the lines of ""premature
end of headers"".  In order to debug the application the only thing that can
really give you ideas why it breaks is switching to the correct user and
executing the application by hand.

This example assumes your application is called `application.fcgi` and that your
webserver user is `www-data`::

    $ su www-data
    $ cd /var/www/yourapplication
    $ python application.fcgi
    Traceback (most recent call last):
      File ""yourapplication.fcg"", line 4, in <module>
    ImportError: No module named yourapplication

In this case the error seems to be ""yourapplication"" not being on the python
path.  Common problems are:

-   relative paths being used.  Don't rely on the current working directory
-   the code depending on environment variables that are not set by the
    web server.
-   different python interpreters being used.

.. _lighttpd: http://www.lighttpd.net/
.. _nginx: http://nginx.net/
.. _flup: http://trac.saddi.com/flup


mod_wsgi (Apache)
-----------------

If you are using the `Apache`_ webserver you should consider using `mod_wsgi`_.

.. _Apache: http://httpd.apache.org/

Installing `mod_wsgi`
`````````````````````

If you don't have `mod_wsgi` installed yet you have to either install it using
a package manager or compile it yourself.

The mod_wsgi `installation instructions`_ cover installation instructions for
source installations on UNIX systems.

If you are using ubuntu / debian you can apt-get it and activate it as follows::

    # apt-get install libapache2-mod-wsgi

On FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using
pkg_add::

    # pkg_add -r mod_wsgi

If you are using pkgsrc you can install `mod_wsgi` by compiling the
`www/ap2-wsgi` package.

If you encounter segfaulting child processes after the first apache reload you
can safely ignore them.  Just restart the server.

Creating a `.wsgi` file
```````````````````````

To run your application you need a `yourapplication.wsgi` file.  This file
contains the code `mod_wsgi` is executing on startup to get the application
object.  The object called `application` in that file is then used as
application.

For most applications the following file should be sufficient::

    from yourapplication import app as application

If you don't have a factory function for application creation but a singleton
instance you can directly import that one as `application`.

Store that file somewhere where you will find it again (eg:
`/var/www/yourapplication`) and make sure that `yourapplication` and all
the libraries that are in use are on the python load path.  If you don't
want to install it system wide consider using a `virtual python`_ instance.

Configuring Apache
``````````````````

The last thing you have to do is to create an Apache configuration file for
your application.  In this example we are telling `mod_wsgi` to execute the
application under a different user for security reasons:

.. sourcecode:: apache

    <VirtualHost *>
        ServerName example.com

        WSGIDaemonProcess yourapplication user=user1 group=group1 processes=1 threads=5
        WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi

        <Directory /var/www/yourapplication>
            WSGIProcessGroup yourapplication
            WSGIApplicationGroup %{GLOBAL}
            Order deny,allow
            Allow from all
        </Directory>
    </VirtualHost>

For more information consult the `mod_wsgi wiki`_.

.. _mod_wsgi: http://code.google.com/p/modwsgi/
.. _installation instructions: http://code.google.com/p/modwsgi/wiki/QuickInstallationGuide
.. _virtual python: http://pypi.python.org/pypi/virtualenv
.. _mod_wsgi wiki: http://code.google.com/p/modwsgi/wiki/


CGI
---

If all other deployment methods do not work, CGI will work for sure.  CGI
is supported by all major browsers but usually has a less-than-optimal
performance.

This is also the way you can use a Flask application on Google's
`AppEngine`_, there however the execution does happen in a CGI-like
environment.  The application's performance is unaffected because of that.

.. _AppEngine: http://code.google.com/appengine/

Creating a `.cgi` file
``````````````````````

First you need to create the CGI application file.  Let's call it
`yourapplication.cgi`::

    #!/usr/bin/python
    from wsgiref.handlers import CGIHandler
    from yourapplication import app

    CGIHandler().run(app)

If you're running Python 2.4 you will need the :mod:`wsgiref` package.  Python
2.5 and higher ship this as part of the standard library.

Server Setup
````````````

Usually there are two ways to configure the server.  Either just copy the
`.cgi` into a `cgi-bin` (and use `mod_rerwite` or something similar to
rewrite the URL) or let the server point to the file directly.

In Apache for example you can put a like like this into the config:

.. sourcecode:: apache

    ScriptName /app /path/to/the/application.cgi

For more information consult the documentation of your webserver.
","@@ -67,7 +67,8 @@ A basic FastCGI configuration for lighttpd looks like that::
 
 This configuration binds the application to `/yourapplication`.  If you
 want the application to work in the URL root you have to work around a
-lighttpd bug with the `~werkzeug.contrib.fixers.LighttpdCGIRootFix` middleware.
+lighttpd bug with the :class:`~werkzeug.contrib.fixers.LighttpdCGIRootFix`
+middleware.
 
 Make sure to apply it only if you are mounting the application the URL
 root.
",add documentation for nginx and fastcgi application options,add documentation for nginx and fastcgi application options,add documentation for nginx and fastcgi application options,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
1fff3e598126a084348ec2c112fdd3bc6b9a1ee0,Fixed a doc display bug and setup.py workaround for dev version.,setup.py,"from setuptools import setup


setup(
    name='Flask',
    version='0.1',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 and good intentions',
    modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[ # yes, as of now we need the development versions
        'Werkzeug==dev',
        'Jinja2==dev',
    ]
)
","from setuptools import setup


setup(
    name='Flask',
    version='0.1',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 and good intentions',
    modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[
        ## disabled until release, install yourself
        # 'Werkzeug',
        # 'Jinja2'
    ]
)
","@@ -12,8 +12,9 @@ setup(
     modules=['flask'],
     zip_safe=False,
     platforms='any',
-    install_requires=[ # yes, as of now we need the development versions
-        'Werkzeug==dev',
-        'Jinja2==dev',
+    install_requires=[
+        ## disabled until release, install yourself
+        # 'Werkzeug',
+        # 'Jinja2'
     ]
 )
",add missing missing `setup` statements,add missing missing `setup` statements,add missing missing `setup` statements,llm_rectified,0.0,5,False,100.0,100.0,0,0,19,20,0.0,0,1
574e81f9c8bbdc41958e1e7a7613633b091101f8,Fixed a bug in setup.py,quickstart.rst,".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter::

    $ python hello.py
     * Running on http://localhost:5000/

Head over to `http://localhost:5000/ <http://localhost:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).


HTTP Methods
````````````

HTTP knows different methods to access URLs.  By default a route only
answers to ``GET`` requests, but that can be changed by providing the
`methods` argument to the :meth:`~flask.Flask.route` decorator.  Here some
examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If ``GET`` is present, ``HEAD`` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that ``HEAD``
requests are handled like the RFC demands, so you can completely ignore
that part of the HTTP specification.

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` objects as well as the
:func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html')

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
",".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://localhost:5000/

Head over to `http://localhost:5000/ <http://localhost:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).


HTTP Methods
````````````

HTTP knows different methods to access URLs.  By default a route only
answers to ``GET`` requests, but that can be changed by providing the
`methods` argument to the :meth:`~flask.Flask.route` decorator.  Here some
examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If ``GET`` is present, ``HEAD`` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that ``HEAD``
requests are handled like the RFC demands, so you can completely ignore
that part of the HTTP specification.

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` objects as well as the
:func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html')

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
","@@ -24,7 +24,10 @@ A minimal Flask application looks something like that::
         app.run()
 
 Just save it as `hello.py` or something similar and run it with your
-Python interpreter::
+Python interpreter.  Make sure to not call your application `flask.py`
+because this would conflict with Flask itself.
+
+::
 
     $ python hello.py
      * Running on http://localhost:5000/
",add documentation for the url_for function,add documentation for the url_for function,add documentation for the url_for function,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
574e81f9c8bbdc41958e1e7a7613633b091101f8,Fixed a bug in setup.py,setup.py,"from setuptools import setup


setup(
    name='Flask',
    version='0.1',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 and good intentions',
    modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[
        ## disabled until release, install yourself
        # 'Werkzeug',
        # 'Jinja2'
    ]
)
","from setuptools import setup


setup(
    name='Flask',
    version='0.1',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 and good intentions',
    py_modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[
        ## disabled until release, install yourself
        # 'Werkzeug',
        # 'Jinja2'
    ]
)
","@@ -9,7 +9,7 @@ setup(
     author='Armin Ronacher',
     author_email='armin.ronacher@active-4.com',
     description='A microframework based on Werkzeug, Jinja2 and good intentions',
-    modules=['flask'],
+    py_modules=['flask'],
     zip_safe=False,
     platforms='any',
     install_requires=[
",add missing `setup.py`,add missing `setup.py`,add missing `setup.py`,llm_rectified,0.0,3,False,100.0,100.0,0,0,20,20,0.0,0,0
2f5a4f8dbc832b0daebcd66ea8b3969589191fa7,Doc updates and typo fixes,testing.rst,,".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests you
can savely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will us the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  Let's start
simple with a Hello World application (`hello.py`)::

    from flask import Flask, render_template_string
    app = Flask(__name__)

    @app.route('/')
    @app.route('/<name>')
    def hello(name='World'):
        return render_template_string('''
            <!doctype html>
            <title>Hello {{ name }}!</title>
            <h1>Hello {{ name }}!</h1>
        ''', name=name)

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`hello_tests.py`) and create a unittest skeleton there::

    import unittest
    import hello

    class HelloWorldTestCase(unittest.TestCase):

        def setUp(self):
            self.app = hello.app.test_client()

    if __name__ == '__main__':
        unittest.main()

The code in the `setUp` function creates a new test client.  That function
is called before each individual test function.  What the test client does
for us is giving us a simple interface to the application.  We can trigger
test requests to the application and the client will also keep track of
cookies for us.

If we now run that testsuite, we should see the following output::

    $ python hello_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s
    
    OK

Even though it did not run any tests, we already know that our hello
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application greets us
with ""Hello World"" if we access it on ``/``.  For that we modify our
created test case class so that it looks like this::

    class HelloWorldTestCase(unittest.TestCase):

        def setUp(self):
            self.app = hello.app.test_client()

        def test_hello_world(self):
            rv = self.app.get('/')
            assert 'Hello World!' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'Hello World!'`` is part of the output.

Run it again and you should see one passing test.  Let's add a second test
here::

        def test_hello_name(self):
            rv = self.app.get('/Peter')
            assert 'Hello Peter!' in rv.data

Of course you can submit forms with the test client as well.  For that and
other features of the test client, check the documentation of the Werkzeug
test :class:`~werkzeug.Client` and the tests of the MiniTwit example
application:

-   Werkzeug Test :class:`~werkzeug.Client`
-   `MiniTwit Example`_

.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
","@@ -0,0 +1,116 @@
+.. _testing:
+
+Testing Flask Applications
+==========================
+
+   **Something that is untested is broken.**
+
+Not sure where that is coming from, and it's not entirely correct, but
+also not that far from the truth.  Untested applications make it hard to
+improve existing code and developers of untested applications tend to
+become pretty paranoid.  If an application however has automated tests you
+can savely change things and you will instantly know if your change broke
+something.
+
+Flask gives you a couple of ways to test applications.  It mainly does
+that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
+code and handling the context locals for you.  You can then use that with
+your favourite testing solution.  In this documentation we will us the
+:mod:`unittest` package that comes preinstalled with each Python
+installation.
+
+The Application
+---------------
+
+First we need an application to test for functionality.  Let's start
+simple with a Hello World application (`hello.py`)::
+
+    from flask import Flask, render_template_string
+    app = Flask(__name__)
+
+    @app.route('/')
+    @app.route('/<name>')
+    def hello(name='World'):
+        return render_template_string('''
+            <!doctype html>
+            <title>Hello {{ name }}!</title>
+            <h1>Hello {{ name }}!</h1>
+        ''', name=name)
+
+The Testing Skeleton
+--------------------
+
+In order to test that, we add a second module (
+`hello_tests.py`) and create a unittest skeleton there::
+
+    import unittest
+    import hello
+
+    class HelloWorldTestCase(unittest.TestCase):
+
+        def setUp(self):
+            self.app = hello.app.test_client()
+
+    if __name__ == '__main__':
+        unittest.main()
+
+The code in the `setUp` function creates a new test client.  That function
+is called before each individual test function.  What the test client does
+for us is giving us a simple interface to the application.  We can trigger
+test requests to the application and the client will also keep track of
+cookies for us.
+
+If we now run that testsuite, we should see the following output::
+
+    $ python hello_tests.py
+
+    ----------------------------------------------------------------------
+    Ran 0 tests in 0.000s
+    
+    OK
+
+Even though it did not run any tests, we already know that our hello
+application is syntactically valid, otherwise the import would have died
+with an exception.
+
+The First Test
+--------------
+
+Now we can add the first test.  Let's check that the application greets us
+with ""Hello World"" if we access it on ``/``.  For that we modify our
+created test case class so that it looks like this::
+
+    class HelloWorldTestCase(unittest.TestCase):
+
+        def setUp(self):
+            self.app = hello.app.test_client()
+
+        def test_hello_world(self):
+            rv = self.app.get('/')
+            assert 'Hello World!' in rv.data
+
+Test functions begin with the word `test`.  Every function named like that
+will be picked up automatically.  By using `self.app.get` we can send an
+HTTP `GET` request to the application with the given path.  The return
+value will be a :class:`~flask.Flask.response_class` object.  We can now
+use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
+return value (as string) from the application.  In this case, we ensure
+that ``'Hello World!'`` is part of the output.
+
+Run it again and you should see one passing test.  Let's add a second test
+here::
+
+        def test_hello_name(self):
+            rv = self.app.get('/Peter')
+            assert 'Hello Peter!' in rv.data
+
+Of course you can submit forms with the test client as well.  For that and
+other features of the test client, check the documentation of the Werkzeug
+test :class:`~werkzeug.Client` and the tests of the MiniTwit example
+application:
+
+-   Werkzeug Test :class:`~werkzeug.Client`
+-   `MiniTwit Example`_
+
+.. _MiniTwit Example:
+   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
",add a test skeleton for the application,add a test skeleton for the application,add a test skeleton for the application,llm_rectified,0.0,7,False,100.0,0,0,0,0,0,-100.0,0,0
2f5a4f8dbc832b0daebcd66ea8b3969589191fa7,Doc updates and typo fixes,README,"
                        / MiniTwit /

           because writing todo lists is not fun


    ~ What is MiniTwit?

      A SQLite and Flask powered twitter clone

    ~ How do I use it?

      1. edit the configurtion in the minitwit.py file

      2. fire up a python shell and run this:

         >>> from minitwit import init_db; init_db()

      3. now you can run the minitwit.py file with your
         python interpreter and the application will
         greet you on http://localhost:5000/
	
    ~ Is it tested?

      You betcha.  Run the `minitwit_tests.py` file to
      see the tests pass.
","
                        / MiniTwit /

           because writing todo lists is not fun


    ~ What is MiniTwit?

      A SQLite and Flask powered twitter clone

    ~ How do I use it?

      1. edit the configuration in the minitwit.py file

      2. fire up a python shell and run this:

         >>> from minitwit import init_db; init_db()

      3. now you can run the minitwit.py file with your
         python interpreter and the application will
         greet you on http://localhost:5000/
	
    ~ Is it tested?

      You betcha.  Run the `minitwit_tests.py` file to
      see the tests pass.
","@@ -10,7 +10,7 @@
 
     ~ How do I use it?
 
-      1. edit the configurtion in the minitwit.py file
+      1. edit the configuration in the minitwit.py file
 
       2. fire up a python shell and run this:
 
",add more info to minitwit_tests.py,add more info to minitwit_tests.py,add more info to minitwit_tests.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
2f5a4f8dbc832b0daebcd66ea8b3969589191fa7,Doc updates and typo fixes,minitwit.py,"# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new database connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.request_init
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.request_shutdown
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    offset = request.args.get('offset', type=int)
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followd = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.request_init
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.request_shutdown
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    offset = request.args.get('offset', type=int)
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followd = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","@@ -31,7 +31,7 @@ app = Flask(__name__)
 
 
 def connect_db():
-    """"""Returns a new database connection to the database.""""""
+    """"""Returns a new connection to the database.""""""
     return sqlite3.connect(DATABASE)
 
 
@@ -52,19 +52,19 @@ def query_db(query, args=(), one=False):
 
 
 def get_user_id(username):
-    """"""Convenience method to look up the id for a username""""""
+    """"""Convenience method to look up the id for a username.""""""
     rv = g.db.execute('select user_id from user where username = ?',
                        [username]).fetchone()
     return rv[0] if rv else None
 
 
 def format_datetime(timestamp):
-    """"""Format a timestamp for display""""""
+    """"""Format a timestamp for display.""""""
     return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')
 
 
 def gravatar_url(email, size=80):
-    """"""Return the gravatar image for the given email address""""""
+    """"""Return the gravatar image for the given email address.""""""
     return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
         (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)
 
@@ -138,7 +138,7 @@ def user_timeline(username):
 
 @app.route('/<username>/follow')
 def follow_user(username):
-    """"""Adds the current user as follower of the given user""""""
+    """"""Adds the current user as follower of the given user.""""""
     if not g.user:
         abort(401)
     whom_id = get_user_id(username)
@@ -153,7 +153,7 @@ def follow_user(username):
 
 @app.route('/<username>/unfollow')
 def unfollow_user(username):
-    """"""Removes the current user as follower of the given user""""""
+    """"""Removes the current user as follower of the given user.""""""
     if not g.user:
         abort(401)
     whom_id = get_user_id(username)
@@ -168,7 +168,7 @@ def unfollow_user(username):
 
 @app.route('/add_message', methods=['POST'])
 def add_message():
-    """"""Registers a new message for the user""""""
+    """"""Registers a new message for the user.""""""
     if 'user_id' not in session:
         abort(401)
     if request.form['text']:
@@ -182,7 +182,7 @@ def add_message():
 
 @app.route('/login', methods=['GET', 'POST'])
 def login():
-    """"""Logs the user in""""""
+    """"""Logs the user in.""""""
     if g.user:
         return redirect(url_for('timeline'))
     error = None
@@ -203,7 +203,7 @@ def login():
 
 @app.route('/register', methods=['GET', 'POST'])
 def register():
-    """"""Registers the user""""""
+    """"""Registers the user.""""""
     if g.user:
         return redirect(url_for('timeline'))
     error = None
",add missing docstrings,add missing docstrings,add missing docstrings,llm_rectified,0.0,3,False,48.73457184659348,48.73457184659348,44,44,250,250,0.0,0,0
2f5a4f8dbc832b0daebcd66ea8b3969589191fa7,Doc updates and typo fixes,timeline.html,"{% extends ""layout.html"" %}
{% block title %}
  {% if request.endpoint == 'public_timeline' %}
    Public Timeline
  {% elif request.endpoint == 'user_timeline' %}
    {{ profile_user.username }}'s Timeline
  {% else %}
    My Timeline
  {% endif %}
{% endblock %}
{% block body %}
  <h2>{{ self.title() }}</h2>
  {% if g.user %}
    {% if request.endpoint == 'user_timeline' %}
      <div class=followstatus>
      {% if g.user.user_id == profile_user.user_id %}
        This is you!
      {% elif followed %}
        You are currently following this user.
        <a class=unfollow href=""{{ url_for('unfollow_user', username=profile_user.username)
          }}"">Unfollow user</a>.
      {% else %}
        You are not yet following this user.
        <a class=follow href=""{{ url_for('follow_user', username=profile_user.username)
          }}"">Follow user</a>.
      {% endif %}
      </div>
    {% elif request.endpoint == 'timeline' %}
      <div class=twitbox>
        <h3>What's on your mind {{ g.user.username }}?</h3>
        <form action=""{{ url_for('add_message') }}"" method=post>
          <p><input type=text name=text size=60><!--
          --><input type=submit value=""Share"">
        </form>
      </div>
    {% endif %}
  {% endif %}
  <ul class=messages>
  {% for message in messages %}
    <li><img src=""{{ message.email|gravatar(size=48) }}""><p>
      <strong><a href=""{{ url_for('user_timeline', username=message.username)
      }}"">{{ message.username }}</a></strong>
      {{ message.text }}
      <small>&mdash; {{ message.pub_date|datetimeformat }}</small>
  {% else %}
    <li><em>There are no messages so far.</em>
  {% endfor %}
  </ul>
{% endblock %}
","{% extends ""layout.html"" %}
{% block title %}
  {% if request.endpoint == 'public_timeline' %}
    Public Timeline
  {% elif request.endpoint == 'user_timeline' %}
    {{ profile_user.username }}'s Timeline
  {% else %}
    My Timeline
  {% endif %}
{% endblock %}
{% block body %}
  <h2>{{ self.title() }}</h2>
  {% if g.user %}
    {% if request.endpoint == 'user_timeline' %}
      <div class=followstatus>
      {% if g.user.user_id == profile_user.user_id %}
        This is you!
      {% elif followed %}
        You are currently following this user.
        <a class=unfollow href=""{{ url_for('unfollow_user', username=profile_user.username)
          }}"">Unfollow user</a>.
      {% else %}
        You are not yet following this user.
        <a class=follow href=""{{ url_for('follow_user', username=profile_user.username)
          }}"">Follow user</a>.
      {% endif %}
      </div>
    {% elif request.endpoint == 'timeline' %}
      <div class=twitbox>
        <h3>What's on your mind {{ g.user.username }}?</h3>
        <form action=""{{ url_for('add_message') }}"" method=post>
          <p><input type=text name=text size=60><!--
          --><input type=submit value=""Share"">
        </form>
      </div>
    {% endif %}
  {% endif %}
  <ul class=messages>
  {% for message in messages %}
    <li><img src=""{{ message.email|gravatar(size=48) }}""><p>
      <strong><a href=""{{ url_for('user_timeline', username=message.username)
      }}"">{{ message.username }}</a></strong>
      {{ message.text }}
      <small>&mdash; {{ message.pub_date|datetimeformat }}</small>
  {% else %}
    <li><em>There's no message so far.</em>
  {% endfor %}
  </ul>
{% endblock %}
","@@ -43,7 +43,7 @@
       {{ message.text }}
       <small>&mdash; {{ message.pub_date|datetimeformat }}</small>
   {% else %}
-    <li><em>There are no messages so far.</em>
+    <li><em>There's no message so far.</em>
   {% endfor %}
   </ul>
 {% endblock %}
",add missing tags to the end of block,add missing tags to the end of block,add missing tags to the end of block,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
51c9829a9cdfa2bf301431f686d7a404cc7c5083,Fixed couple of errors in docs.,foreword.rst,"Foreword
========

Read this before you get started with Flask.  This hopefully answers some
questions about the intention of the project, what it aims at and when you
should or should not be using it.

What does Micro Mean?
---------------------

The micro in microframework for me means on the one hand being small in
size, complexity but on the other hand also that the complexity of the
applications that are written with these frameworks do not exceed a
certain size.  A microframework like Flask sacrifices a few things in
order to be approachable and to be as concise as possible.

For example Flask uses thread local objects internally so that you don't
have to pass objects around from function to function within a request in
order to stay threadsafe.  While this is a really easy approach and saves
you a lot of time, it also does not scale well to large applications.
It's especially painful for more complex unittests and when you suddenly
have to deal with code being executed outside of the context of a request
(for example if you have cronjobs).

Flask provides some tools to deal with the downsides of this approach but
the core problem of this approach obviously stays.  It is also based on
convention over configuration which means that a lot of things are
preconfigured in Flask and will work well for smaller applications but not
so much for larger ones (where and how it looks for templates, static
files etc.)

But don't worry if your application suddenly grows larger than it was
initially and you're afraid Flask might not grow with it.  Even with
larger frameworks you sooner or later will find out that you need
something the framework just cannot do for you without modification.
If you are ever in that situation, check out the :ref:`becomingbig`
chapter.

A Framework and An Example
--------------------------

Flask is not only a microframework, it is also an example.  Based on
Flask, there will be a series of blog posts that explain how to create a
framework.  Flask itself is just one way to implement a framework on top
of existing libraries.  Unlike many other microframeworks Flask does not
try to implement anything on its own, it reuses existing code.

Web Development is Dangerous
----------------------------

I'm not even joking.  Well, maybe a little.  If you write a web
application you are probably allowing users to register and leave their
data on your server.  The users are entrusting you with data.  And even if
you are the only user that might leave data in your application, you still
want that data to be stored in a secure manner.

Unfortunately there are many ways security of a web application can be
compromised.  Flask protects you against one of the most common security
problems of modern web applications: cross site scripting (XSS).  Unless
you deliberately mark insecure HTML as secure Flask (and the underlying
Jinja2 template engine) have you covered.  But there are many more ways to
cause security problems.

Whenever something is dangerous where you have to watch out, the
documentation will tell you so.  Some of the security concerns of web
development are far more complex than one might think and often we all end
up in situations where we think ""well, this is just far fetched, how could
that possibly be exploited"" and then an intelligent guy comes along and
figures a way out to exploit that application.  And don't think, your
application is not important enough for hackers to take notice.  Depending
ont he kind of attack, chances are there are automated botnets out there
trying to figure out how to fill your database with viagra adverisments.

So always keep that in mind when doing web development.

Target Audience
---------------

Is Flask for you?  Is your application small-ish (less than 4000 lines of
Python code) and does not depend on too complex database structures, Flask
is the Framework for you.  It was designed from the ground up to be easy
to use, based on established principles, good intentions and on top of two
established libraries in widespread usage.

Flask serves two purposes: it's an example of how to create a minimal and
opinionated framework on top of Werkzeug to show how this can be done, and
to provide people with a simple tool to prototype larger applications or
to implement small and medium sized applications.

If you suddenly discover that your application grows larger than
originally intended, head over to the :ref:`becomingbig` section to see
some possible solutions for larger applications.

Satisfied?  Then head over to the :ref:`installation`.
","Foreword
========

Read this before you get started with Flask.  This hopefully answers some
questions about the intention of the project, what it aims at and when you
should or should not be using it.

What does Micro Mean?
---------------------

The micro in microframework for me means on the one hand being small in
size and complexity but on the other hand also that the complexity of the
applications that are written with these frameworks do not exceed a
certain size.  A microframework like Flask sacrifices a few things in
order to be approachable and to be as concise as possible.

For example Flask uses thread local objects internally so that you don't
have to pass objects around from function to function within a request in
order to stay threadsafe.  While this is a really easy approach and saves
you a lot of time, it also does not scale well to large applications.
It's especially painful for more complex unittests and when you suddenly
have to deal with code being executed outside of the context of a request
(for example if you have cronjobs).

Flask provides some tools to deal with the downsides of this approach but
the core problem of this approach obviously stays.  It is also based on
convention over configuration which means that a lot of things are
preconfigured in Flask and will work well for smaller applications but not
so much for larger ones (where and how it looks for templates, static
files etc.)

But don't worry if your application suddenly grows larger than it was
initially and you're afraid Flask might not grow with it.  Even with
larger frameworks you sooner or later will find out that you need
something the framework just cannot do for you without modification.
If you are ever in that situation, check out the :ref:`becomingbig`
chapter.

A Framework and An Example
--------------------------

Flask is not only a microframework, it is also an example.  Based on
Flask, there will be a series of blog posts that explain how to create a
framework.  Flask itself is just one way to implement a framework on top
of existing libraries.  Unlike many other microframeworks Flask does not
try to implement anything on its own, it reuses existing code.

Web Development is Dangerous
----------------------------

I'm not even joking.  Well, maybe a little.  If you write a web
application you are probably allowing users to register and leave their
data on your server.  The users are entrusting you with data.  And even if
you are the only user that might leave data in your application, you still
want that data to be stored in a secure manner.

Unfortunately there are many ways security of a web application can be
compromised.  Flask protects you against one of the most common security
problems of modern web applications: cross site scripting (XSS).  Unless
you deliberately mark insecure HTML as secure Flask (and the underlying
Jinja2 template engine) have you covered.  But there are many more ways to
cause security problems.

Whenever something is dangerous where you have to watch out, the
documentation will tell you so.  Some of the security concerns of web
development are far more complex than one might think and often we all end
up in situations where we think ""well, this is just far fetched, how could
that possibly be exploited"" and then an intelligent guy comes along and
figures a way out to exploit that application.  And don't think, your
application is not important enough for hackers to take notice.  Depending
ont he kind of attack, chances are there are automated botnets out there
trying to figure out how to fill your database with viagra adverisments.

So always keep that in mind when doing web development.

Target Audience
---------------

Is Flask for you?  Is your application small-ish (less than 4000 lines of
Python code) and does not depend on too complex database structures, Flask
is the Framework for you.  It was designed from the ground up to be easy
to use, based on established principles, good intentions and on top of two
established libraries in widespread usage.

Flask serves two purposes: it's an example of how to create a minimal and
opinionated framework on top of Werkzeug to show how this can be done, and
to provide people with a simple tool to prototype larger applications or
to implement small and medium sized applications.

If you suddenly discover that your application grows larger than
originally intended, head over to the :ref:`becomingbig` section to see
some possible solutions for larger applications.

Satisfied?  Then head over to the :ref:`installation`.
","@@ -9,7 +9,7 @@ What does Micro Mean?
 ---------------------
 
 The micro in microframework for me means on the one hand being small in
-size, complexity but on the other hand also that the complexity of the
+size and complexity but on the other hand also that the complexity of the
 applications that are written with these frameworks do not exceed a
 certain size.  A microframework like Flask sacrifices a few things in
 order to be approachable and to be as concise as possible.
",add more info about application/application_config.py,add more info about application/application_config.py,add more info about application/application_config.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
51c9829a9cdfa2bf301431f686d7a404cc7c5083,Fixed couple of errors in docs.,index.rst,"Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :align: right

Welcome to Flask's documentation.  This documentation is divided into
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   patterns
   api
   deploying
   testing
   becomingbig
","Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :align: right

Welcome to Flask's documentation.  This documentation is divided in
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.  If
you want to dive into all the internal parts of Flask, check out the
:ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   patterns
   api
   deploying
   testing
   becomingbig
","@@ -5,7 +5,7 @@ Welcome to Flask
    :alt: The Flask Logo with Subtitle
    :align: right
 
-Welcome to Flask's documentation.  This documentation is divided into
+Welcome to Flask's documentation.  This documentation is divided in
 different parts.  I would suggest to get started with the
 :ref:`installation` and then heading over to the :ref:`quickstart`.  If
 you want to dive into all the internal parts of Flask, check out the
",add more examples to the nparity docs,add more examples to the nparity docs,add more examples to the nparity docs,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
51c9829a9cdfa2bf301431f686d7a404cc7c5083,Fixed couple of errors in docs.,installation.rst,".. _installation:

Installation
============

Flask is a microframework and yet it depends on external libraries.  There
are various ways how you can install that library and this explains each
way and why there are multiple ways.

Flask depends on two external libraries: `Werkzeug
<http://werkzeug.pocoo.org/>`_ and `Jinja2 <http://jinja.pocoo.org/2/>`_.
The first on is responsible for interfacing WSGI the latter to render
templates.  Now you are maybe asking, what is WSGI?  WSGI is a standard
in Python that is basically responsible for ensuring that your application
is behaving in a specific way that you can run it on different
environments (for example on a local development server, on an Apache2, on
lighttpd, on Google's appengine or whatever you have in mind).

So how do you get all that on your computer in no time?  The most kick-ass
method is virtualenv, so let's look at that first.

virtualenv
----------

Virtualenv is what you want to use during development and in production if
you have shell access.  So first: what does virtualenv do?  If you are
like me and you like Python, chances are you want to use it for another
project as well.  Now the more projects you have, the more likely it is
that you will be working with different versions of Python itself or a
library involved.  Because let's face it: quite often libraries break
backwards compatibility and it's unlikely that your application will
not have any dependencies, that just won't happen.  So virtualenv for the
rescue!

It basically makes it possible to have multiple side-by-side
""installations"" of Python, each for your own project.  It's not actually
an installation but a clever way to keep things separated.

So let's see how that works!

If you are on OS X or Linux chances are that one of the following two
commands will for for you::

    $ sudo easy_install virtualenv

or even better::

    $ sudo pip install virtualenv

Changes are you have virtualenv installed on your system then.  Maybe it's
even in your package manager (on ubuntu try ``sudo apt-get install
python-virtualenv``).

If you are on Windows and missing the `easy_install` command you have to
install it first.  Check the :ref:`windows-easy-install` section for more
information about how to do that.

So now that you have virtualenv running just fire up a shell and create
your own environment.  I usually create a folder and a `env` folder
within::

    $ mkdir myproject
    $ cd myproject
    $ virtualenv env
    New python executable in env/bin/python
    Installing setuptools............done.

Now you only have to activate it, whenever you work with it.  On OS X and
Linux do the following::

    $ source env/bin/activate

If you are a Windows user, the following command is for you::

    $ env\scripts\activate

Either way, you should now be using your virtualenv (see how the prompt of
your shell has changed to show the virtualenv).

Now you can just enter the following command to get Flask activated in
your virtualenv::

    $ easy_install Flask

A few seconds later you are good to go.


System Wide Installation
------------------------

This is possible as well, but I would not recommend it.  Just run
`easy_install` with root rights::

    sudo easy_install Flask

(Run it in an Admin shell on Windows systems and without the `sudo`). 


The Drop into Place Version
---------------------------

Now I really don't recommend this way on using Flask, but you can do that
of course as well.  Download the `dip` zipfile from the website and unzip
it next to your application.

.. _windows-easy-install:

`easy_install` on Windows
-------------------------

On Windows installation of `easy_install` is a little bit tricker because
on Windows slightly different rules apply, but it's not a biggy.  The
easiest way to accomplish that is downloading the `ez_setup.py`_ file and
running it.  (Double clicking should do the trick)

Once you have done that it's important to add the `easy_install` command
and other Python scripts to the path.  To do that you have to add the
Python installation's Script folder to the `PATH` variable.

To do that, click right on your ""Computer"" desktop icon and click
""Properties"".  On Windows Vista and Windows 7 then click on ""Advanced System
settings"", on Windows XP click on the ""Advanced"" tab instead.  Then click
on the ""Environment variables"" button and double click on the ""Path""
variable in the ""System variables"" section.

There append the path of your Python interpreter's Script folder to the
end of the last (make sure you delimit it from existing values with a
semicolon).  Assuming you are using Python 2.6 on the default path, add
the following value::

    ;C:\Python26\Scripts

Then you are done.  To check if it worked, open the cmd and execute
""easy_install"".  If you have UAC enabled it should prompt you for admin
privileges.


.. _ez_setup.py: http://peak.telecommunity.com/dist/ez_setup.py
",".. _installation:

Installation
============

Flask is a microframework and yet it depends on external libraries.  There
are various ways how you can install that library and this explains each
way and why there are multiple ways.

Flask depends on two external libraries: `Werkzeug
<http://werkzeug.pocoo.org/>`_ and `Jinja2 <http://jinja.pocoo.org/2/>`_.
The first on is responsible for interfacing WSGI the latter to render
templates.  Now you are maybe asking, what is WSGI?  WSGI is a standard
in Python that is basically responsible for ensuring that your application
is behaving in a specific way that you can run it on different
environments (for example on a local development server, on an Apache2, on
lighttpd, on Google's App Engine or whatever you have in mind).

So how do you get all that on your computer in no time?  The most kick-ass
method is virtualenv, so let's look at that first.

virtualenv
----------

Virtualenv is what you want to use during development and in production if
you have shell access.  So first: what does virtualenv do?  If you are
like me and you like Python, chances are you want to use it for another
project as well.  Now the more projects you have, the more likely it is
that you will be working with different versions of Python itself or a
library involved.  Because let's face it: quite often libraries break
backwards compatibility and it's unlikely that your application will
not have any dependencies, that just won't happen.  So virtualenv for the
rescue!

It basically makes it possible to have multiple side-by-side
""installations"" of Python, each for your own project.  It's not actually
an installation but a clever way to keep things separated.

So let's see how that works!

If you are on OS X or Linux chances are that one of the following two
commands will for for you::

    $ sudo easy_install virtualenv

or even better::

    $ sudo pip install virtualenv

Changes are you have virtualenv installed on your system then.  Maybe it's
even in your package manager (on ubuntu try ``sudo apt-get install
python-virtualenv``).

If you are on Windows and missing the `easy_install` command you have to
install it first.  Check the :ref:`windows-easy-install` section for more
information about how to do that.

So now that you have virtualenv running just fire up a shell and create
your own environment.  I usually create a folder and a `env` folder
within::

    $ mkdir myproject
    $ cd myproject
    $ virtualenv env
    New python executable in env/bin/python
    Installing setuptools............done.

Now you only have to activate it, whenever you work with it.  On OS X and
Linux do the following::

    $ source env/bin/activate

If you are a Windows user, the following command is for you::

    $ env\scripts\activate

Either way, you should now be using your virtualenv (see how the prompt of
your shell has changed to show the virtualenv).

Now you can just enter the following command to get Flask activated in
your virtualenv::

    $ easy_install Flask

A few seconds later you are good to go.


System Wide Installation
------------------------

This is possible as well, but I would not recommend it.  Just run
`easy_install` with root rights::

    sudo easy_install Flask

(Run it in an Admin shell on Windows systems and without the `sudo`).


The Drop into Place Version
---------------------------

Now I really don't recommend this way on using Flask, but you can do that
of course as well.  Download the `dip` zipfile from the website and unzip
it next to your application.

.. _windows-easy-install:

`easy_install` on Windows
-------------------------

On Windows installation of `easy_install` is a little bit tricker because
on Windows slightly different rules apply, but it's not a biggy.  The
easiest way to accomplish that is downloading the `ez_setup.py`_ file and
running it.  (Double clicking should do the trick)

Once you have done that it's important to add the `easy_install` command
and other Python scripts to the path.  To do that you have to add the
Python installation's Script folder to the `PATH` variable.

To do that, click right on your ""Computer"" desktop icon and click
""Properties"".  On Windows Vista and Windows 7 then click on ""Advanced System
settings"", on Windows XP click on the ""Advanced"" tab instead.  Then click
on the ""Environment variables"" button and double click on the ""Path""
variable in the ""System variables"" section.

There append the path of your Python interpreter's Script folder to the
end of the last (make sure you delimit it from existing values with a
semicolon).  Assuming you are using Python 2.6 on the default path, add
the following value::

    ;C:\Python26\Scripts

Then you are done.  To check if it worked, open the cmd and execute
""easy_install"".  If you have UAC enabled it should prompt you for admin
privileges.


.. _ez_setup.py: http://peak.telecommunity.com/dist/ez_setup.py
","@@ -14,7 +14,7 @@ templates.  Now you are maybe asking, what is WSGI?  WSGI is a standard
 in Python that is basically responsible for ensuring that your application
 is behaving in a specific way that you can run it on different
 environments (for example on a local development server, on an Apache2, on
-lighttpd, on Google's appengine or whatever you have in mind).
+lighttpd, on Google's App Engine or whatever you have in mind).
 
 So how do you get all that on your computer in no time?  The most kick-ass
 method is virtualenv, so let's look at that first.
@@ -93,7 +93,7 @@ This is possible as well, but I would not recommend it.  Just run
 
     sudo easy_install Flask
 
-(Run it in an Admin shell on Windows systems and without the `sudo`). 
+(Run it in an Admin shell on Windows systems and without the `sudo`).
 
 
 The Drop into Place Version
",add more info about virtualenv and vendor,add more info about virtualenv and vendor,add more info about virtualenv and vendor,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
a01e8b49ca66608f0bd46134ff02deeb5724c799,Fixed a documentation error and implemented template context processors.,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
import os
import sys
import pkg_resources
from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []
        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        context['request'] = reqctx.request
        context['session'] = reqctx.session
        context['g'] = reqctx.g

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path:   (self.package_name, 'static')
            }
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param request: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
import os
import sys
import pkg_resources
from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path:   (self.package_name, 'static')
            }
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -130,6 +130,18 @@ def render_template_string(source, **context):
     return current_app.jinja_env.from_string(source).render(context)
 
 
+def _default_template_ctx_processor():
+    """"""Default template context processor.  Injects `request`,
+    `session` and `g`.
+    """"""
+    reqctx = _request_ctx_stack.top
+    return dict(
+        request=reqctx.request,
+        session=reqctx.session,
+        g=reqctx.g
+    )
+
+
 class Flask(object):
     """"""The flask object implements a WSGI application and acts as the central
     object.  It is passed the name of the module or package of the
@@ -216,6 +228,14 @@ class Flask(object):
         #: To register a function here use the :meth:`request_shtdown`
         #: decorator.
         self.request_shutdown_funcs = []
+
+        #: a list of functions that are called without arguments
+        #: to populate the template context.  Each returns a dictionary
+        #: that the template context is updated with.
+        #: To register a function here, use the :meth:`context_processor`
+        #: decorator.
+        self.template_context_processors = [_default_template_ctx_processor]
+
         self.url_map = Map()
 
         if self.static_path is not None:
@@ -248,9 +268,8 @@ class Flask(object):
                         to add extra variables.
         """"""
         reqctx = _request_ctx_stack.top
-        context['request'] = reqctx.request
-        context['session'] = reqctx.session
-        context['g'] = reqctx.g
+        for func in self.template_context_processors:
+            context.update(func())
 
     def run(self, host='localhost', port=5000, **options):
         """"""Runs the application on a local development server.  If the
@@ -325,7 +344,7 @@ class Flask(object):
         :param session: the session to be saved (a
                         :class:`~werkzeug.contrib.securecookie.SecureCookie`
                         object)
-        :param request: an instance of :attr:`response_class`
+        :param response: an instance of :attr:`response_class`
         """"""
         if session is not None:
             session.save_cookie(response, self.session_cookie_name)
@@ -462,6 +481,11 @@ class Flask(object):
         self.request_shutdown_funcs.append(f)
         return f
 
+    def context_processor(self, f):
+        """"""Registers a template context processor function.""""""
+        self.template_context_processors.append(f)
+        return f
+
     def match_request(self):
         """"""Matches the current request against the URL map and also
         stores the endpoint and view arguments on the request object
",add more documentation to flask.py,add more documentation to flask.py,add more documentation to flask.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
8009bd986940378bba1399dbfce90d03e441467b,Fixed the mod_wsgi docs. Thanks Graham,deploying.rst,"Deployment Options
==================

Depending on what you have available there are multiple ways to run Flask
applications.  A very common method is to use the builtin server during
development and maybe behind a proxy for simple applications, but there
are more options available.

If you have a different WSGI server look up the server documentation about
how to use a WSGI app with it.  Just remember that your application object
is the actual WSGI application.


FastCGI
-------

A very popular deployment setup on servers like `lighttpd`_ and `nginx`_
is FastCGI.  To use your WSGI application with any of them you will need
a FastCGI server first.

The most popular one is `flup`_ which we will use for this guide.  Make
sure to have it installed.

Creating a `.fcgi` file
```````````````````````

First you need to create the FastCGI server file.  Let's call it
`yourapplication.fcgi`::

    #!/usr/bin/python
    from flup.server.fcgi import WSGIServer
    from yourapplication import app

    WSGIServer(app).run()

This is enough for Apache to work, however lighttpd and nginx need a
socket to communicate with the FastCGI server.  For that to work you
need to pass the path to the socket to the
:class:`~flup.server.fcgi.WSGIServer`::

    WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()

The path has to be the exact same path you define in the server
config.

Save the `yourapplication.fcgi` file somewhere you will find it again.
It makes sense to have that in `/var/www/yourapplication` or something
similar.

Make sure to set the executable bit on that file so that the servers
can execute it::

    # chmod +x /var/www/yourapplication/yourapplication.fcgi

Configuring lighttpd
````````````````````

A basic FastCGI configuration for lighttpd looks like that::

    fastcgi.server = (""/yourapplication"" =>
        ""yourapplication"" => (
            ""socket"" => ""/tmp/yourapplication-fcgi.sock"",
            ""bin-path"" => ""/var/www/yourapplication/yourapplication.fcgi"",
            ""check-local"" => ""disable""
        )
    )

This configuration binds the application to `/yourapplication`.  If you
want the application to work in the URL root you have to work around a
lighttpd bug with the :class:`~werkzeug.contrib.fixers.LighttpdCGIRootFix`
middleware.

Make sure to apply it only if you are mounting the application the URL
root.

Configuring nginx
`````````````````

Installing FastCGI applications on nginx is a bit tricky because by default
some FastCGI parameters are not properly forwarded.

A basic FastCGI configuration for nginx looks like this::

    location /yourapplication/ {
        include fastcgi_params;
        if ($uri ~ ^/yourapplication/(.*)?) {
            set $path_url $1;
        }
        fastcgi_param PATH_INFO $path_url;
        fastcgi_param SCRIPT_NAME /yourapplication;
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

This configuration binds the application to `/yourapplication`.  If you want
to have it in the URL root it's a bit easier because you don't have to figure
out how to calculate `PATH_INFO` and `SCRIPT_NAME`::

    location /yourapplication/ {
        include fastcgi_params;
        fastcgi_param PATH_INFO $fastcgi_script_name;
        fastcgi_param SCRIPT_NAME """";
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

Since Nginx doesn't load FastCGI apps, you have to do it by yourself.  You
can either write an `init.d` script for that or execute it inside a screen
session::

    $ screen
    $ /var/www/yourapplication/yourapplication.fcgi

Debugging
`````````

FastCGI deployments tend to be hard to debug on most webservers.  Very often the
only thing the server log tells you is something along the lines of ""premature
end of headers"".  In order to debug the application the only thing that can
really give you ideas why it breaks is switching to the correct user and
executing the application by hand.

This example assumes your application is called `application.fcgi` and that your
webserver user is `www-data`::

    $ su www-data
    $ cd /var/www/yourapplication
    $ python application.fcgi
    Traceback (most recent call last):
      File ""yourapplication.fcg"", line 4, in <module>
    ImportError: No module named yourapplication

In this case the error seems to be ""yourapplication"" not being on the python
path.  Common problems are:

-   relative paths being used.  Don't rely on the current working directory
-   the code depending on environment variables that are not set by the
    web server.
-   different python interpreters being used.

.. _lighttpd: http://www.lighttpd.net/
.. _nginx: http://nginx.net/
.. _flup: http://trac.saddi.com/flup


mod_wsgi (Apache)
-----------------

If you are using the `Apache`_ webserver you should consider using `mod_wsgi`_.

.. _Apache: http://httpd.apache.org/

Installing `mod_wsgi`
`````````````````````

If you don't have `mod_wsgi` installed yet you have to either install it using
a package manager or compile it yourself.

The mod_wsgi `installation instructions`_ cover installation instructions for
source installations on UNIX systems.

If you are using ubuntu / debian you can apt-get it and activate it as follows::

    # apt-get install libapache2-mod-wsgi

On FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using
pkg_add::

    # pkg_add -r mod_wsgi

If you are using pkgsrc you can install `mod_wsgi` by compiling the
`www/ap2-wsgi` package.

If you encounter segfaulting child processes after the first apache reload you
can safely ignore them.  Just restart the server.

Creating a `.wsgi` file
```````````````````````

To run your application you need a `yourapplication.wsgi` file.  This file
contains the code `mod_wsgi` is executing on startup to get the application
object.  The object called `application` in that file is then used as
application.

For most applications the following file should be sufficient::

    from yourapplication import app as application

If you don't have a factory function for application creation but a singleton
instance you can directly import that one as `application`.

Store that file somewhere where you will find it again (eg:
`/var/www/yourapplication`) and make sure that `yourapplication` and all
the libraries that are in use are on the python load path.  If you don't
want to install it system wide consider using a `virtual python`_ instance.

Configuring Apache
``````````````````

The last thing you have to do is to create an Apache configuration file for
your application.  In this example we are telling `mod_wsgi` to execute the
application under a different user for security reasons:

.. sourcecode:: apache

    <VirtualHost *>
        ServerName example.com

        WSGIDaemonProcess yourapplication user=user1 group=group1 processes=1 threads=5
        WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi

        <Directory /var/www/yourapplication>
            WSGIProcessGroup yourapplication
            WSGIApplicationGroup %{GLOBAL}
            Order deny,allow
            Allow from all
        </Directory>
    </VirtualHost>

For more information consult the `mod_wsgi wiki`_.

.. _mod_wsgi: http://code.google.com/p/modwsgi/
.. _installation instructions: http://code.google.com/p/modwsgi/wiki/QuickInstallationGuide
.. _virtual python: http://pypi.python.org/pypi/virtualenv
.. _mod_wsgi wiki: http://code.google.com/p/modwsgi/wiki/



Tornado
--------

`Tornado`_ is an open source version of the scalable, non-blocking web server and tools that power `FriendFeed`_.
Because it is non-blocking and uses epoll, it can handle thousands of simultaneous standing connections, which means it is ideal for real-time web services.
Integrating this service with Flask is a trivial task::

    
    from tornado.wsgi import WSGIContainer
    from tornado.httpserver import HTTPServer
    from tornado.ioloop import IOLoop
    from yourapplication import app
    
    http_server = HTTPServer(WSGIContainer(app))
    http_server.listen(5000)
    IOLoop.instance().start()


.. _Tornado: http://www.tornadoweb.org/
.. _FriendFeed: http://friendfeed.com/


Gevent
-------

`Gevent`_ is a coroutine-based Python networking library that uses `greenlet`_ to provide a high-level synchronous API on top of `libevent`_ event loop::

    from gevent.wsgi import WSGIServer
    from yourapplication import app

    http_server = WSGIServer(('', 5000), app)
    http_server.serve_forever()

.. _Gevent: http://www.gevent.org/
.. _greenlet: http://codespeak.net/py/0.9.2/greenlet.html
.. _libevent: http://monkey.org/~provos/libevent/

CGI
---

If all other deployment methods do not work, CGI will work for sure.  CGI
is supported by all major browsers but usually has a less-than-optimal
performance.

This is also the way you can use a Flask application on Google's
`AppEngine`_, there however the execution does happen in a CGI-like
environment.  The application's performance is unaffected because of that.

.. _AppEngine: http://code.google.com/appengine/

Creating a `.cgi` file
``````````````````````

First you need to create the CGI application file.  Let's call it
`yourapplication.cgi`::

    #!/usr/bin/python
    from wsgiref.handlers import CGIHandler
    from yourapplication import app

    CGIHandler().run(app)

If you're running Python 2.4 you will need the :mod:`wsgiref` package.  Python
2.5 and higher ship this as part of the standard library.

Server Setup
````````````

Usually there are two ways to configure the server.  Either just copy the
`.cgi` into a `cgi-bin` (and use `mod_rerwite` or something similar to
rewrite the URL) or let the server point to the file directly.

In Apache for example you can put a like like this into the config:

.. sourcecode:: apache

    ScriptName /app /path/to/the/application.cgi

For more information consult the documentation of your webserver.

","Deployment Options
==================

Depending on what you have available there are multiple ways to run Flask
applications.  A very common method is to use the builtin server during
development and maybe behind a proxy for simple applications, but there
are more options available.

If you have a different WSGI server look up the server documentation about
how to use a WSGI app with it.  Just remember that your application object
is the actual WSGI application.


FastCGI
-------

A very popular deployment setup on servers like `lighttpd`_ and `nginx`_
is FastCGI.  To use your WSGI application with any of them you will need
a FastCGI server first.

The most popular one is `flup`_ which we will use for this guide.  Make
sure to have it installed.

Creating a `.fcgi` file
```````````````````````

First you need to create the FastCGI server file.  Let's call it
`yourapplication.fcgi`::

    #!/usr/bin/python
    from flup.server.fcgi import WSGIServer
    from yourapplication import app

    WSGIServer(app).run()

This is enough for Apache to work, however lighttpd and nginx need a
socket to communicate with the FastCGI server.  For that to work you
need to pass the path to the socket to the
:class:`~flup.server.fcgi.WSGIServer`::

    WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()

The path has to be the exact same path you define in the server
config.

Save the `yourapplication.fcgi` file somewhere you will find it again.
It makes sense to have that in `/var/www/yourapplication` or something
similar.

Make sure to set the executable bit on that file so that the servers
can execute it::

    # chmod +x /var/www/yourapplication/yourapplication.fcgi

Configuring lighttpd
````````````````````

A basic FastCGI configuration for lighttpd looks like that::

    fastcgi.server = (""/yourapplication"" =>
        ""yourapplication"" => (
            ""socket"" => ""/tmp/yourapplication-fcgi.sock"",
            ""bin-path"" => ""/var/www/yourapplication/yourapplication.fcgi"",
            ""check-local"" => ""disable""
        )
    )

This configuration binds the application to `/yourapplication`.  If you
want the application to work in the URL root you have to work around a
lighttpd bug with the :class:`~werkzeug.contrib.fixers.LighttpdCGIRootFix`
middleware.

Make sure to apply it only if you are mounting the application the URL
root.

Configuring nginx
`````````````````

Installing FastCGI applications on nginx is a bit tricky because by default
some FastCGI parameters are not properly forwarded.

A basic FastCGI configuration for nginx looks like this::

    location /yourapplication/ {
        include fastcgi_params;
        if ($uri ~ ^/yourapplication/(.*)?) {
            set $path_url $1;
        }
        fastcgi_param PATH_INFO $path_url;
        fastcgi_param SCRIPT_NAME /yourapplication;
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

This configuration binds the application to `/yourapplication`.  If you want
to have it in the URL root it's a bit easier because you don't have to figure
out how to calculate `PATH_INFO` and `SCRIPT_NAME`::

    location /yourapplication/ {
        include fastcgi_params;
        fastcgi_param PATH_INFO $fastcgi_script_name;
        fastcgi_param SCRIPT_NAME """";
        fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;
    }

Since Nginx doesn't load FastCGI apps, you have to do it by yourself.  You
can either write an `init.d` script for that or execute it inside a screen
session::

    $ screen
    $ /var/www/yourapplication/yourapplication.fcgi

Debugging
`````````

FastCGI deployments tend to be hard to debug on most webservers.  Very often the
only thing the server log tells you is something along the lines of ""premature
end of headers"".  In order to debug the application the only thing that can
really give you ideas why it breaks is switching to the correct user and
executing the application by hand.

This example assumes your application is called `application.fcgi` and that your
webserver user is `www-data`::

    $ su www-data
    $ cd /var/www/yourapplication
    $ python application.fcgi
    Traceback (most recent call last):
      File ""yourapplication.fcg"", line 4, in <module>
    ImportError: No module named yourapplication

In this case the error seems to be ""yourapplication"" not being on the python
path.  Common problems are:

-   relative paths being used.  Don't rely on the current working directory
-   the code depending on environment variables that are not set by the
    web server.
-   different python interpreters being used.

.. _lighttpd: http://www.lighttpd.net/
.. _nginx: http://nginx.net/
.. _flup: http://trac.saddi.com/flup


mod_wsgi (Apache)
-----------------

If you are using the `Apache`_ webserver you should consider using `mod_wsgi`_.

.. _Apache: http://httpd.apache.org/

Installing `mod_wsgi`
`````````````````````

If you don't have `mod_wsgi` installed yet you have to either install it using
a package manager or compile it yourself.

The mod_wsgi `installation instructions`_ cover installation instructions for
source installations on UNIX systems.

If you are using ubuntu / debian you can apt-get it and activate it as follows::

    # apt-get install libapache2-mod-wsgi

On FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using
pkg_add::

    # pkg_add -r mod_wsgi

If you are using pkgsrc you can install `mod_wsgi` by compiling the
`www/ap2-wsgi` package.

If you encounter segfaulting child processes after the first apache reload you
can safely ignore them.  Just restart the server.

Creating a `.wsgi` file
```````````````````````

To run your application you need a `yourapplication.wsgi` file.  This file
contains the code `mod_wsgi` is executing on startup to get the application
object.  The object called `application` in that file is then used as
application.

For most applications the following file should be sufficient::

    from yourapplication import app as application

If you don't have a factory function for application creation but a singleton
instance you can directly import that one as `application`.

Store that file somewhere where you will find it again (eg:
`/var/www/yourapplication`) and make sure that `yourapplication` and all
the libraries that are in use are on the python load path.  If you don't
want to install it system wide consider using a `virtual python`_ instance.

Configuring Apache
``````````````````

The last thing you have to do is to create an Apache configuration file for
your application.  In this example we are telling `mod_wsgi` to execute the
application under a different user for security reasons:

.. sourcecode:: apache

    <VirtualHost *>
        ServerName example.com

        WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5
        WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi

        <Directory /var/www/yourapplication>
            WSGIProcessGroup yourapplication
            WSGIApplicationGroup %{GLOBAL}
            Order deny,allow
            Allow from all
        </Directory>
    </VirtualHost>

For more information consult the `mod_wsgi wiki`_.

.. _mod_wsgi: http://code.google.com/p/modwsgi/
.. _installation instructions: http://code.google.com/p/modwsgi/wiki/QuickInstallationGuide
.. _virtual python: http://pypi.python.org/pypi/virtualenv
.. _mod_wsgi wiki: http://code.google.com/p/modwsgi/wiki/



Tornado
--------

`Tornado`_ is an open source version of the scalable, non-blocking web server and tools that power `FriendFeed`_.
Because it is non-blocking and uses epoll, it can handle thousands of simultaneous standing connections, which means it is ideal for real-time web services.
Integrating this service with Flask is a trivial task::

    
    from tornado.wsgi import WSGIContainer
    from tornado.httpserver import HTTPServer
    from tornado.ioloop import IOLoop
    from yourapplication import app
    
    http_server = HTTPServer(WSGIContainer(app))
    http_server.listen(5000)
    IOLoop.instance().start()


.. _Tornado: http://www.tornadoweb.org/
.. _FriendFeed: http://friendfeed.com/


Gevent
-------

`Gevent`_ is a coroutine-based Python networking library that uses `greenlet`_ to provide a high-level synchronous API on top of `libevent`_ event loop::

    from gevent.wsgi import WSGIServer
    from yourapplication import app

    http_server = WSGIServer(('', 5000), app)
    http_server.serve_forever()

.. _Gevent: http://www.gevent.org/
.. _greenlet: http://codespeak.net/py/0.9.2/greenlet.html
.. _libevent: http://monkey.org/~provos/libevent/

CGI
---

If all other deployment methods do not work, CGI will work for sure.  CGI
is supported by all major browsers but usually has a less-than-optimal
performance.

This is also the way you can use a Flask application on Google's
`AppEngine`_, there however the execution does happen in a CGI-like
environment.  The application's performance is unaffected because of that.

.. _AppEngine: http://code.google.com/appengine/

Creating a `.cgi` file
``````````````````````

First you need to create the CGI application file.  Let's call it
`yourapplication.cgi`::

    #!/usr/bin/python
    from wsgiref.handlers import CGIHandler
    from yourapplication import app

    CGIHandler().run(app)

If you're running Python 2.4 you will need the :mod:`wsgiref` package.  Python
2.5 and higher ship this as part of the standard library.

Server Setup
````````````

Usually there are two ways to configure the server.  Either just copy the
`.cgi` into a `cgi-bin` (and use `mod_rerwite` or something similar to
rewrite the URL) or let the server point to the file directly.

In Apache for example you can put a like like this into the config:

.. sourcecode:: apache

    ScriptName /app /path/to/the/application.cgi

For more information consult the documentation of your webserver.

","@@ -204,7 +204,7 @@ application under a different user for security reasons:
     <VirtualHost *>
         ServerName example.com
 
-        WSGIDaemonProcess yourapplication user=user1 group=group1 processes=1 threads=5
+        WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5
         WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi
 
         <Directory /var/www/yourapplication>
",add documentation for the application options,add documentation for the application options,add documentation for the application options,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
c4f5c2fb9afc1679c085500830bd53fab93ad885,Fixed a typo,README,"
                         / Flaskr /

                 a minimal blog application


    ~ What is Flask?

      A sqlite powered thumble blog application

    ~ How do I use it?

      1. edit the configuration in the flaskr.py file

      2. fire up a python shell and run this:

         >>> from flaskr import init_db; init_db()

      3. now you can run the flaskr.py file with your
         python interpreter and the application will
         greet you on http://localhost:5000/
	
    ~ Is it tested?

      You betcha.  Run the `flaskr_tests.py` file to see
      the tests pass.
","
                         / Flaskr /

                 a minimal blog application


    ~ What is Flaskr?

      A sqlite powered thumble blog application

    ~ How do I use it?

      1. edit the configuration in the flaskr.py file

      2. fire up a python shell and run this:

         >>> from flaskr import init_db; init_db()

      3. now you can run the flaskr.py file with your
         python interpreter and the application will
         greet you on http://localhost:5000/
	
    ~ Is it tested?

      You betcha.  Run the `flaskr_tests.py` file to see
      the tests pass.
","@@ -4,7 +4,7 @@
                  a minimal blog application
 
 
-    ~ What is Flask?
+    ~ What is Flaskr?
 
       A sqlite powered thumble blog application
 
",add more documentation to the application_tests.py file,add more documentation to the application_tests.py file,add more documentation to the application_tests.py file,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
40e0024d7b87150ed694829a5335bd2435962225,"Added screenshot of the debugger to Flask docs.  Flask now runs from the
shell again.",debugger.png,,"PNG

   
IHDR    :   eh  IiCCPICC Profile  xYgXKKNK99GXsAI
$EQA$""""fAIQD2A|~wyywZ 	!!j ""¬ 
`H1<D07 :P?wg8 V{a| 61$, ,1aa<zQllt @3@BN y@˹ް
] 0AA 9XC >0r?	}߿	@	ׯnɃb?]B~X<lar73{[YDh`A^!6|t`L<G0>%,o1;ã`(h://_}6Z!L@  n88t_8X?q #ctM7{D61ǧ/9@w0pWcqlv	%AɡQj(uBQ,@%RDi4P*N	iس9l*U ,6/ 1> @'8$6'K޹b\FAD	1.)i gկ\_##l烷C߃
?2Ax߫pK8@Pfxe<P@s`~|5A<Hi d|P@%A#h! x
F8_
	!BqB($)Bt!7
""x(ʀrbnA-C	4&;@""v BB lGވPD""qQ@#/5$@!Hn8R4G:!ad:yyً|G.""7Q%SC-
E%2QŨjT5ZA)lhQ2FGUOb0G&s	Ӏa0kX,+UÚc	l[cg$d$$2$$N$A$$HjIIIHIIIII=HcIH'}A:C	p68?\w7[%##!S""$%;AVHvll\\ܙ<5NN(j(Q|ؠ4L,l\""Ңr@u""5) 5:-
49M M&M-yZ, m*m%#):$/.
cz }uZY;6q</77-FvF-FO37יX4<ҙ^3m1s113073dAXD<fYdgUa%6~`CYcdg[c`7`a/bľȁhXTU͵m]=#c˓ǫśŻgW_߇]@P^@ ``PP+a%AHQ%!1XX[qrq-(:		adfeI>I'^=)9 +R#ҴˈeJd^8(нCdEe=eKeəʝەW!pQ""bbZI[)QUiSY^9BQJʼ)55Zڸ:eq
n
FƤ&f朖Vֲv]ue:H]t=Z=[bO<u+r:
ц&9o؍F5F+
ǍMMMM&;|ajlztԌ,Ȭ7h!hjciaYb9k%mokMgj]kF&fV6Ҷˎٮn^>~A3GG_{NX';*#zG8999*x4 6W*Wm7[PAXs7rB!xhzy,xyzyyz{y^[Яo~}@C I[`KmPw0GpLPhHZxrh~JIXU8~4^=|8<9Um};&&(?V$L\~ccc]Iǵ'@		]3'NT''K%&HOʞz""uɺ4ʴTNF==pЙ3{O32.dd3>[xv׹,lLvP\ܸܩ~? { WY0^x^_QvNO풆l\\qiTF{YFe
ʛ**.Tb**g]齪x*jZеjZڬ:D]dBsun(o7d7#o~vMIcm7߹xnz۴<~PqK}wH<ZЖՎkOmX\|p˵kãWݖM<Sk}gϚ>{~w@~{JTڇ5}ճfؾy;wa{(z4#>U	5ˏMNOZOLLO̤R^㜫o]_|̗/ۋiK4K|ڿ2-Uk?dtY}s{=}yzSqw~kn;zS+{dot?p?Fu@-`sA p9/@
y>)@gY4J͎<ySQ2h㧘BXM*ؗ9ܸ<]0*&(! Y +HE\""re.1MF-ym[(+Fƻ}}}mEib#mklcڡڱiȪU	O-""gU﷾~ZσF;BC#\­""""FƦe+?~7Ab{I)U'Rr&/==DfsY9Q

YKh/_B]Z++\WYWitE*՟U>UL~Zr}hrn_tydz>V6TPՎ΀]N<>{f/sd`Ż'^:R|Mzۛ
ߟ139qSX8q`RbvtLl<B/!KKi+,+cVѳM_'Yɠ	4lvIlFC;a)
0 Ƞa]/23T.srp*ps
x""E^DUG,[]Lr
8E	%ceol
[ϵhL`hȸפpiYyEeUuMmE
*j#εG]6!w{|\Al

N	
WCueEU}kױxv	B'0I)s'G^8Lw̪dEez?gopA@_(Zs`Ki~e/K3V*ɮP\F_M_CWK[G[OseM[F$wPw64
5wݻRu⃂
]mz_?Y})n?40bipuhmxҫ/tx>Í?11=>456=02[11`Yƒ2ɕ߮|O_
3f_GoS68CP3|:OE
[M3%""DPQib`aO031{ȳXZ98-$)?<-7`l!$ &A-1#,*m""C%P\|bQY\yGePZƞsf:(gz&2Fh%L|oZ[ZvZ%ZP|w`vXtls<b<KmJ4`C޷n E `!mrPD_(h\tOLRzn\SuN|Hz|>*ry[ܩg32Gξ:ב=Sq^:7|! жHxdbӥ2ˇʙ+f+4^-JYWU]WF`C͸[WnYnogu?AZkA[M{GǇ.Gǃ>'Oß:pwOFOj-<X<;#@ GZM	  ,,Sg!6 /H90{K0	3=b UiopE$#/H##(
GM9Ў<
c<Œb!f""I̝*I7q:24<#>E#%y$SSޥII0[IO0 d<Xä4ɜ΢՗u;7mC.,W9Gf|,?z\EEOيx.Y#!!~ZV_NE^BOUIEGU\MEHFE[;Hn-7HӤS-saOk`dj/u͹ǅ*a(qsħUXPB`([XPxg$>*""M^H|KB	唴Rg:3l2gΥd挝/(P/b(^WU}YFWKwuZ\n{F`O_3/]_XTӬ߼g'~]wߦ!ncS~
խpS x Y&`,
s"".pko#K(,JG~c1l0uVbȓrF>p#ddr?W0m,ʦΣa}@gJ7Nɀbso110E217زl̱Ôc-76;_@0D:E]$$9$Ƥ;d*KT(PPQҪH/ڔ:""zz>_M{=YYXKv4trˮ/.a;;сuCnqD""WbVdRHS+ӔNqI_ʌ;*ν?PS^bYetysUizקn5޾~%@HNbB7O6͆f؈Gi/|K	_~0ĭmow1.\Iʃ x5ah
G#*HcsUZCϣg0ʘ\{ۧH6IIpI271r79JJz*K]4ZڧtC	xq$c)'56ovAy:`.%n,(=9~YAC!KaQ?dkR=KdK+euuv
F-C*}AἱIY|Mv@86q9tIv""Ox	i/E@Ǽ_MLjOr)3[2	Zy""sɋK7ˏW\u]U^}#M#}-쭃l<4c@y~heط?d|\+8279;9?YKbRr׎omWV~Dq5Tٽްqncuxbssb6߶]]]݇{L{{{M{N9}:$s 6\~*  6ݜJdt/.,?	\;CW   	pHYs         IDATx}w{]XzJDAc`DŖOGKF%Qcņ(*?g=wm x3gf}L͛0&&\:E@PE@PE  ^;m۶bp|btuu5|z-(""("" D6oTUU]PRR2VQE@PE@P6da555'H(,U""(""(""`#<:)""(""(曱:`@:E@PE@P曞hVNEQ\TuoKKLFN|HMXz|[gŎ(yu6/ElEKJABHw
Zj΢};Xm)*k%xR'/N~
r23ᚠ(""(""_,X :hy()xiimZ辷`3vl݆y,jp->BBJn&:#]G""(۴{7nB=Hϐ>rTu~<hRЪMkEm}-ڂQ^a]3\5]PE@PEiM<wVJ(S|t$aH^{O1_#Ю
QS\-@B^+GBBBXxǨ_1݆'ŗ!wԱhUWAm|xǑ6{OχC;
AE[P^S/W|Vɭ6+ΰE@PE@P&!uxdNzV{0pk=Ė""}ĵ,hl5l,Gz$ٖ}{!%%%lC*vжG=:ARnj fR#BdU!:'c+VQ}Ex᫧
l%	)U+v/FEM9!=39]l,#/ΰE@PE@P&!t˫1lgڠkw""`>ɟC]H@
HfoB5L_!I?kmh:2R 
m>QN""]O[ZJ痢_rUX|b? )I""%Uv@bvZf!5%w:5CPE@PEyJ:;=hK6Rd&ܺxׂr	Z<DyG%+pM,
ySx{IMF\28
:&d .%ɉhߛܹ0΂uh'9(!>1QKJ%2]R>(ر.p
uV޽<?5bpz4]8Ł|Dvv6""Nw9mUE@84D%WOC-+)Ȧ+±B""(T#d{ΈD,-}f!""I E1$折<U	tzɥԣdTGO,YhN8$xZGmCu]CYgkPJ#3-(--Ŋ+лwo5
To/u&_uGq囻}n}ͭmłN/ҥKxb,M+""('>)	H#RL23Ƞ+i3,%>h_KDđ3>;qD8Yv@e<U@c
Iu'#VͧvKX$L>c֣eD+jQWZFib}U_guڵkgr?%Kujx'*Np~W$T}?,<ǹlB{|ÇM6xwЯ_?>SwnQE@!DЧ*oZ$g]4]^Jl|)A$vˏcmvTҜt""(f""]/dD8(Z.gޡI@2YSIaNľJ""U(9(E.\1ci!;liL.+aC8|iV!ı^Ic1G|c1Nʉߘ2]V⻲&nU;^IcQG|G;vI'O>}ANPE@@u>^=s֕F	
7#,4޷!zʫO2I3/3H!>4\UK\Ů-zcaGHGJ\""y
6Ѷ2EmU%JwT`Hc""ˉ۴iRٳT""*GiT^8B0npnݺ!&Z""(@Tҙ<|(*BAb,ڷnAVN""dd%;&l9ʊQ۵aOT$I|lDҼMp1xO[2mٲLm}saUص-{""!$мNtSkQ]Sw""5!}Z
zRAN9#/0%+_$xхq|BOuI`4-gg'a5>S	M?8=rssܵ۷o1""DSCWx.aHMu""(G,QIg
U'~2
?I4UoHekd,-;-dL>% V\`˦Wi]h~H[ʱuS	_*Igl],F埋ϷiHm:M""G뇸E(ÉClm,I&۲e`	u72	/ <K'\O$%>îZIpQw->72+ALq k'OGپm
yGjP={oۖ(NPEHC B""~ywZ%(!CKZ\sb脟*쪮BYFE]\Hsμ^EBrdM:Ij*,FbT坍&=m}Z))g'+ZYm;p|KlgNL2w'|7C^ޜw_qyns<d[<z;ݢG܅=.I0F^qSpy&l
vH%q˻]y+?ߣG,Zm-BB-}wi
G]![#[l6C""(a@TK'>{=djغ+ىxR^YY)jh=u(%S""
[N""z`ZixOqi<yhv5Ignr;z-6El^Cꪒ"">e䣵<_-##4d,\|Lfyx0cKxz-~ViPݏM],&(7*I]eV[
Nl5Gev#qz}/r%{-yf2C-~S/:KU6R߇w׭]~⸉^.]L4ͻ9w%';a*JVH( rEY/Xbrw>d*zu""(Gr'""W6DÆa8BK8oOY؂NHYM:{3ͧs~ƀVIh loMg+'@8~3t;w N+ȣګx%tiQFu}<_a|[q㲷0ޯtX(h6J>I{BelF
RàeJʆisyvy	׵]yPWU5?M
$e94۹<K/{
Wޭ/T~zC>G֬^ECú5kp	'?C좃u?<|tr>o""ߟƐNÃ?l|ͣۋth\P# X~E,{l
p籌tVVV_'!,Hy[tX=˲uH4}!0MkB:kaBW2m)SX+xHM_U,`kTue!-+B['S1{P_]wL0q{ӟ6TDQ_ySx?Ǉ!\v!{ͯM˱{z/zŤཇq,gR~|J}fLjco޺/z%ExwqEF߄{5/pҗv:_@xAƪ<eX_<J|{5[.N""%O6c*Vo[L]ixuW/Í?Shc9jԩu;qY Z\rcX~ƌXj??͞=_|,Yb!avhغ=kL0hB89=ٛV[y!QuU[ɴ'e>HZ8nIHcEeEXpe5=ob3|bGRp""干v<RHy7\<W[$2KY{!=զukؗQ)zŗ<>?N9}{hpIP]ONbݺp׾?[_'e
MoLI-v
8W/7{1}LzF`훗""?z݆yVr/wa˲YXO1fmƉqG_+z.
<!/|txD<T6+9Z?xxsv󅘕q֮-^Zl9W[,'Y_qdƲw5?7<8/K_?	/:x{Fl/\vWo_鏮\x;__Ry:g=W[wطoO?m,W\qiy0	p}|&?6d=oūy/͡Cgp
Kȋ9#2	qtϧ?uf37yDyQBtUrIξ.=-,.5\qPgp~4?ҏ]ˈ#^8]v?$l|_7-i;7ᬿa!D1Ҋ{eQF%7\ߞ[6G(i;@YÌUnK""gJ{qZ%mqǸ!&_G9k:keF[QO?q:Ϛ显ĴƱcZ!0*}X_IOcռvL>CQ`6|e#sJuvx(!X41_GpՆb$Y7~Zι\ڈxTvV:L뜶JKygw-F
@__)ݧ⌱1+ԌTYEwkuH;__iN4n0}#+s$""*s+̙ݻ'0$S,䬃/2X\bٴp~>M_MIz&ym2vDCzoaeL^m
eHΰB
y7lD˖t`:E@P#%an1qlժ!~	/~iKZsD*/s0	CGc߿>JNyт)J;3qՌE\sp/aZ KCn$RRiORL|ygV\znfF?FBrgmgI=Ep
~w6rbj,mږ+D4aΣ=_9,}^khg]eA4k%NLC;ZG|X8nC:}gϑhuQzߟ}H"";w)eݧvF%		,WB.1ы+>hj<&\8,<M>s>R}vL9.Gcr8mm]jlShkיav֯NPE@ IGF7EXGDzɺ/8,?!Q~Io2+';0;fI'f	=#f""v 8Z༏6+Ơ;UYBG6(Q
BDm}sy Y%Ki.<
XtAG2!Z""݅Wq}PDdeoì7qlKk膖y C:&~9y}	/WasW:Ak}t[|Mߩ=Ki5桍_Rd[~}ߙf16A2ڕ`lv}0wlǯ~H,Ǎg(VKy1;eaqI1P^AD(3<<N&繝2.wfݺugvْȢ<?I,u3T[hǌ=4WE@P3#<޹sg""痣BJ4&!|&e
V,f~uUQe4f5{\ֱ%W,
_>taP
2Ӝ֜Υ+iEc:
]¬+Б,#;Y@g32b)Z8M;g#RZ땯""+&vz^/J;+;^ԗN657XOzz:/+Fx?
_qԞȠ=LE/s""蘋̖5	X }7s>DjtϹcn7}8Kľ>(퉎=XR4,$_|1&M;3c';i:uW_}ݴ@-b%*L;'dL[Mxqn>N:yax{ )珿eG|(9E@Pbz-zU(n݊'mX7ŗÞHTA+y+yX\fF:CԼoiKyNX/G8eu\ݓV>jtgȚ9Ұ-Wiu=5Wgl
TVzb""+VQ'
o.	x5O<Iif~C:aCS)(><XJxy߅	J 2i~;ig2p;.az%+%JL8;aq>Y͞BUoӲUm/Is?e҄/4o/;)"">z{󨣼r3t4Œ Ig|َ _%>;!	ϋg^5SdP|nA-J^`12Mp:e5>̀'3CuKX|gw3ށ9yPe&ɩU> &}aQ|h,#Rz$,v-:;b~7d-lJښ~TBCIb߳'`oPS_PEC@9D1ҹw{z[!l	 	`Uvl5LGmhr|IL;^_s-DR8ekCY
]g˸y;hUSpii|Pvli߹sg̟?*$D{.,{BaEZheb@Ѡ""(11z[0nhږ-[ԓ<=5tgS,>=dh1MqIYTF%aDQ""Py 
z'q{iq6M+R*2M7n؀""{ݑT(""p#NWr)sFTPd}+/zMI\gʛ4`)!>0PW    IDATdMJr54(?OO9sY#Ēol쾞khwj:NO@:H?:""(C@Iz<	)[Ҙl%IKR2h<,Nؙl]tCnDb~""V?j7G+=
?gAGQ7?裱b
tvn#䫹\s\Q=""(PÅK}!,fsl!Er2SHΜP[}rG
c(d&/vK2D
cla߿?9>T(""F _2)2Z]@ +D19#T//hԩoZPPEF QN^3l03d%""d}C]hpI`4y|x47o)f/s>k*(""C 98%U.9hysGFPߏC]_{oJX?ڳ?.<߷hPߏC]ߑ۷őE(s-{:ykG_'<|f!3r3P~\0}DcnL4U+[m[|.gw^?rzAK;~yrv8Zy7_߭O}8￁#BmI3·ʹOW^;O?mtUT YBSTìAij*Ta4U0nPsڟUx%4?M?̺ԜAf	MOS5i|PYBSTìA'I_*_&Fs$ꕿܿG_?=(y3@c%DAGt}o^p`#۝G\m ;`9>!(!!jvsUUAYi-`!m9#u""(""At|\||g1b'Q6k5k֠cǎ6D`57[udNK\4}v.I6!>޽VB.]s>3c 6رWFΝ0}忦?1))	zj>E@PE@Xp!rP[%q5i&Xsss
bKK\Vd8MHKNlq-Tu-^\ɵJkݺ5Cڵ	&Ϝ/pk1e_""l*⟗kn75U/T(""(?\>7._p̯:9ˊ@{&@3cK!9ͽ$Ӈ]˷-}vXqe>o{ė2
>!u3<vn;lö;-\gn独	xc`\AE@PE@hO[ab9Ncn%2ɶ|B^NAsKgEmt640d/v[ve[+$n(""(/[Jm#y9iMj̡z3auJ,$
&	\#~'>˄
i;O>;7oFbn޽PG|qv<;-Ν;ed8ڵkWbmn+6mۇj&앇sHVE@PWƾJ,Z78Ć15G4K'.:8.<vʜB%]^x{W_R_:
%+ϦxǱvFN}{gy&ؗ23N?tL8guY45yd3w駟]wMQ>Jʪ.{}4~7rs5Xp8*)\yF|1?_Z-(""t61s`<+Ć{]g4*?H0st +ah!RgΜkT~Pjm_|4W_ވ;v!XaaG|tg.6}t4>zh߾=x""}+<|t[J0aY0;cƍn%exl/'h$IJ>mHn?i)""ƯG>Ead<y3`-bWTdU\JK)*ަ*:qK
_ŹG5PV0?4
xrVLZloH| vC7)
RE@8,Xz;=8cT,Y܎fs6	G8wY7Mn6Z9̗titJ]Ŝ>s~2?Ol./|n;,yKY;[j'gCǒoYN9_d6؄˲co!,/O|o醶e8eEtp?N^
⣏>2X|ꪫðgӎJb6ϮC?2y-S(]*;7%F'zjgg@6ϤLlT?`k3
A9
	2.+iL_d|/vdL|:}""xK@Pb""qm,?uD^cvbzr[*`Ѡ""(^F<u-9):y/<Bx󟆿曱k..errIsؽw.	c8{ͰtIxꩧb]\}vvur\tnC3:/4e_{5cܹsX]3>.w'Ro'b5kI>sD¢
YQTTd(`?fe%KH1\2oOVd]($'턯o59uuXL~zrӖTU=*jaѼgfp5?nWxdǈ~vn20u""&""q󹗱x1Oܰױ
pӴN7M?UǴoWZ'd)а""(!AlJ
kk:s%<װp:=5gێrw0y.#mNz9=%q:͖I4A/vۊEUp>3fŻs9̾|[:ر 07q&֭+z9SX}}eeX}ö>v8l/)zW	\_l2 u߬؊aۙej苐=s
b5DD[eҰzY;[5X""&(_7Θ{_U'5L|TI3pQ
z
gs9ꈏ76bb&Ņ;](>ʟ?qbx\͡)]Tx
u&nW9Nkc `ن2gD;#_~[Zd_[ڨ>+Â{@EÊ""z>J~{xZ-У$.2,D˻N8@G
%ey	'?>:݋ۜHsYsgƲisA۶m}
=^HI$ KX|///7L{
m,s=7`x%S63f20rSo6or2C;v9,q>p?xq\W
2ԫO/OM2me8nP̄i""<	B` -q^dg&c""WUxŊgz%8qڿQ3<n\?&% ""ڑdҺ`;F>Qqqu\Oo}N+Ǹ)*_FoFMyw.n/GұW!g
::x)&q|vÍx|Boz<%h׳7Ўjb{>i˻8'ǠƲˉ^C mK
ۀ޹ab<Т(%/Z~;̣>{o%Y}E@PC@<see
>1⸭HL݁4mޑM)d~3 9	|w#O|}
1?ב:o?iU.@GLHOHa<J$4⃷b4x`>)&,XHI>
I\#k4 9/M|Y+Q|ck(L87He~Sԛԓ.r9e_O8!,::w'x""$nl
3}}9Uf[$ῶ$漖idq<_VU?k[6$>Os1rS}oca信䟈{F9]r$E~Y[<SJ٣ϱmDMHSqg+V!"";_|pUD:[Jo5(ʴR;ű'`ߔT{0{)8()ǶӜɫpWZGj;oxo	0^@QFgV|AVcЧMNPE#Чkk̋g{b\ZYsMP5ԕaqHX@%=)|_ޒ4s19]B""I4#&;a)̄_|qHB5jk$
)i1J|ddSԧOE\,$i&tb,SN
BWymذ컎!}}^)'i>m%gË;EN|WA{N#TqK̽iB](vl,J3c6eP10Xx'Mx[IBP>Buu""ɴ7+onq8	xT""?ǎ#oPŝ>%!9(B61»ǋ  ت{xN+<p)p%\;dM21j>GŦ8TVOKxH:nZ
u""(;Lu0tj[YMS:ˇ#\XaSN;
?S)}G'Y7HdWh+ఱ6/qŏ<H'2)%nNJtG			袋7K+/}(YNRf˟Y|⇳,J>aq~VQ<}^c;ٕNsFo]R|8ܯo?$&&<5 W^t-X)XO)i4Q{x|
$$a@\dOcҧK+|&֗#Lx7r3O)ߠ]E*ᓰSGoΎ!mݏ)bK2l'+M6|*-x]WqÎxޘ28=;I^a?Sr[b@bhOoWlù;mˉv۰yڭDŕKgq46b+SF;R_PEDgqSF#^9\+Ldl!ihPgϞf/r&)u.d(oe%H|Q 
&ds1Ss/R۷Ϝ)ۗ0^vå>dXjk~iY˳cwߗHp-Wo
eyE8ƹIy7MII๜|I~sRﾋ_f0ŕ7|3/&=,G/_.݌UZ˱QtBQS\ǓxbҔiП]WP~pذo}ؾc^ {iJ9 bgn;0o&Rr9$y4dފBgG_t2~{X<*^_	WI[j hoб|""3:.'oCe;:8>tj\<*	3:{%Z>+[DovZV(""p8 }g)頕(W4@yj*\$#|l~ﳓzdC݈#)s1;؜B¬WL](B%,n4+>
/isO1c]$jr[<8/>	'Ds˳c9CPHX-E&qnQnn&fϞmm
i[Jv4mWo{1|`=N<k}cYl&	zg9ovIكW7-zxW+/*~I&bcG""gn
{
Ncni~ڟp1.S0\J!>qN&?{u9IQ%̈́wR~ǀg}}ԣ7ߥѝe)	Vsœhc8՚қqFo<|mpsFO'fFk>G2/y""( o twVaeXi5Ya6ύpp
#{ؘ6i$3wf.:)+i5pchSu/KPxf(9ɱ_	Ԃ479
ߣ9i4f!csB8Cu
7ܘ><Sb'qDySS""g_ҥK^X$yRk~H=<9c֒ÝH5mko1nėK67D:
..&knH~2[s+wZl.SSL:i]4>V&gêT&dfn}Kd̠a>ZHWJ2-ZL֖Hm
!߮!v>Ng՚(""=""|fE}ëǰ༟Eޢ
_:<lK8ǔGs%$~s-Gl6Wz#q`P03;clUr%߮N09~;wΝ;͆|I/yv8\Ö#a[	˗>/g{{ͼMFG_q[m'TGZ^=~({k	
Ïjo&0UThteRb9)<I0ILR""rM$ɌGqdi%ec^lhѸhat<l~V줡5TE@P@MMѰyfz
y[3M3^b3iќhӔ0.pEMfxs1l(ƲaBjPB|
dk#/<N)1-)aCC-e\[K68?Lt 6h$_鿑2p /q7ͫɤ	%ot]w-TC6{bhJ
2JnnUhwE.
+[e!)qۣaZ""(@c`yQ#twk2yIeˬ\uZ,XE#.	򄇈IDN|xN?|	qHLW
UKŔ
""&&Y8MayIg?ٔh/zwp:_vm'bˎey8U'#2R2&>>!.'0_v[$}v""2L>yG-yɐr싳둴H>K%<E@PE`=:
嘀n
;W	    IDAT^8טu[yD/
0c%6abń&&߭H8WK͖G Nc|IX8	7p%߉^F.ʇ_9XOe,sa+~or&v[|Λ
 ..PJR""(""ArI{/\('2
`<NcYɏ +0޽{^Γ	K2v8saH	v?^JN0#0_9lCisM>4W$]vޖs-SD/x/W/rⳜM ćQE>&)""(ppp|n#uo8Jy1oIċu%'⋌]`;,2zv3z(,NswmH4o'$NEg{n-_طz0H3޳lXq8'N㰛/+""(o 8*e-ym\6hP7_ac&>BTF,;#2Ȼ,E+-_tuϢ}>;n\yasb29cuVǋN.'aٹD#<o[Nqny/ʻny7|sݸ[ϕwn<ZhMʻq>7+xϕwn}n?Ww˻h7U+|wGo>Wލn\y7-ƣT}wsn[ލG+-\y7s|V>Z~Snܭg>
fv}:9r65\|6w47t/ԻG77n}ͭpקDp_ݾ_8|ch#PYp<~ceeX܋O_y~$o7km3{߅M61r_ߏa Źd%,ioU1壅ŏ?t_p_{hٕ	{-#XFqb֭[*GR\>/1}O	}8Ͽ~7/	ߛh:?y#@hNtJ%ǿ
	71}J7ΑAhgQd򮼴K|Vor..^rwwjpls9.&pP7<>BW&wo""{]_ﳓL	/qwA_o!<O<ãNPE@PE@8hx\+""(""pȨDuu5PQQad7o&Im+yH>1F?'""(""( H;??=Pދɦ}q^^^ ⊀""(""h`D&)))())1-rrj<&QE@PE@P!<N1Ѵ$Hs>ɊJ:{-(""(:/--5[39.""J:u""(""(Qmdk*ٺi<355NS)H(""(""*gǫ7mڄKb۶mػwɫ[hΝ;㨣B֭0;U%LE@PE@PAya1Ř8KJa{ѨOEVNoߌ^+>ʕ+1zhtX=t
+""(""DD-<kW--Њ[$ lOiE
}}w;3""(""(""76Ӱ5G83ψGx$""%(ahrWKg QE@PE@ \Y<hHNҙp&[fڦ$ =""&{8n(,,TKg8P5]PE@PE ^tm1䐅sc	
WŠmj""Z'!g]qP2޽[Ig SE@PE@ /""Z[g`l""YUw6!#-YN#k'G=aRw{8͚(""(""Xl7vLAfR,c@$3!q0	dif{%2P""(""(}:cbLgGӑ<'dbvMY2dFV9z[adUE@PE@8ϥmyzR@W-o^Kēݍ#Y{p%.[~*""("">t#f*
גOTX>)i5R<`KQ?E@PE@P~4TezI1ClCi4ĞAsJ)I'?JхD?GD;(""(@ S[vMYa1PS*9S<~tբ(""(""p mf(B4^Mc4oF""tzqOE@PE@PF""PO9yN'<jZdYKDg]fUO7\SE@PE@""+M2uV""Y77auwJSK ""(""(@a2IW
-Q#g
[5L<tų)H(""(""(jYIc<	f%J""DFy>'L@)$WE@PE@hu4nN[p5R%Y;y;M6p""^.N	E@PE@P@Yڎ5GgJ\-:4G`&1FQIgU!E@PE@P?D,8gDH""'ox&Qq\$E@PE@PxBrKL tj,&N-""(""(B14%tq,	4|ZG7
YRE@PE@h@-#Lj8;<N!,sj$WE@PE@h<b]!C2
$&%PbM>SP_PE@PEqиzXdX'.8=,cm'}8J""(""(@xhN:{Ē%6Jl錣tI<Ԥ%""(""(B M<$""b5#|7N&2Y@u!^߽mճBY9hjZVID,]-v~m""(""p!CG`#Y_GN""j|QY<iN;ĤQN}zkkqѯMndzKmrA-(""(@X\Ms:WұKbW9;-7g'ڌW'ʱ*E@PE@@}=Y9骥+̝5ff-*b|;ɧ㐓]aZSX?njE@PE""KX4izD#D@l:ɜF	SpWto	<,^8ox
PrVKӮId9K,=C?A(""2bLUS]O:idd4Jb	d#;$a䀹-ZO~.ÕѦa@|tHWE@P	&dڬ`V*vYIhg*N8Ov]ş |ȧqը z#Z
3*TE<w n>ϻiǢyxB$U\kY'f~E)
]~:Nb͢xxtu'?%qCҜ㦐Κ""wXF3=vQy9x~t+s^iG#}Y>L}&Ka

1f&65`rpΘcSC5RE@PDyz""L4xWӢ""ʋ#iς<H PW.	b	rɽS_ɻiw:}_⡹OsGVW/ӖK']ҍ'0=Dydw~bxKpTƣe6qZd?&&:}4s5*\~6}smC3_3״c:4dZiF""(""Ft*۾jh':3vO1icxhBfgL""([
20s;K""	npQ`3O7nI#du.Jl$ܦ)+pמBӕ'p_mph\PE@P""|z,Y9gIDH""g""g<tqqƐFt>W%xŧJii;ӃId=Ȼ(?=Yiio?N0g2Mixj
vU$vS:(_0\aNxf-
k%r0}}U)`iXPE@PQH]K-,c)Ì&bj+ro͕hV<UȱR0Vxd NTb=Z'b\x*iN}%0s<4Q\?\hoq$^XmlIcC37VuBӦM3MSq?ig(ߺ;QTSN֞JZy}NfvCc}sms1[桇O9Cht""ԭQE@PE@h6h$ٻ!(9,45[?E8]Yn7{o7
gvY&[O܈prJb..}2`Z|gA7l'O!̹͋KAșy3g ~v2H;mik=ŧKlummٞN8mJ~b}ETgM>)/-K[
mCB(""(@""LRGTC̓=4>gg,e#0fHpWPǯ!eڊiڴ0,7Dhn%6ls-P>{`NUw7hٝsGW>t.:4=~$<""7E8zdj\bNAQ""(""4?<b]!C2
$&
%^-Dn.b8;p&J0c.
UG쒆M6NA(^Ka7t*6Ԋ[ZMXOQ0K#wNq𵨩Cvnuۮ3:EG}X""եUJVKjO	@68UE@PDE'ؒKcힸ8%i}QqeO_b}V5F9CVfP0,=J:lnPbD2=;UD 	\Q]%ƭ[&(gt|{A|`o=+z""֥aE@PE@h^HDd>bYFX>)s5RsH$GMshXR8.EKi$$sV)U%)-pfHH>r.JLؖTuo&Kg""(""4	l$Y'xR!Q6K5aE:A{vNhzw{S?]뗮
ˑ:,z)ȴ{{&wD:Es3pIM;rE|uUWZcNPE@PSbu.P'щD5d$x~gM8VF;7!tVD^'H;{һsR@rͥYǇ`Ek4sޟhF3fi*QE@PF%oTkWųH(g1׬=F:C0qr2E8;T{{u+Ic0`p'Yj Ө.)Q*9(I]Ơwշ{ɧ;RȅPA5APE@P6d夫2wVZfgYKd'Pw10|D4̴WU$sc
̚<߄^u<z禠p=}Apv44*jOhE""gE=0yCoJڱׯ;}S7F![qǟ_B,lm܁Jᡇ9`gqSŸf
BwqA:L߈S
j""(""bŢI++h$Y'Jd.ב9'tR`'Fy闷
&Hg[t\3ԍo`-H_-XtFQ0(m@:gYKNd1Y̘A)UXd.W(""('1L&骩y4^
2m|NZS-\nx$<7)q q5KLc㿿a
.
@ȓ?|!
7G\%
H$/`IO=MWtGSp=Sıi!nCKeWJ5IPE@P	ZVidYɫig%J""<}&3 	 1Ýc1ye(uN/+s5.xiU2IixC1:
씓k<])?٫C-S|{Z\\e	`:λ,\c7điov-oD""("",Ѹ9O('I/G$kg5b'NɫE""wh.wx]5̬э=2T98i$:k6rBLi
C,Q)vXtرm+(37$[||""RREg'6	!\%\'g`?;gTmx۰~.T'g EtrR6Ёn
k""(""4:N%b[Q
W>L$맇UIlIl|_#J~0Öhv0Lv5:A
C|p[?]J@}E@PE@8 bgӜGr&,Йg<tdk>ع3 t\<WE@PE#!
IcKr	RCAM,E]so>l9UE@PE@h""!(v茧xG
3E]C&|;3h3ǟФ!d~+""(""px!LjQLfPsOg-Y\~!Vdґ]suřR;ɱv^m͂mRE@PE b~ȐLC6ɮIk&##*D:y{pl?#_#SE@PEǀ %Kf,{h7b޷ VQm?܀r;$""
6AˇR4bA[ʥ6a)-VVjBZEqQr  &!DrBNr=䜓.
:';;ggf}}g,m*'H˹OK5F@#h4{#RBH:_9C&h4F@#""$󬕝>\ŝ-~-oPMu F@    IDAT#h4 nDY[[ꬑ#;;k鬓>h4F@#{]ګpKRn	הm*/44p5F@#hD᠔?
<DSj{fYCyLQmH :F@#h4@=P*&-m$YW""Ys]T>ID]QӅ>h4F@#  !٫tpjJ>I""P$Uڐ( 4uF@#h4Բs*bg	gɨsQIh4F@#7U.D_OJ;ŊDS|*+v+A=n!F@#h4!P˅ܕH6
s%3+Çrk0J?+Q鶓t `+܆%/-D+Vf +ܞW27#WU.ŹƼbM+H
l+܄W^q_}FER[oB&y&w""r 0ϔ_0ɵN-khۋǸR/66:hx:_bv+*S◐ծNh;&?7+V𣏕f +>S݅J=uXMg=#ߛw^wozVwLc_؊lL'~(տ.څ)C@P_u5@0)$~tahB?3?
Aչܵ?.]*V(,y0eH:ǶGUoD~).a*>KY:.4R2eb?GݯۊgV_aÿz\삛SeMګ2ZƤ`vsRDn%L&=9_^nK%%4j0e.06
KrlῪjj=pX˩v2n?^z/@ IE.iDC`J<CRt>D;LIu~t~g2plPxm^E&﫱{))E@9]פbks15dS{	M7N`m	1"" 6෎<+%6k!h7kIx3ֱ·̝fnXGyG.klg]*ΘWfSq:/x2{`{S{i4Wd2ZLfT{0(<(Y#L'rJƈjׄr$rz5=3#3{F"",Ǧf
OMq+z 4kFb3=#qH24|lڹƘ}|39jiK;U2;11ԗU|@LӕiuSIyػbRWxlj fc+9:sʵ˟h5GW?(1dn7%1XϐL f\>L<IPj~v;f$w8;
Fp3IcJ\<bO^#k^!lcB63Y,)[նKk\UP0W7l
Kj}Ѫg[V*a?~%|V=}f|uuuܐ_ѸR7e ѽkLppçe-̀{J}1;`Ĳoy+Pl9c9naF1X#ozjmrl7,߳l8Vap's6lϜ6""-/^@#쒶Cd*I\+JᇼeBܙ6lv\ﭷޢ,IcaN+""Y8cVq$_:;U^w꼅y9tTK#|TʍcGe3Q٫gKgΜĈ+rI&9.訬y뎹BcʍY1RVLtJس4Yc3Btj5ycՎeg;<,:$<{c5dr#Qaʒd#9FR.88.L3ʞ?y^cƕ4橞6>3kdS3J5Usfl,㒕8f[I1񹰌Vs^fh39S*X,1`76mc㺥HZ{;񎟟g;9V.1ʚI'ggcܥͶ""{js08x6f6(.QϫX,Fpf)aug^cms,-1""x)iSl
)Vͱ%aac)뒗ql[ʱP;f1Ɏ
Fj΄ڕ>b&v,6Xp
bY>Y=V[0IH[yziO7n$ի1sUcR_>.s,z8&x~Ac	#Ck'{o;p9_3'gA gq]XHgc0˒MBEq`RYmjd]bxE""kp|ckzѯ|&/3$M2Ŝ0|imS20_~B@&z,=`*WBZ4MXU,H>
.5#A%{AK@4XqёuVWX(̬xUXR`Ի3vxiz}F^>f`""Ϥ^Yl~٪,϶^'bCuR}8fG^7ēջel<lwG)JvB,iʩfQ͏9!	oX}y!)iʇE~sL1b)veqֹL,&.u}llt$HnǬg_+5,>=P}70ԯ|3Ryο|Lҹme8_ㅭ|	*p8~Kt=o_3	U?KTOXz}&܇[בt٠4#CⰒϹ%HLZǎ3RcMa'<p>/)h_|V|-B;nVM11J/a>4""۵W!/B&`nC0JG+/TpO>4CrDWO]Lg}lbzޔ 8=/HEQ""`q
T`zX홂6tkO`g/70c-y&HPEQi~M	hv?#}
L
^\BW/3]Ibz@=YO7Nf`:R:e392S'~=v嗺rIXɖ1ű(Șbq茤@5-4ɣoGwE݊u
ۣxGfg6-
~'~qOzk	G-O:c{v\#J
NDᅁp=xLdyb!U]]'SJ| H&[GAJoN.2l%Gp}a={yҳ{?to$1+^.<(G~O󖷫j	O\;2!!.f[f&W7%'^uoxdO_]XXGqlX3N<0$m	=Dz-^Td/^4> ƁrUmZ9V
W,9	s'=c93ݳYgiK}m2ch>q_z>?e_=)pE99Yb1;͐Q44ǭ{~	ooe))ru<	+>?8]\g~P}N[RmU}U6H/?o/=L=&+`E `B#q RZL)jd'""HD{VEC9;׊3LJäsG
xlDw
\F}{(t7ƿ8I Si;W

<TyMiI8y6jW2ʉpJ2³r{惏OAQfR%)UBwg
[6PWuX|Ȟx\c7TwnD0oV\̌8!/º^qVzᮑ#=QF6L""᎝Z߂#u4&$9(3$ullfPZr[#͏ɳض
~8f#zn|C>p]1cmZ\o~v`FlJ)s,֣݇8eJ3W7rg7;@Ye9ü[`}-z1;zfz*Bn܌RzPO5C@ȥ,$K't:	t/pMZ8fz]jG&`~cjO쉐<~ًǏ`zS5+7ƚ`㗽f;܌Go=W%hɴv?R{`-'?}x3k^ԅ8z=8d\I;#;g,ķ_c
w62Ͻ7}2^Yg""ce:S4E 6<R閟[ZO𝟧zw*w998R7ʝ5+Ν~e9e}?o&a)۹1q#{l⎟UNvNWYVu|aFdo6{T 7]u>P:1n6)0'6-4;AcR]0,\)m@gQMbW8~;9^isVgr2?)S;y KK
]?%Y8Q(}-gO/yڣY}l=OÚG8e!STqj?.~[soi>mb'ǒ#{P,yl道[T#B8rW_ŝ5.dD""콮N^
渫ogXZE=K?1ִf1SFTi9Jdn6Z1h`bdиdOalEӕLac9{ZcinUգc22ʟ<oci#fuv&edsTf>eYe9NK)n2ӂg[VKu!׾""'H2{,vNt 9K]eܵczaβځw`<s5+=aN3bޱ;J3gN忆
l*8ZmPcVJRm
PyV*
WI[ƕXgUߖ+Oegtls&aBK6
)V<׭ێ34<oq4ͨGy:imS
CLlZc#
OxPU0'-hZuWF2$>s,cіo6:YzȊ
:3w8/9r8q	@qIt!.)ՉTm0	Q3nS+.%&`)*W%~޼,2""ۗ_JK+e1'|)*,2ʣR?z""R-lYXFj!Q̫~v=|
W]$Ն򩟳yft+UF=`i`gEţJW3=-QC*W]j:oݔ_+9WRXѺوcC
$g9]v@8.
8#R{ bٶ8 VRJj}=lkyi{FFK3.='O
 ۣ]߸Nidee!۔	pY?a~J4WFѱu$ZsH4F/>
d}m.wD
5˕&V	?}qw`Q^X:\ze%Kț'a$Hq,<E2FsW4#pL~Zue̗uױ!=+=ө_S@Ji 7vpDʎ=g=F8%HY^~7]f{>ɥ#3)ՓXګ~5PK;F"" ¢*9Zg֩rD+vxVQYENit
	\^}B3 
A0 y2j4JQl8Җo@
çND uP[7LĲm4ԻK4ZZ˪I6M!^+vx)IX[kE:{yc1,55@;{){}\4u>H\%jrIZMk=0C5f-ڃi.VRJd5F@#h =EI=33{rm9SK5F@#h4~& J9Ņ	R\YNK:-$Q#h4F  dQxᓊ\҈(+'~xƈGz@@F@#h4.DɫZLfT{0(<(Y#L%h4F@#dAdR$SM5iKdP2L#ѧ4鴐GF@#h4:DJ2p=iSqʦ(M6$奏F@#h4p	Nnb)D\FI$M/JEN	}h4F@#PeyNDdvn=tDjxb7wOD5h4F@# nDY[[ꬑ#;ՐhND't:Bh4F@#K]I2^ĭ/)Y
:M:
_F@#h4 p8(Oє^مl֐h^$Ifzz=@pu0F@#h4&DNI'gH)uWPκ;t:'F@#h4 $d?{zNƹuM(T*mH:F@#h47DjYŹuY%V""""}N9
^GF@#h4弹t&xRY-V$""""b^GF@#h4BJvߜarePnFg0w%
}0%4鴐GF@#h4 e-NLD@8Ea<)`ޓk˹Z^h4F@#@0)$~tahB?3?
AչtZHF@#h4@@IE.iDC`J<C9.|͎_3h4F@#p$iגf4Sڃ9.GnA	d:-鴐GF@#h4z""""lRI[""aQ>MI>j4F@# ՃH0PلsM""3̲	٦p򏄱Q#h4F@#.ɽ׍?B,ŀ(()E<T[hi!F@#h4!*L2Zى/^ܙHB
Oz̀ԁ4F@#h -0H9kkkZ5w$s""]v""5<|iN'D#h4F \R{S.SAMCm})k6tzzwM_F\R4??^T    IDAT{=|۞mϿܟ8coï0f$vm~u6t6>[Gh4RNj5.dD""콮N2K:ġ?C+ëO,(U25ڵjIHgUϳ
mժ974mK1xtI4%|4kбM8B6-ђڰ4m n10vcj4W@Jb:hnIY'%O9.*$]fWc`.,.R)Fؙ	Z}['cL;JBթ'&~LJ&@Z6Su|}X(z{zQ1b-_ghf	^^g-hS9iS
>ĳ͐틷0m`A2`	<?8j޽OAl&pY[bhTM6՝~Cdvuوt던NnQl.7w!w 濇ˁ͔kh4B (tp$!UbN**p(r_=dIv,ʣsW@q>T?iS'aRllE{MF$ʐ>U~e
(""ş7x;!2Vb7wSM{b<D(?)~?oXQbIy߅Ͼ7U(R,WX:q[{l_aK0Z59F>/'
*OFӝ7\g!߻⮡$ע4of.;G[XBFqw{nBPCp^]Qلe\؛bn#)\Xw_VNq]x**܊9+|O2ݷkD/\0aũxkV5i߿=57!~G4FIdM(ȱa]5x a2*E[J	Q~8漝[h˩rIYg;wݕ;O;E!hPx.%UV6}Hߞ~e:A!l?r+}]SAVQ#h#Pw6zOJ;ŊA""㤪bR׭x9dpEhvEE8%D$yj|[Й3""u
&<;g<9
K!.!TPܧ
5cHp
pf4	)Ϡ1vN} /cXz3;SRbZtD/jB$K#oB~	'º&J9Qy[Kچk޲9BB[a*i;wA}D^xDlHriՊ &|""'OD?3iqXOLxp ISsMC`;SDY+u	'i*\)?q""Oj܁(+yOEo!5PxU!Y3C54-BCuHmv7mÓ^=~pV+Eb|Q&?8Y~C
q:0Oxi V}/xӭ}ѯ`Yl#tw}C©<% ~N>:d|Is)?-F@#FBJ_07_oNʕC5f&/TXAo>;7th0MG[0w!e3HwݑEÀf_.Pw\_܄B n45R߆ϾGO
$7b¸6xS:+Ro_l١kruğ'6@x|l;nv\bոNTD67E[pZ_emx1/L9,Mcʷ;!p1jp[""7m1Ǧ/<:=}{0nYzu4'LJWFH#cn7ҩ9|d%""~0ilɳ_Hh)aPyKS*im(
rQ)//;Ұ>hqz
rbv۱xo~\Wܯ$9݊obi3c~}ȖB:btv,;dSf}!X?DaG)(Y_)sӆ00?B[\gJ#hH,eurgr'""p\[:%V#cKn~}-zz+""mBߋpE'gqO`<aZ9zv3s0Ox""^CAB̚s'anCBka	)_(uhE>n<ޅ,.^T4=S1=n+x=E8zbn(}E8ӃtZ..,{&{[@йY;'>;K:ObV2hM6
iy*\I8&hݭz
L'~.n&960VՙrW%	$
gkb	rUE8[	Z7GGf!1l˯?E	J[SU^>y41NhײnWӕa+U ntD0o<
4vH̼(nރ?N~Z/-nC~f5uF@#HA%_a5l&I'N8Ir*%`(;k]=pkpNtLY3!x=J{AP8UoZ[tIrۻy#y""7B<^ͤ%U}
rѐ0[-弦YBtoDrB7NwP9VIh.ӚIؕN\1u}FZ3.b
H.{=o{@/^|/>3ɳ3弿=C""`\EJQmgE~F@#""SPFD\>?y[hju
;2^щX	{Ǎu}Ju:s#Z~YĜ^?p=~1tI*~V'tqN$%M""pdJTI:dz| Jr;_^(B@DWAԬ+ceAښFR:'a\X|9[[cLB,J	2h8!a*_.zݐJӚ_c-Z3n@pV낵@T8$QTփ8{#9P
bA\G N\MI$Ut(Zk<}_Xש+F=01[!oU%r7!l*&V$}h4d""`γQyPRnKByk_Ӓ9bZTs-P|:k{ۆةsNȞѫ(o=d>=ΠshCT/B@0ʣm]i%E 6|u4*rϨWJrͺKܭ*ל	%6_Ul^ϕYo)UϗW
TTͺϝ$gUvZ?NC00c{1	$
*'N8yC䞓FǨ\/xVT߫GF_M5ޤ2\ˎhG) fT0a>y @ +%UI?F@#p!DvI!E2٤SAO!nL
it)$͑2&oE˓P.K- )]ow2D@x=tN{&s
gOΝGuxsDRfg76z]ppThmZs""(kINW+oR<2guhGkzGtFMG)oKjf>gJ8@yxp
y,CxW9k@
UU>
Ra?.nrH@oh0VF)^ #q"":ܤli'HGoݍ""Na䒗ܽx[{=6;ԟh=o3«9x{0ۨ
=xam:
=6Ylsf|OO!RIa}u8vm{uA]ǆ8=hG\ꌮ|㷆bSĿdѣ
]_-F!ӻzvmQwvk8ooÑ_4%1Ƿ%ؿJk4 չD'PZԄs4R!I&|
(!H˹O?YG_Es5cik[yl^g-ڡ7q\~Sn/77?NW7p1wӢ}.斘LLxT@7b>Y^$B8<fڷ.KrLy؋T(d8QxWxYTz˵je+A.TMI6a(	'Ǳb>rԳ<,][pM|X&8""H.=x feh^Oŋ4%!m:aа0(ZYJ
OP*6B~)yHR1ՅO*gpXst?NV
ΠuN6uFܲK7%BpriĲoON\b!`uf3OZ)k]y/srREtqp9ܓDisČ
2f9=0wCxPk3Xe>0s;) U\EgF@#p# oZQ!eb_D6
u<UӅHJJjT6lTK	<ףƧiӧ񟓞GuUM7}kZH}QV}'+pu#齭oz85\Ȃ}}K|Q /n~LJ=u~2/LA KRԉ:4)+pq7urbX}OTSc ix~źȺʧ^0F;(qV*""~+x,qP^91pi3ωY0׀Pe%AU{|>tв٫D\RN#h@[s!++!:7*{ˑs}ХuPIkбMm| _|7U\aǑ\=|lZ5).BIʱE8v
Xk~zw󑏄kL>dXہ(1}q+I'5 .ъ{_'Q?=eIm}/S
O6_ iRR]@K*y{`{;c[ݯGt_%juI
aMСi6-фh:f)']ZMQ#;qP&d<R;ND)}~mdo`uz>dO*_}Iu	4Fw%4LWqKNWB4k֞M.LI7)w7 ]^
UF:gF@#B᠔?
<DSj8Ԑt
ۏ$Z;D4$F=5]YF@#h4M,&E6Nz?9pNκ;t:'F@#h4 $d?{zNƹu$gtJRK:AVh4F@#p"" R*6ESfk<`	gɨsQ4鴐GF@#h49t:'UB<)+vMpQX[K^D+o}h4F@#BJƲ۹|53`M.ksK }Sի>j4F@#\GXW(
N!{)3s3{rm9SK5F@#h4~& .,4M'aG!:`J$Vh4F@#p! D'Q(WO)ԺQ7;6ߣ%h4F@#p! L4S2L}N9քY#L%h4F@#\AdR$SM5iKdP2L#ѧ4鴐GF@#h4z	fJ2p=iSqY6!TN0s㟖>j4F@#h|#%8Gr%t6s*+M:-$Q#h4F  BEIY+;}ڹ""EË;[]o:F@#h4f)gmmZFv""Dv@$ND't:Bh4F@#Kjoe:	t/pMݦNNW#h4F @J9A4eרiv!5$D
ՆD""i4F@#C		hrFəuE@/u9gEDUK:]X3F@#h4 2ɟANka)JY
@Sh4F@#H-8.a
+vxVpV>ZN/d!F@#h4!PysY5""MU	񤴳ZI4EIbh4F@#\]Εs?Pʭ1(D0&h4F@#$ߺIɝ33{rm9SK5F@#h4~& .,4M'aG!:`ӒN	}h4F@#1 >%B|Lg(օBVh4F@#p! L^Ւf4Sڃ9.GnA	d:-鴐GF@#h4z""""lRI[""aQ>Mvjy}2޺en6vlEnA1
rw`G^QSF w+vmx
8]w#;3 }چgAϲ|lݸŗ3 V܀=;wo RA4oW""lBIf7m2`$TN0
yy:ROt󗚚|^~t*lѣ浅NcCxrhwRG`ěbȘy<n!#yz&S{˕¦ ut+52f l|>sYy/㹚9Ue#55!yiWϟk꿖,uz(
z% 埫xx?~6X6<-[u[H;N|g2,ۙ|f""Fĳl(lڰ6a4} VL6maE>h?ɆGo/E30dtdٓ0[׉+En+lD]'ż{#RBH:_9CU1aSN:_.Ѳ鷽Vϭ~Ť0_؏`9xT#g``\/o;YYvmٱ?iXű=<[X>o%ekYQR;rd sc%U/Rq_n)_
o40-ػޣpO[eO wte}3pY:DƹxzhJͼĳ!W3Y,dM%%H6`nu2^n;+îwqRF߫?;1Ct>r zh<o
u 1olYrymNjl*܌,|ѓO    IDAT,
QQk.[;
[+igFc}f6-
G<܆8YТoa+
_3o:NZ JB)`NDdvDjxbwЯ7ϦD׫d6_`%:(t܏UH/%C=7ʉ=B8@-SزEâ|E8_أzHvG^9؞.bUVT [D''{Ne`miE&faڣ証l(?]7s2 ]#8XO䣺yO{Dމd8o~1~:6OЮc[LۊSA=^VլY$x)&iƧEsnl6{];J|~A磷	fq9[=$H >-*	m34.7	iIKnO}PH}'L텧#WZ2 / =
<ec=U9<(Σ]׮^IHx1ڭQtB:}BdpyueyvKjte{ia,K87sΡm;-NKpq>}ZW=zl?!x/+m(SmFϱ-v؞l|`mCo)^;{I|~VE ۓY5=fR0
EP]Z6빪U
tх}Ea[fd^4=ͦJX?1utM33D9pdۻߋ;WFexXHe=8X0cc+g<=)
*]q RZO)	&w""Dv
d<R;k-Ttiު-3E[a9V`ctN+<lꄖ˞a}r[[HwL7Ei$=""S>QW#zH@i*`XDwkb1""q4}exil F*vqƩnC0刏̗G'btB,bȼ7}_bOĐ$=
,NAlwp8M=s_Sa$vz.qo:%e!t&&s}Yщ#?:U>z'UI$܊sC9C,^e}YD$Ga/#`A\dL)""Oiܸ[cwHI]^κRuMs6qoI|vHٱR_$lvq<+Ƙ0x$bĐh$o}'r7a)G\c~Lct8s}GOqI=W{}ݲmyG{	""s!>DzzMAʺ7HB~a0P0Uz-֨qU;؝νFe_IՕ1Y^]	C*N*pK5Έ{}|
{}%fTŎus}-Yx龮N~$#d@댟y˟ǘS?4i81~Ӽ?~K}غu7<UM67\g[|f-x\Nm
tt:T.ur9?fv\\;6fy_3gj=2S6lS`MnqTqy
4!`t=JD汚ORzpMn6.'gST|́r;}#cn^Y\f]f03pӈC-i?-'%p~!UIJ:<=IRْxIؖ!c:_4.^s""C%aEQB+-SYq)'v4%%}w7#Sxw	B	a(ydj=7SPp;~3Y#lR҇gpDCH]!Ni2⺊oR\gvn<91(XQRZjǐ""2-b8iҲnn7o\5W.|$Q-s]dXʒRuڷ(]תO+OiS)mcx~&-G ^,'lKv!)(H[8iXTtiy8qr2g`A'K<e=H[jW\Pl/3?}.m.O!kJC3lu\ʫ(RaD6Rz+S[Emf*<_}^i<5K0M83W['0J5N|$m}DKy
&M""8*t̑l_6;l%7$1Ko^Q͋'R?t1E$;ciSF,k|PcW&-Jߑ`xjg]|JN!#o]>>]a[u7yA'MJ;20j~[>[sI|{}-.08rnBA0Y+[FAJ9/j{fYwEO!j$35mI ҳX~!n
J,?Q}h6!ڙomj8	x0SَQ=,/)A@A/Xd,ߘ{x""<]˱<-oj¿""/ws]`|%
GIۯ5/҉
SԴ=1x
'>$Q(T G֧L9XqYS:ق!S{ICkyoÔ%ӕhJFS&Nu;}Wc4T)
nWH6EEK{E5G-Lu	ɓT3P@jrر!ПDbko6-ar>w^<ZEm|3N	GnYQ_<ifIHڪB˩.@'n/ GJ=tZV.^|(UNif,. PgQp4DIGLy{kRH:o8Sڷ
?I45~3UFlN޸fzw}m}q-}ɳS
O:|#nÔX,)Vij:v<<""ĜؽO1f>Yg!p>b]|Isiๆw3RG?xV %tL)YC}C1O
8/dS[fE2c""zNE~j6Y'c⧱`mYb|͆?:֪_9gx7zE<tmLGjf>t$Yxnb_Ls<^L	C /=w݇U訉ɕ,NK# M,&Wq$άl'Dԕךt^;/~z%UPMN)g-+iN;FS'Aʳ~X>EX<S@T;1s*IF܆de9 a:cH^NHw`ˎc4O%dUAmyi9iYm+mŴ,/2#8S/LH Noy
~CYGͥWFC?>ӝӼ$vo
S/.~3VJב8lߨP
~Ba] ]OD6sTN]\`mB\ΞSDW%_JڂlH<ZJF$%e'2YG3촇ږGIY:0&WOdTP$C?)Nmj/5?6Pixm~pX	""'QϘSӇ}h<oA\|ym{_&m^^;YKAG}WX4iAW6;>UJ~8Lo~N|<׈η*Wu,vOaOʕvf$tZ4b<W!a>mp>s>WP>""5I=G.nuXT_t7¬@G%e;v/ԾڷoC#$a䴗F22ɟAZNGѦsҦ|*
{
7PdD41	܈hn.	CP,	d$QAzCy?^xQ8Tn?/s2Z&t2"")?gb5y1L6mGwprSƷ[1J>TIcHbNw3_	|ut-iی})$H5$ᙡFO􎺫JB%a2 SJ`B>gnS7N`J
/0e%4P/?ŋ)}@nmj	uh)~""^>muǠޗִ?/$PY#|bϵ+i(A]1zQ$3zX*r
Dg{STH|QC3˒9""?_lFaEg1=m!ːDdool .;b5vxI<C5+b7ng)tPU?+l!Om|<ZUG#
uFj;tt4$
[/.Vphr$_M./Pɺ<s+.ڀ|dnƳG#bQ'`ѧELjD@dE$Jع;Q	gh89
ZiUQh<5w'+*P\GEvNq7&!NNmNvM͚dH^w?-~w$c{@zb8S)
*w;qGx*}N!M2/-(:G!}0eGd	;$9e]4Pm4, .E-㺩Eh~p^okCaJe aIu62S<[et@o)!b]KtjObC*XoϟCHxə~RhTզ%h+Ĉ֟Ox/-:.2tKfMeI7gEMz
rU;ي3(	38U.)F\4II3guB,-SJ>&k4&ɶY=(_8ӐbC6qW`ß3x WJH0j2/oGY~mp XGa=(e=$Tz1MtI1Ǜb
܌^se޸GԩMSnz/
faӗ_{J^/a</jk^hiYTYD7Ǒ
-集LDH䢘a
#Hx,ſT[3,ߑ""ukJ}fTSځi`Vo:Y }pX
9YQ#xj9oޔ.:H<Iig5hRt:ŊrXIBCMpM]sS07ݺ/Fg _ |ȔAqxtnO~
/QS<G\^ S#gHB~Xҟezv!)j_Z""ӈYTۜSGRODǌyv(ܵiA@
Rpsnԅ%7#b_NmؔDZWU}ʂN4ԚgAqP3[{U+N+մxJXbQ_TI+wEnEW7яiUٺIY涠%	S :k)Ijmj=$=	iV
s=7Q2eEkѳpJzrQ Ywixu~LXWBN6mG
4kr^qxzq4H^uI&t'wkzw۫^*NX*$ęǜ,2(oyJcgo	g~f?4jm29Ӓ㒤	sx0rZ_*C%AYh-RcvqȢ+[""ߛsp?\%ye\V
wWw3f^pep9_ixGsΈM#̤ŽrUhtLqj\Mso-""w;:z""c:IRQ`fzW卖lc9# $24
=-1ݞ
.Rp$?B,|1]<TJA\\d7""nޜ4+Çrk̰ ~CnaX}IkKWc|ua._t4HoH27b=Գ	AdD[V3ݧ4Go~EkpItTƗ+,)AmɷhQ	_lc)4E*2b ))9r9sLmg5&v.;/G\҆i#i_H-,1[UsEm@Xک䋖y`۱gc`e,I_0)pܧ4ʼM܄\=:rLYq_)cG!ȒbMi/5g2F~F,2|lvHCY[@oWkz p'
I
U39;Bxc.`'˪x*Pۅq[v-N=BٯZ=}~ӹdevO4{;Dn(50z*AB@\Lq[L]ގGt9.&pvjЙ_m; mRi>nm>`$t)yhFmX.Sb@nQ1I<KiU)K$~&ÛO-`MC+̥2b	d1i4C	G(fpxGfɱf=%pYr!'py_uzr)Sڇ/yn8drz#$~N~bǫYqt[6Y]h2K{oZsǹ5UCcTk=夫:|YO?\8&S,V
""9jwA	j79Ar%G,}sz>)pJyM'*:[~ŗsrt9|%ۦ^UW)S⏉'1WV.3GOޝo`1E;[0X$.T406j:p(+%PP)A.('vj<uNW3P@)MիG<kWnA,1sRJWѶ d4u峅9ʋ'ZE:
$U!P(
B/<.Cj]HF6Z""%}>usՒ;veTWB@!P(WIII\ɕMnщ`j29n		A(,n&'~sՒN)Jި
uU(
B@!p }y_, 
6J$)=
+uU(
B@!PF LTdur٧;_pXd""	U    IDATNH
uP(
B@!A<3'qDd]9]N"" ц^7

B@!P(-KfMP0׎'5N4t:pP
B@!P(DZNDkav!$8""?u?U
B@!P(PjM:$YN稻L$u!Huc(.vN)^OG1]3Aٿذ`rrOly|@*=VO
U@I5Yatj|N)Ӧv
kȹN?fa,o᳍9O6	R*-llDk/Iʗ[/tkֈ3]n!j&؛4\r˚ʏB@!p"" 3m[9B0ms<m$6Q)W!QN峫/'p%H|>wc@k3ng!;*jd<51rRwdO٘t=f:UٛUh+g
wY5Ъ4l8xʛʌB@!p!Pqsa9D?Oj;kd;(8VB'Նk3/؋ރ󦠫l+;o-wC#rϽ; y?-ΣX[ǮiߜǤ1k9,pq/}gN~k߁!-~;Uչcxg؜o4,3LG<X@<ǲebhgtctu.^W>kOD7ba$:EXam?ι	YwBL~3o7(ޝ݋}e9 ?'ǲ\Xv9i{ s7=dOSy&U^<kX;ू^x*}
kQ9IX8k(1Uvs٭=UL<_M!]=0/Uo?J/:9o^{֋Wf]o+^6f&KL+=)/9~O܌0&X(
f!PǍy*v0ø3|S""LWi:}B]l<1k&~gQv1^|CGӫ9f/g=,xnmHQa妛pЭ-}[7i}am5>p>gV!m8=2		g""}hr<ۆOӹHf>秥`pvz}Awq9-#}2=a޿h4G(4<;ȸDnF|cXH_d#;{:FS-{&׮¡j'uPc~|c-o).;X/>1ێkapKS3]q6~b|ͨ}+6 ]`VvY""zn,sa(Sa^4nh+$W?C՟Ibm$Kͮ)򚏯? B@! L
9#LY&φQN	o׶>?K} s-](&#7-CنxX8q""qVùמŅ8(HKW9}goBѠa(*;!Ԯ68}={놢_{Ga^>0h^J=n&!Ҟk|ޯ?ʾEO1㩍
%qD""w>q4_S0rH$nzx!Vw~ZzN oOĔc
cn֢Ōa0kǻbJ[/W^wtSIjx!p/^k+Ĕ<;_vԏi}ҩ?RWW/0Q~w`cn	ܩe{^LuoI[#;~SC8ڻ>ۘ7Y{ͬ~]dG	xAWuU(~#`!_wɱ0i'aG%v_/캡2>#CP9k+j,ywڪ?ٴ.&=e0#ts&.8vfu5-Y1+8>K=)Ctu9|qlbө0Dg|0r5ݷ˶mX
*7&8_mbI/|Q`Hݰ	
?V>˧y1[UxwO
{nm!tzdV{8I@wۇ5ﺍƏgw됟M<3|zC9/kD?5:8 ׽|˙Ťn5ڊYQ>G|5.KqwiuE+zhmmǣq!
""rN""0nʟYτqh](NH
7rӄh~AynnX4$]d#>9:
sxp(sƭxMOws#2Ǵ0'đ/3;SOUGB!""Ȯ`g<m|JKO#*7:tMx܌([;<ُ7<@+B-^ ^~=tMx';?	Χgkus ݏy?LjehTz1ztF
!kFvrcXrDnL<zb'ySj$_MgFtz8K""_;S_5~0t:y?uC䵭SG^gdk[,_#|\r1+=4]?̠Rn
d:LQzPrv^4B2&8f!zz3vTgY/+=-Ӂڹ7	~%u|ϿĉO4RO-=O<HIw7L6/
'Cyy	No忎ϧMx9NjAnב=/D\ӗs|Vzgoxܗ~fl^>mg+|]&ǚStř3'.|ā37wд%9.^:
gWЈHidIkv	n2V""o5%ҷ=:]}׭ӋTIXo3fr-N3//yi~=N<B;>7q]N!P GeN25I<kz*;4\'(42CȘalu<kא۬Wh{o5?~pp_#RSS&(|L1'6|FVi̼z-&e)$v{b6i
0e99 Yfٍ""\m4=0QêgqEێgH7>nk;k9hzsPG>]Y0Ms)DZvD
H[]-d/vcxխ-[tt""1D㾿/mXe|`ËHIkͬ,ZC&!]b}|Lw!s6Y>ϴ?Y#MePBj+udV|iN|iZ&mT^Y&m0iZ`)3@+P(D6H0X%$d*
fO&/~]k.Crr_~
O|	bbӪasݱc%IfZNgkaYayݾvGGb7̣h7-̇X%Vg8xmObb`GϠSIX;#-<lm.""$
137#QOټ9#
[5vF
cEFjqbLM}e#9>9{[pVn`OkYp=ppm}d{#Lv`P
VD`СoiÇ1|rƺj#85pvX t{{ucWi-zRֱ}8:vEq$F/璎FRRzaNBː@^oil^W`-{
f+Kz`kPvmM:o\Ƿk{hz΂(c2a
fn<ჰ81LJMCf;HmhA= 3SE-yE SViF[qOS'_|e,z\yM-ypN	pn
f!&I:9v/+^h-aѮ5轌՝BFYF_ʿ]0_'Y#aإ#rOs۔3z˼g>ƻ@sc87Wm;3pDz_%hnFh,LmהQ(@""<([$""H$kQuƱtn4f_'u.:h4f	澖wãsm3~
GJ|12b /M""p!ٜVB@!86:D)Z͚`{Y}Im$[A7tHB@!P(
_SRM.l@&""lm!BvP
B@!P(PjM:$YN|NuwtBn
B@!P(A H$z0z5|r>'AeHPF!P(
Bec܈SMVt""	d4BRoU C]
B@!P(FkSOj;kd;t?K%Må|(
B@!P4`\DrȐZD0CJ!GHgsVa
B@!P| 3EI3Ag8gB7y6ۭa
B@!P(
,SLx:3?*A{f4PWB@!P(
MOj䒋¸Cg(b''Iqh]:""u_*O
B@!P(.Dɧ:LfPrv^4Y+t4P(
B@!Ad\?LlRɵDJ)DE:
$U!P(
B?8-:LMf0-!!%㴐Ymj
N?q㟆*
B@!P(|#-8yKY@mDB{I(i 
B@!P(~!&L2:9Σ.8x2ZݎT/h'B@!P(
 DYWWY+'D"";$""Ów:""
yy(""B6V硰/hvL*oJ_/-P]w=ݫS6.wԛ?U_Ǯy!KWPRף%y((j^*KD
5xAkFbYm17=oXaOaSQ5!牉xXv%):-s'cKJǢ{k	^4""o5fgK.lLZ
scg5xDL~ϕ^4Ϭgؙ	R_]D)UmܹQ5
d-K;~rdoCwMag
xzhIh\^6=ً69D՗g]*<T[b[$#ےpHՊ1bYZ^gfݞc:sg<F^9ljojl<FxS_-Au<s^
٬ɧPm$t{S|گWhߖKg[`< /	4֣p 056{ȉ2Ϙ*vbrz
G?-@n8lapE2_pslT~S\K')۲Yq5
TYMQ|#'zVnA80-aܵ۶
oޗF7'J+>C,ѣGp|2<٭K<2}O[3-'K?ڋ3aشY՗g
]:<t=[ö%'_O~:y2a	@""mm*źW!5./lAxd3mć9H=ZtErWڜK?ʒo;rT-l?r/W`CɕVđuPM䞣N9^7	3qIo=(?>[4: [_{6;6.H:ys!D	H[b`%i#`4,@Mh$ztԎ(8""XUU.r|1:-k{ KFʊҒԿ7||n@\(H(g_&?Fv,lt}*%iY]{tqik%
Ptqث*PmbFi),veG$	(]C55FfX10zV{/gZjr|ӓ0%5股BQ\r8s{5G0=7'OE{iYX/Pyh:XYr+˩SOS<JJE޽%AqnrCJDszh*pif~
O
zS9i!qt(GENK͈%{.yT`R^Xɫ<a.ģ܊=d%@ޔ5W(C%-pL{m*Jjiӕi0XYOK)=pXgaWD""nud{eFŅR<1|smza+bꊻqzˇ|+.FYbAW[Ϻ1]~=8Jhҹ,kl 7	|'\oxY*sc;_Ef˜#^-+6:/ Dc|(6e+
ĽAB&s^g=`jSsrM4B""r`-d7ֱ>{uS>ŝM=mHAػPVGJ֢5ofo@WO

?I>79D8yÎExqv7č$L4ۘ*`/o`tCxLNJ䐰>rĨ!&pd5G5!D$ħ`urG܉IH4pdڏ!>3lT2r%敩M3	8	
͠[?;5Uvb}s쎞e&#?9""|	NK$qFeqy)_aΈ|$!)11cđÏ/$-CjbN@jiܸ;b̝xJSYeʚzDv 2Çg;=_$D;]e&L'L&I<*WW|`CYQ#K8q.cz"">q$N@ܜg1!_	qD\2=cEn)b}ȃOw5_e>qخW0)h!3c4o~kW1VqON<
w-Ӵ;!I:'eieKӸp]VFϘ8m8Q'LO⊋æÎ
v=2jϹx{`_O?[}.줤Vl?qO/*nĻG0Ko,(+Ã;׵{h""L_ya^S~j3K1ʝqGr)m4^TCB]CQ-zؔ>isX4f6vpg_ͣ\j9A0ms<m$6Q)W!ץE
R)J>    IDATJJx_5_Xo/`<$e#+ pf	5.K
""<4UXwCHX2F~m$N< *7Jqyz>IjeO[IéBV(,*b]tdl0	pEKW%f8G?-9GOp>""rl.8:6qiRʳq<#80x	ky?Gph9#d(Ov0|{h&9|8/K ;ZQgӴwM#ܣR_ڍg\p(v4\X[}Zw4bA/)ٴ+/P۫js݊hƸ?yJίl~a9ܮt8Iob?!%x$`2ȸE+FB*N""Ǳ1#[2
|&&s?OgB.""G.Y
6c<]Z9˞S^:?|#*!Ρ;2kt{	8 d$7czoi{8NS_A!_e""Bo#eYv34-݄[i!ӳXWE㣴)f8ଯ^ OíAKg?ۥ|yYn7wS4qq{C\5|]HWj}5_ZRF2w]HR9ߊ}c͟Qr*{.߉3ᓌt{,!HV$x|Bs6#{Y2,K(i{@#9i5<gfܨJ%|g,M	dEԇ&{-eɣtD""FBJG7Ź]ǽ*lAzr2
nͯ`Z߾
MCX\^ϟM5DSP90BTZ^X*I3x$5u
e˸s(BkBfg|k~3=IX*94{Oӏ1\2ӎ]oi/k
kp[֭¤^$cCxՅh^	2kSP-}iVch}ĥQ,݆
dɯlLm5Q_Lз3I#ig[EKY\U=wDІFY}$wQ}%**|5H{PGtmhj'ȜޟVݧr|s""\vϰ%^=q!w4\ KYx2U9Hi""Nicbt?.0?^\ag;돠%C;t}.pIp""%HX3c#L	!32+ I}3B
k]Ìv%Z(S'PaA6=9v(bs}U|.woHp֝,# V6rXBh)ۤ=pC%p$kNԐ2;LAtJ͢>WJDkJР""je%ܧERU׷pφS:1ne]FpE""qqŉ/>gR'eθ}֡{evL_+._#Si""Bq[o}oyw88TMo}(s,$c[qnjOr0Q	EB>澕 ߻gr>)TaSnZάEy;%xWNy/-8:""whm&yM?&aݎbčv+Ο)j͆UvF<Hz+;wya>GcS2""|
~Uk:/𝗰liҴMNryÎq	`wX}hԂl0SFhoGcYx i&hC""??KaSoAHNÃ
01M}%Nb%5MB4tSO45q#?	dh/(> Yow̡d~yڴof39[ie,~s;c.cҭB8itm~6ב8|[EV5.rN<asToi Ў0	2s^7oCojJuT7%js%:4'W!OAxP:8pe+%[v&gЋ/}'ttA;NNڡ<\#g]:~D>ī<87
'8Pn2V/7f9XYh+ONXeÑ#+v.YbF8p<ǶA>ۦbAsV_68!l=up7ggw\eďBnD*5gLkSoop|@qC-@\MKr|<G,&K8eHk#I6>H'!G>2'i
KT79%X>!]y;>=j'y!mȕ#NꅜQ,=L$j}xX!^2U}KcɈF8s Wc1hXJ\*\W!փ$ID!|)?0<J`#<)7~Ǘj9W<B{tp#[N&1G?N|/f""}{1}v/*= X	>bFznhXLMS3ʠG?&egݠbιN+GdӶ:WFq'Dd9yaTJ#""=ylxM@HP]:7㧕ː$/&a+~ߞE%l, 6YnX93pPH9/<ʛd<2_ )tmE-aCs :2
A43y^0N˜if19+6!97SH`ܢTc[^#b^uayU!^2RBKDg: Oe c_:1Rg
,O~!/e2	qf<;6:%o""ÜӪlJѶZwi?^M`
$Lˤ9EWfa0Ϣ1wC-CS_M2/X	oE;ׅoH%aVi 1D*
ib#eI_p@4E@ϸPMEśGk\N1n
A3L9""vM
=2=x6/h0Mܫ)#\sҗ'\k֍{͊rd!_wɱ0i'aG%v_/캡we<Ã˦qX>{zrCjTT^GcCPKS8ؤm
Ea6O2cPRYć SP0HMB)Rq0W1~ÓӰxSqUZO48~Nra3I1,ӶwgNZ^E2n""׊ż*>JJ	esX뢥è@\F\ŜΣn`)X""bn]
M6>޴|\9Ec˅+J␷9`'Uu3
ˈaև;Q}A-?mȾ+v1w	O\n%7Rp
0
lٱ
a򥟌3e8s`7(+rpd^</X_ҧF~ZMdi#2Nf#yl}t^ f~92guZ/զȓf.B8-ۈikPTT
J(	ag[\lɝ%ṽc@2,%21/G""K0
q6m:[.&0
Pvg}7t>G2yya7[,`#W|""Ng4}%}}ac᫱8p߲m;բ9h1'.ټmDoh`ftI_op..cEp\@E⭿=#-OA:ߥYyCaGk*ٍGb|34C+,B""!""0nʟYBx{(B<r%WXq
bYե\xM]^rg~]i|-KI@n\5<!V.tt~)͉؛OFw
:yd5o9^2oPu':y	ۘcҕj|CTL^@`nH ?R#?ԇѹ/1&ck$?V=@WWpU}\Eq8qDJLcou_6o5#AȈ⠬ĚRl̋2-,uKq?]ZH^E.&p%gs-:r] !aڃ7rd?}f
	KPMmj*V?M7	נ we	t9=r><q
I!u'f8Zb|H4LJ1C,X>R}Lk
I#yOֱmd{6~2H:ɓg&֢;mHx5
J!EvC\lɝ%~I	f}=i:aߞeFvkiiLC'@X?""Ҡ/LTa#@\ux)%͋ pA
H<L{G8qфؽEis,N˝D^ū~{zrqXWz~pZ\Z~#zoøn5L))ˢQӆ""7Ҷg/>=3<	g3Pϕ<6e8rwPfZ<eqv	/3؍u\7|]d
|'|	ˎZ:KD<V7%AqkSRzCC.:jzMZNR΋Wtħ*rb+
?;2z*RFk4WVj  ]>uU@	g^=V޾{{jL\J@8;eV-Gl&l>#(ǔz/}${QxCKLH{pS3,h#<w`aAmg;(ZP'q隧fdŏ 9!yZo?Jؔ֩Gl;p٘]G߀7sH-~eR8gLE5xqngB#jU39;xe0P7hܧ?.-=
lqޤ'iש{=C>|
(TNNB(sbvx2Z -A>=@|vR܅wk[<=Fu@/}sFhF~f.S@nQ1I<cGA9xSUZpJ&৽eaᅈ$^0rA\j /pJ#UHǗb௢&nfɱ${C,6<5^>B}U/.$LX	icQ	/P
=8-ZpJ<\nF[fa֨k\zcTdwBK6A8Yz.ۜAe525I*pW9a
gx,#!ܒevKv3ZMdsP^EX05'(M*""vo0etTWnQ*}>ǿNp>wxWrs̭rKuj>Nlh0ax,1>oG?Sʫdߥsc5\;Z]I-gڷN;hFp{+MU/_bNA]ɻĎTї]T#WN{ޚęM1FLSVWaʬ?Dc0Ê'iNzݹA^i1db:un|.fn⮌B@!P(
+ DYGY_Bɓx""3I4$0NEʴhv:̭eRW(
B@!TM,
OZC})N5eRmDދQӁCBrQdr;$}'m=^3HZEP(
B""P_O-'QYcՆمl֒l^ 흤K
{ ;v܂}g},~:{FQ?/{+􍛌ُakK37`I!P(
e@uk]8NJɟq>pN;t:p%F%=}]`ΜYRYgJ(ܾmn%]yeJ/'ݸbPw
B@!P(^Lg:Gզ""Pi<mj!BBFlO\o`&\bsW8ƛ
B@!P\Pzn)&9kFi# OPèu	ʵOLɰqQǊ= gTMf*P(
B{@e$k=M!v*v)
NYn5n z}XF8d8
ޮ/nJϛyƢ
B@!P\s:O%
b	F$hO$
<S""s""t6ͨk1kBcX_""ܴ
i=[dTcCoEEI	JK	}?QJ}.o7gF!P(
 e(rg""rFx^x,tgxSn+7Z!}><0yA2rxCtdCjpj
LKM%/	b:+yda̿+nh#kP(
BvS6yr,=<̂`څGv_5sT,ރ`DD<
	ǟ}>sY<8yGM|Q
B@!P(.SSٻF.('Msh]:""/-k	V?#""VVqҫ6^mn=ptݏ_-OR
B@!Pd\uv*hV<2ܮܫłkwm^[0XφCg t 3dJ%D%P(
 GeW&\K dBDt2^WA3B@!P(8-:LMf0-!!%>
dďaa
B@!P(
pN'Rq%t^sjF,W۱cQFuU(
B@!pE j/{_fU&gDDiCV<HsB-ox\SJ,Q(
B@!hxf)']D!$<'1rDF'tt:Kn
B@!P(Z!il$C5A<>pM9%ܪ""B@!P(
??*<ĥ5Zm]f-O9{];IS-$\M!P(
B@ѤJɑu^ :QwQN'F!P(
BLgzʱu5ESx)M?*?
B@!P(NDkiغiUi#ᴑ|N
5""c(.vN4y3S()j    IDAT>ݿxwlo#6=r	w\`e<HeʠB@!pu!Pqs5B='6!v*vMQpʢ""YnE:
$ZZO7#Z4K90f9~[mxIz?OMŬeiDklΕlagcB""֐ֈR`ѺirioxpMHŮP(.1ugda>gbSiDHHgT_>
7h""qߍ/3wV⏿直lL]3tj\DNS/'ŴzZ@kgk:FYqhU6<s)Vi)
ER[VS^ᆜ=)?0^}ڰ{Q3~""7{1{0t.i+;o-wC#rϽ; y?-ΣX[ǮiߜǤ1k9,hV^_:j<3W_CnY[8-
c865sױ9wN߀iX<g&Itoj?Gf-wwb_qzHI!fL*_agq[L'0w3L|iJ?Ϭz#Ys
^*腧ҧ5x#ӡ=ԺTKb}
o-%'t(_üY0?-|#&M%ݎ/+N6˧Qdhv=JOKb<7E<1-ɟֺ2
BGMNDwɱ0i'aGv_S׵f᷁{kw0lx<
m""}փ{ʂ職ۆt	=[n	7
ڲjߺNk,=+ذ
iIHN8+E6}΍@29?-ˑml>pi̞7}}G>B
Ź{1x<G<(֠pY>'fa1q4ss1l}i*t:""јgC<;wً69V tboäU8Tף$>DIbo̙\NmTyѢm?_ބ|֑3yC՟Ibm$Kͮ)򚏯lZ O!P\""Qbj䒋¸|(bg$Cn%!R'm21l}~
9^MAZQLGMMPa&G9N~$ ^{'b 7MQuUGzBvBa(*;!Ԯ68}={놢_{Ga^>0h^J=n&!Ҟk|q8Db1rM^֭scScP}q)$_{5e|WeLGR++C&^V)wCyvRqh&N ~N}!6jz!t;msK0N-+bZp~M$|֑TG)fqzϡkfmL䳳O6&K~ ʙ[;
G	xAWuU(W$dH3E)CUyȧ\#a㉞DhxmX얍qM;!ЄJ>҃fcn$TN7>k1fpçb1eH424Ml:oFt{f[Vab>F]SBaOfn'}׸{k|Əgw됟
ܻ<~.ԛysr3u/_uJzw%fuĮGl;q1iuE'U/gh B@!p!DvB#$S#t^#|mPى:FN	_W!B4m܍.kHh/9Ows0g~2wwɍdʋ~ʟGT,N=~Weo)/+
Ae/[
FTtot2 9F8\9
@T/M聅-s7j_034-!Gd>0al6o艝)Oj~ؕ#pRJkӛh	rk_C3
U>#:ۃq̡8MYFbWz#gfݐQ
BEA$w9n!A
%Lu'~?
+uuG~g\5oD0ڳ8^V{-(>qǸeuٵ/qS<;)txKG Og8R~bp
SB`ÉcP^^[())&(޸wμpvRMߏ5ORC2*+>3gN o]&V5fnX:/ɩ˘]X:X
1	2B3MzXf'OvZ/c+>=^K_2zl,}ܣw;xϦHz+YN7oqןy|KwztqSrTw
B
DyAD?!((3|N""7ۭa$XL,~c)2fs:p7v?57f
ꏟ,$jh`j
MOѯH
agkdleXv?ws:\Ѥ!%ٮpO&ew;1$.LT!SѷS9D<O%A7CVյŎt8^݊ѲM O7-ns@=:B8Y1چy>㖩
/""%J63\,07y	:3cfC4y`E>zhxoZ|ב|ӜdӴLT^YkGZ;`)3@+P(\DFY''}ڹ#QP{
ts6|]~'OP
<ر㒤cςpw-3/T5;uZ99{geEi	g>j^/8Ù^C춃xوzwK37#rOټ9#
[5<.0;G\""#KD8>Mβz5TK=NWU^珼Bh5;s|n8*B@!=@`СnTk>Ç{ue
_|GpjǮEk´Su!QRڢK6HT[nWz
Yt7Lr7bXB:\5.43/+8_Be>^XhH܌,0)5
 }l]}%yA$	g x1ZΩ2 T>|֑ߙvЮ[Ǉcد}՟#/,wypN	p6QY!p,EDNfMP0	hFBE%M9*2vl8B!yxwhn`ܼv2_}nߙw#ҫ&2/	?"":vy!a2z_ZS^e,vSK0M:SF!P\EqNgj.;0M2a$in߈[]!=19՛1sk)Jc`˨Z}i3\t;dsZe
U@0	ѤJi}Gx!u\NN!P(
BLgG5V2Mk
5\85EEis[HGʋB@!P(
Bh-mTmʜN!6YӉl$6Q)W!Q@B]
B@!P(BB='6!v^(883^mQ(
B@!hY|=O%	>aqg0N1Gfn'^o{B@!P(
K9cJNzDP1tM
vkXB@!P(
B)$KpL;92?*A{fViP]
B@!P(ZY@$|R#\D:C;9%CGZ
Tl
B@!P(&Ŭ#m[8Sh{OQN	uU(
B@! KHF6Z""%ÔuDuԍ""P(
B@!W""&3c햐qZ,65'øOJ]
B@!P(<{O, 
6J$X4PWB@!P(
U&gDDiV<HsB-oLT
B@!P( #0H9j:k$""Hdr^eOn4jN
uP(
B@!B.9{S;{]kyev8	ה׭?>(AW(
B@!zj9A\^cՆمl֒h^ 
65@^<T^~(?(-G~QEA(-C~V@VVO ~F['yjJ 
QRG:*QR*?bW^
C8*+w9Qyx/Ӽ*^HTm17=oX(aOaSQk1~wg@/qDOl;\(t~V:/,F~|VlT][{)5ׅM[Kat,Xoًfc;2AW=M;w5J5BPE""Wsi'?/ZmyhrSB/8y/""fۂ`WlB+x n}<""rvϏ 1i92Gy_FeMU+OHĄw6?Yx1}::wַH>?HVc1HV*s""Wx̦}G[3f$)/@ESv[BRI28s9m\1Z¡6;Γly/=Y)>h׫W_oͣg[-Kq]LiG ajl(e
1U,[~%9[q¾=Rm\|
ͱQJMrr.vnBf(Pe62G4qX~tqvo*y_*
oޜb+Pf0FtPJ""bf.l
]xlJ<q?J\7I2g[|T/VΪf6Իʍ__w;ha	@A6?<PoY7K0?s1v U'LFCX Du!䌯El?݅W,}yT-l?rއwg]]g$LWLG:rq$'kJ>*84⏯Ы$x5*&ͷ͸/?>{iu  d9rs!D	H[j`%__/A+Jp5:b(:{(?{WeIIC%ZXոXt,N+^]Zʌݵp,?/
ui!Ȫ)f	\ EE=!~3pZf38ygf|3sFVM
pA=c' ҋ(Ó󑹡
1`d%
>~C@xH kɧոg$&Do4TԤ 0Ɗ-Er:JҬ	A5aC8}
ΦԞ.N;jkO!!j7>`oov5\бº	p[BJq?#Dj41vb8ZPk,~fx\v9i-xb>h@!uK
ż~a]Kla瀑wMwZյg1($""t""A
q.?cpƇ酒dpy<e""FO~=#`7mv7y~kCpDn+l""a~hhlB``4Ip|~4yq0j;̭23Ѿ5GĹ/ssGO|#ƄAvil,8/9P]7BH1@vu
2rp.%俆qLHU[wg)l/ƥ#ba>>3EO?gzhش惸ҁgMXNzǱlu`mW <Vr=B""oJEGs;&y/'%ToR_?ͬu[)	y6{ݎtזL+-A`dP6F]kAN;*ޅEƀ@Tv
$)t&̚aQXW\%a+)AERRb=3Lxk F"".)[~iigy(1kȨH԰h$d-h'$!!67pd?
G>ZEyȱ 2Oܦ	JuJ):QpDEɥ)l2>ҡX	
F랐ȇ^w""|NhyR2 _Quī)BY
DXHBR	1PeőXKzRMBv|/75G5ni,[úʺ&""-A-cQϣдSYPDEYqtL
GBכ)VĠa#IGJvUo
LB8Q?C""<J#ZXZ%̃ڂL`3p{-00`bj<QNw&?/a}UHe#MZ,kojo=I?Ng\K_ҤJbKe_ƶkp
H~L$5QjWJ2UŉMY8Kh]~3%)9cLbvYf1}hbme]ux͏#iOZށ쏦ťCɟ6ߎF;SK;
2aqL
6aY՟
p5Ӯ6;<&:۫$11*2Jl,CT?}1SeX*Rz>s;C.i%JI]F-0H_2+5)x@C:u"" 7/՞!""Vw5<#<#
縵~{F=}Ա# բߍޅ6Ί\Y$eTZRVɤ@>?A܄Տσ)k&ۨ1~5ʌqèUqYz>+v$'jBckr42dL!9HB}'3 \hɈG#3˱w)<k|QVsL c^=
jPWCQ-4SٓW|3cs1<GdJjjfkEڒ~$0Ɋvii
!%wm"",<aC2au>1Yji
7H
іZgCvr$i9ќ(I|+6dVW]rϦQ+ibc|?yJ>DTc1OixIPr(q|}i:#,ahhd8&xeP.T6!e1[z2\]ڂ8&xI4hrbifن_p |_L\lͫ6SAˏ8DE~ʀM|E#?ac[sQG$ZZrQ׶j    IDATStZSE&);t+ɖ~'k
]
dl'QWSxaAWSB1iL56SvywUq0gKZMMd.|?F̦}hReFQV2bi֯#I>ôCtjIV0	oo|2GDۈDe	vЕݺf3bCJė,ˢ$MV}zR؛c'Q7f-]i~:.bqd._Qrcŀ;BÐ;@ҽqpyʍ}m|m؊w#si&8lO}!ycbYQy.ȴF}B~!Tgs>M_^@<q;Ξ_>RKtK9bڳH5*3q1p8uݭvD:fh+QW
S'p򿋽23_W Z {
`M޻rÀ=I}Ѿiº\L▻`5GMۋh;glε+QkvD;>Q;\v[XYG{=f&! @T!(	廘wiGti+jFe'2p=)E$u/6,BObȢe.D}8(ƮE<	y""58Xa-tOAAb{Kc2F9pKP_=	S̠1tF3:jq}f,(|*:Č
,m{NZp$tL۰tFdK}YLXK""b0Mt~_g;u;J<($'A!nz_ҌZ$IoG
-1oۮLy4oPذu/ɱE'WsQʓ:n#q.<`$2gbw]6""d2Mտ>rߧB'w>bXKO[Ѻ,/_	e uDL{t.xrUO%R8GD6WhBX⢰\W6-!.2)X'˴zc@#""yPҲ'bi1}`wNkNiߎaÐG!AԦ)<:qRc0:nL䉚)$
Og%?o?DN3R0U,;0#{&cS09,(Ϊ,-+XEXy#ng_a.xM! ǎii{$U|g4ɡ_3v<}F߾}mM痜LYAGhCh8?ێPSXr5k5JF)&Lhc)eN
Q2j8ɢĊIш]CN19`ǅ۰0F0^!LjqW _
煖^'5mN1(a|٘%DiB !T
8m+d|Mj[6|4Qyfyk!1ц]43BN̆-cҽbN{#qXF+,1#eZ;[@jܷb pcor|.]""ڄh|KraČ]sV)+~
'D܆mSA%H[ɀ!RC||J_4nxuv-'(гtJtKkna	>9RAHj,4n9Jg>Ej:
	g Z$~#ۘ[1y|[bVDKxy߼e߶/4w#ˡ
yVBt{9H&:'q4yAˎ؉X<2to-ͧ/|GiOLjCrv:;]!ЅɉJm؍Œ{q5nOǊMBNw((f]t%Ƅser={q8U2l=8O-H %j%LEi O)hJpxtGb`˰w؝tli.4rAܬPz3l՜Nf]\T=0f.R!SBylK9gqv	)XĦ[U+ڈh~iumo[[.(q~)r~nW7v
O\D1XSvk̩xvnlhSv&ov^0ԴMjM`ؘYЅ+{-H!PH`@f6{ގRgx>ZYFNA6WEs
#ڒmg9^`}G
s#e4+U(KN9B[Gx\
mWTWp=`ܺ;f
V8~$C/Ōөi!hVLZ""7gcqc۟y41>;Njffukʃb0[q7c
!PG]1l3A=MItt5s4!=,cR{WHas َaۢkQ[x?;
~ۮLx	?IB~|6VY70$ǊS5]Ѕ`$/-Y@T26~r}}M
(mfJMBU?4+=dLpOăZ{N9.g-£qwWNW1:.DA9J_1-Q$;gGE)o`EX_bՖaJ: bƑaE	%2j<>	FfctM""pde1O-Đ,ݬGLWESo/E""#yvMt®lWa)ka9lD̜vs촽i;:
UŽ#1bl\ۚn58fs[>wzxnGcm
ѹVzbfZ&͢C'~cc9:K<X}{dpM)
7Jē(WbI	}ÛJx/fcf<9MPHfnv3ae4E1/oeH͌סm7>JD<1fPnHB[LP1۴7r׸;1iKŮ0CLrYe20Y?O!$s2QleCUE#Zw	
N
45؄2b=dx	K>cL׺*6Mv,~(mdS**`Wzb=GszB޲օzyJQk/N<a4i[
!Umlǖ}.ԣZhas[||G!=e2h/""Y\[:&b(KMMVBUURd׸¶VǛF䊃+<:jW&9piy릩<?y`f1;%OEUh~Gѷm_jsB1EC4UciY{%E3KmsM&'+)5(&1'
8VȘ	xr铰<
v.IQڃ<|;kk+Oo7b汷J>㔸Tpq&#o%BD돣/3lsߋ^Do	D^Mֳ6	 #S:<$K 
LszI_ez5?xi␕lrя_D8YyREXirB
%(=ypfLXP
-j]-1ɱxw3
]9Jj< @uP\myE""&[퍭893jZ7'9Kf-Mr3.2L""Jql*óȭqH}غhѲlXHԄ+'
̔+4etVwt%Y3蛐b{xnW)""y8rJ<ڼiY[8\<y
byH(Sda{ng2#m.c}Lv@MLG?)aמ_GbBҎR#yy)|噿i9hת<g<%ܵFNI&V#}ox3F`:e弩{Z&N(fd\4~Y<,[bʱ
;6g%GkOlNqŰڮ""3Ⓡ2nN+aI>^.VzkWS`-q\
<6~yKpC:$Jmr^5,S@|Uwu4L<xr}9""-1TddemA{rHf5\F~ڮr(@\#mٗƝ+'d\^
	.@jX+4p>7-gFK67z
cgx
=,]Ib_~0` #_-%ԉv]f۽{7BC[ov%W 6QKC<NwP
nƄ%!mG[i9A=\-rFpj@\ǼԘ8ip~v^hծOGdro_k|rďq[{~/G6A'juureO
k];!glOI,M~`s亐T6heK(@!O@Oo""WڡsKN?\:΂~Ff݋S]*7x}:4YӏiWGGB~xWM׋7Bx0񕰫a72u|K
IW_87\n~|l÷~m|X
6կhk/XvٸZ߮[Rcqɫ&_a.F[<(7f7]uٳ\J%QqH^?wG|'N'Srn~-'@'.%磌ذNnk=Uȋ:!<tyՀnE&O6(E~rYQ/Q/7M:x (ȼK8EG7+(ty&4^X{r,x	3ع~5OŪ[,-vpa<`Zز&wvw<v>NȟZJٕgwa
q3O"" |Jj33yռW-9N]Hnk7S=DwKgP_am3RZ0
!S*/'2)t~kYEUZFx=z]u6ԭvuʋJqǴixoxxQ=_xlk;׼\['~އV(K݄)))z	s#^nM]h;ſ:8BZNί_T
B@!P(7Mv
B@!P(W6+WI}ƍ_ev*/B@!P(@RRFd5YS75XJ
B@!P(PhgB@!P(
+:B@!P(
;JtGC=+
B@!P\yE`UD
B@!P(PB;Y!P(
B +CJTVj]\Sܿ{GQnZ9>PSx฻+jxP櫡X_C}
kysvdgP*KB@!&PB5٬FΡdL̜_}f?̴?X0s\KhO窐2:{R0O]~W""}w|uQٰv^xܷvW/
B@!Ty^ࡗKQZZFne6t.3ѧ+u`FO	$~@hW(u3_|t^(*<=fڅEyx5~ We\|z#
k,$\ԃB@!P(M
lf.?}J╗vacbi÷jP2}SS3'\D{o%p9gM66CQc4EK@1+&(ppil!mcگ//ա0zy#""G4<2e)_Deq>`U!x	{4|EΣR-No?q,|
d.""-ǿ8]0Crn[7	'@3DB_ 0h[XہG~)ySL27_#F}G</0O^AïY.P(
@PN]Dci~>s+COcM=%il;-/0!\=ك4/.R$<Wsz:%#3X!<0aޅs1 RsH3s}<^|Op?jCKU?Q<0]CP}xz
u}i)Oq0W~>%ͨ,1?}>""6*0d=;!D=w݅A7hkiϡb	p""	{XDM_'~O;ܡv1{xq<]]cMoxv.ņWWD륉ڽ`z)11ҨoB@!PF@i:}#a/ϔڞx	o^;a#wtωC}QCRX~\8O*оTqɂq˘w&Tn_XCjB㣘0{yW';0Ǚ!iW>wsҡeLA<=u4J
w^D_^_S	2oo;k1m(L{eLYQ6kīx''N=/OQBJ?'o)S0HZ~JhGTԝԠt^x0:fK4ЂZidmzp8zK9oc*_B@!Pt%t`|x%~}__܌GƠ4Bc9y׈xwC	ie9aӘݗ ^X<nBEzz}xڍF	&cHһ&j,D	ZÍFdg v:Dn !r"")O>XKgmE'3GH*m?d~\Bjn'xj.D'%ipaO""i4шFn~rGB@!Pt%tvݗp#""^uMԨؙi(\M4c;s
m1vڤpؔgӖQ9~Vu(Ф}$S{BxQmi	 84Wt4<괌B`ZRR|,{5f7
؏9ߵD哨ۉ|t	ے'O<j gO*س3Eq⩯ar j1ϛyࡤ,s
B@!pP6 y[xa:Ƌ/0\[Gq1[wqw<(sIoo    IDATbVascxM/p^BiGQ__|kg
NM{s2/pEOh#Jf<
:BVWY3gclGF""s,ҵq<""T?^Gg۴\0?훊QnfچLg_=v0+=0B!x~={i5狦/ГCoa*
\~<uě+_B@!PE@i:""ރwq=iWlzE6{sN(s~IRU/LneJJiI(W(<Pc WCÛO>~l~
 4u>EUG1Q	4N.ӒL.$R3L%kEV3? Vc|BKzv_^yvc-)>|~HSy_Y+0+Z|{<e!H?B-kMy(
B\-%]$.|^S.%߽{7BC0seƍ|l-ZSةm2^R*/f/]l>_t5+uh>ޗHxDȍ]DsĦMr-ˋK[<߽C3>~=31AEڎ睦oq1AZu_iI}+
A`ر[QUU{G3={A޽巐_=8q]wSN	xa('7Q(unxFJCQBNQEկfO|lvn~0sNY_wЎ睦HKqV<m}XҐ'
IX+Nq_	-('B@!ty*
 mmޛ&({vעxzQߛ}&ּCZ+n)|xqr
B@!\i2I!pwJ[Ưr<rKqԗ51q:mqKQS(
eF@^̀*r
B@!P(PBg{LB@!P(
eF@	PEN!P(
B=״Mv@9B@!P(
kV:ujA@!P(
^WN!P(
U:fPP(
B@!pm#k}U
B@!P\(hUB@!P(6J輶WN!P(
U:fPP(
B@!pm#k}U
B@!P\(hUB@!P(6J輶WN!P(
U:fPP(
B@!pm#NѾ&mߎ&%amD
@K%@m;Jm~[I>arT]<Y
SKe2utV[='˶UB@!kXct#]OMM
Qe?
?IH{w80RvqKXƦYWl؞<4}Z+.f^tlut1eg7`)qU%r#`1ezU^Q\JłR'xoǕ;@/75@W""N#uxWxU%eڴY !i]ac+y0l먯:!6Uj?;yc|ǌ[%0zݶ)b$v6ٱɎ|qYe64CMe
~%EC/iE[5,trrjE~2d:t8Ѓyl}]0wNŠ:GM9z`+eњT&ĥ[qgTwFf~0h[<'""n_cźXQ;,[:N4  jmyŵݢ.Qc
키stim[{i&Fk	s'Qp8weώ0tCk׻	@Z>N֓'zy4o鷞4'R	{
q,#
w~0Bȅ,;{ 1@?;yWnF5_ tkN(ٱL-s[:kP/zcL?  dP n.6>b{o?cM߲,W	XWzNsY}n]5e2_""]ĺUQon!ͭA%7M_Ev
8/x?r</Gx@Dor1Rj
mnc[a|jn}0x4L'*QpB""rd`PG:ޣ;v;-2<9;0Xz9P[}FP7p+|Z}FbBdk""1
5)pb~4+bzc@Mv4¶N_~G |g12DӎSqHڍ(؛]C
0t8n91V"">lܢi'.H=?F:@EDF;ׄrNt)PH]RC1/?{z[?E9`]A`=,0=A!!I=15""4܍oSu4>0>L/$Ӏ+(q. 0Un[=0Hxs[V{aw#\x7kj?T	Gd(~?!f臆&G'Nȑlys!ܪz,;>[s(Nr;W<	U`Ę0.m?%gݡ%qA	4FWH֮NCFn_#p~2Ij""v E?Q-Mv/FNK|c}
8jz)&7+ <Vrҕ0>qXqvR7:7=%Ot>=1WߌQ״S|=2qi>v离mR^ #0^C@x+ES
DLhP?~WfMŰ(q,++JJ£cXjOSg5D F"".)[~JK(?KWC	
e/{QaH`9L[NHBBl$~oȼ?|?<
X}'nSq:%eh(y8""6}zmG[IY#uOHCCLvJ'U4<)pKsR(X:D,_rS"",r$!)ИeֲZ,Oʂ%iM&Zi!d;G_5a]Ce]Ö@|ьQtNY(8END}$trmH8⑄pnQ$<ь#3/£DxL0""MYKyp[[)|l.>x_b&5Lrȸl?ȶM4yq샭@*mHlfYu^ctZ|f/EphZ/Z%M$]hl;1fw'DRʽ}(oZUؔ%k97SB3$-f>یk#qڇ!FNYՏ]OR;a NWG\<
qd`NOsr#}0麳 =.s(Ǥi[mEA$&""Œ*W`yS[٫$11*O,CqːȰR`EE:MD%Xok$Yab@3XŷHsԔTw
vNTa1& D;׺TXGNo1
lؔ<:,Y#!qɣ(gbb:MM""$f[LӸQNQw1̶<Mxv»5/t:vZTWWQ0fF/h
]Y$eTZRVɤ@>?A܄Տσ)kEj>ۨ1~5oqeI|WIjeOǅƶ	hd@?iC}sΌu( ar7Z2rt9y
Ϛ=kal՜0%ȘW²ԕS@(\ǯfc8yl38-(D,1ִ%H`6ٽ""V
ص<aC2a#r>,1Yji
7H
іZgCvr$)97V'ؐEZYxmKU]rϦQ+BLCtS1&j}
Mó7H5F7Ks%r4_GXcB||E1,M-,8/ú2^Ӆ|""dT<;yB0bˁ&~3\]ڂ8&xI4()14al/81Xy/&.6U)	QQ G[""""?Me&vl>M-L9G<\ԵmT ;o	nJ߉ZC׮d<(I ^kw`Ff+l]o]shh*=V_,O%9iBeQ""ؠxJZݗ'#4()L\PHQv,4݅VGl0.(TwM<QY'tˋn6n+6D|	,E\#r% .@R$H~rHw4.B1<yzcҥ\n=ϱ,I,è<C dZLX#Gl]\9$E?D܏1{5ޫX3D'þ̚5
4yŝAI|!	ٚ)UZ:a1HаK>|Ŗ,ID]׬V|IG`3zE""JG@Oس/p,TmMu	5U9W=p̜wd@1o""[%FBUbۇƄ.?""]#TX8ïo'ɭ2)o)XurÀ=I}Ѿiº\L2$Z/D|Q""'*B;s-@Jΐy;9Rj&F-x)9n'+0Fn{=Iͼ),Y}ha]+\vҎVbݍDp	!p1'#VG{?BQ),p]+0d2
o%5EThB𤙁`4
Q $6͇fa?-c	8s	Ox>!
Ac>_:fuܞ' o=30~|-OČ
,1_&z.g=@H*)|p@ߌb=_Uek+8؄yd
ѴМaϪ~܀r>}zlIoRHD/:VLmԚiM
Yç{IrfŪWs80eC6ghx&v0%Qon>տ>rƧtr\d%\-.$dB~ٻ"")#gx-w);ooL'螉z}ӝfd'/m,d,L{ى}fü`,j
,]E--+K=C1vom&9Wisbf tɧtd%ícY$,+XdQi]^u[8ǌUA_/,\Tr2z^	3.Lݱ<ZE`L9^sl>;X0h^5vg*U=?3pT/""Q/{Xn[5u>wMlLzE3_A^󅋑\Ӛ/9똲6Kv$pX)EHϮ߀nZ~^S	0=9kvX++'+f'E#v&g;dnnöeN{0aتM]I_x%sTu݆7gYBn&@mC> TnC&d=U6|;"" ]>,ȚgFxpkvmq9c""b2&ݫob~u$)p̋]Z;[@jܷb pcor|.]-1ڄh|KraČ]sV)VB(Rxp>ض
{O m%H
M(}q.@Iwu.|؍@a(W-ٻ&vsWZEh!SՍ0GI!'D}QE3e	gH4""U܂NAаp̳cݪU""Z+
-3}񼳶^FP˰ܦɜ{9H&:'q4ytNB#Nr]og玣4w'5m""@;	9wxx!(V8| )CB-ai>#Y""uᅵĘa> 3;1xs@үVT`jhSIaQ RE8.,&aAAnfnW˻LdD==ZiuvyvmG1zb.wM89eѬ0뱓祰LiZ0xM1S[
:U% 2^k-Pu̥
ԵVl!lR3ׂKCߖ7{wwC~O\D1XSvjzЩxvnlhS=[/k	LKKoAMK3ʄ]WJ!2kln!X-жi枷TnoG+M)zs
#ڒmg9^`}G
s#e4+U(Ku+
FnGe&sھzԐbJn[qGq [`L7͈aϙq. >`:52,S,PC
VLZ7gcqCLvu'{-c]2gʃb0[q7c
!PG]1l3A=MIt2a9Axag1sl)߽^9 l0mQaM(ƭ]|!oە7!'IȏϦ¾ل!9Vl	.#yiZ񓣘?ikb`ݼeLxS2C{Cmn.2{ZVw㩝|)7 7bH`(!nq::A2}Ca56i)-Ҭ<	FfctM""M v6g,{)yP݉iv2X=AoK:k;""m=Z(ą%8Tih϶2s\@q%h2W<0.Zy95?s-;=dQlm[ܶxbfkg^h]poz[`?'Pgc)rsף'vaЂL	?=LYPƦ&-EjBpMDLTnM#wx43еMBwBN!R1ۙ    IDAT<qإmMEqEx@>eۅж@NbO[""vUH3D@
(qeO^-k9Zekܝ4%yXba!A&*rYe20Y?O!5='MVM<T5pX4u˚0TТ(eɋ6`ʌ""%2K,n,3]:""`p6Mv,~(mdS3A6ye'',6KaqУPe9S>5tז_yh$glRnc;eesD^roۗɠ%(3gkm!uLPQQTo
/~gZF0vP
ӒG;7qp4}WGfOf\7M3y(%}
7x*./8aw&Ԕ΂e?(W}=mo&R\W771L leiCZyqqufPBѳEƺ7Tf<|λgkݏ[=,PN5""nY8hZޠ>iTe<|
kjpfWVsMio7og?ۚPB%-,{ U""N0+;LIz~ؾsj#=,I!䋦0H/E+V輑h4VM|vL},Ȳ""t0q,ZJѨ_ ?""?ֵk)#~,(td%Sñܥ^	o<YdDqvYirB
%Dlq
I8W&vbZb拖ߌˤ6Z;>6fC?瀺=bʃR}Ծo3[ 0/.CAӌ$tu(O[A_8H#$>tsia
'E8 NbOִm]eL0<+'|Z,S%deنd@-S&Is34e""twIx;mEƊu<t6J?3,s(O32QonvT85]:K6@DQ&L:O\MaHgᄜpXHgGͤ(яGwk/Bm1!i3Owq<rЮUy0yBRA\d$Z27~۾L.Zt<2҄⨧e7R.vj?^C(Ϛ̙Xbʱ
;8iǊd+n{XtNA2tCwVkɁ3nN+AyeDNүZ;!Zůփp	~ހQŃi]%#Dfs0n}b9vk|+ftukvLEa9D1!3CÍb<E>,9""61~&#9npNW-70ٜ83걢&g #)UʂȌt2?ԲlXǯD #ԨF#-6h׍vdb I{oe Gn^9[3ByIEj`fMMLYHg[ϰ|fe|OQc5.\-%]>̮ݻwÄv%5QK'maWbi;JSN8ߣnD@+5v!<m} kЪ]<vWIح:y""kh-:UvDĺ\ONj8e#/qrn/13`mE4Kv!5MPBD>&C9VxϝD+~t/9!yϻsmTnOӎPtY'2g.F[N?v]kLBAS2Lv|%jlڎNhŁOc#um[2ӯ΢zջZ\Vo!%8w`|y1$ZߠN,1:ʪk?R+
bGLSA@~xO#KhWKUUCR[.%f гgO{YLGqu/?;{jr|hR򮺊
^NAܫkkz ׭fpg	%qps6=`j .U5g`(x%""'%s'gK-N-o}[WtyJ.bnەV.oX	46ɝm,?.0p,*ֺ}T_]Ewgm%lգ*;tv_{! 1O#wd.y(ul ]HŠm`wqu'7uE׵C$pxz&{ԃ1d<s%vKΖW7
1]įt#s_CΗ7ːC7Ƶ%yy_:oB]M26K8=)Lk#7δ_7;7D	im٪ ~=ZyuŨݯJP(
BjG=Ht3*B@!P(
k	kv{}ƍR;(
B@!-@ ))#y2t׬)sJd,U%B@!P(uw4ԳB@!P(
A@	WVET!P(
B%t
B@!P(J""*
B@!P((
P(
B@!pEO_ľ%DO	ӸtGbPS<tgߏ3F
gPiEu&Cg+{3oơp?17rbr9?؎#Ga̸\<u Em!:~y`k_CEX2ͨ?\BFo4<5oN?$\w#K5Y!Pttv P/bڷ%SC9S%: fZ~[,p=W]Dz)>Wދ'ں_'9OQ8<;!窐2:ӝԭtX;ЇsyUvhq6,/*T=Tgԉ0
kE/չ/^0]Kb)
n 4 $N|
|?:zU胇^.C#$=pIƷ>cuSTO	} ʕ,}W]wQ'~.UƽLCl^;ֽLDSqh?xjִh9/FC3P<:;(l[A$
nD
WPQqD$$|(蓘qPh\$35O4	8%D%*P@Am[UtCw FsN=$C#<ۼ_
Pe-+[3{vceTx߹Q$̩0&T=%ؿx,:Irw\I.|{Oq>~suhlp\ܽ~#fX  ѝYrGfb͒=pw됔c8=*}_Ɩ-H0g`H2w3
T ghgw
>Oi½!?q1)#0+;}s	7CiRӆ9nԧ^ʒ`e&
Br);&PBQS?Pc#YG/LYhE/{tĭ]KYͨT&,ջR{Za+tdMm(ⱝhX}rA9>c0[>#bG-]Zq&-ѤVNŗNeu0fDC8;/orqf1Jρc{y3!\ڧtO1u_RҬM4/̐o0(y<cL	(^7ɱw`ݙ⧍ƼpmpAq
:=!]z_^;t 7$T4N+UR~_wQwg`?0/$԰`xF)2(f6;O(0!&aҟzcI6hڢ>JًbeT<L(*48#z9VH^sH
U|KQ;hhAXud2w.F@<5@4JڄxD5aM*Б)1$z7[Ea5`):3.ahGR7}.tf\&4*cmWz^Gk$K""R8Sл֐iX?mI`:Sç
k MߔۧMYk2Vzo1%cL	X&NK|ر$HzS\Sε`{D֓^ȉs1k08P3T(uy*L~B)Οf	Lv
AZN1Z.EQEttċéQ	+|L.02q;{uwa[#`
mĐO7:~H؞ME!r^{弁ׇƅ(->/OGB>wFY,CݫRX}#5Ymr՜x+J5
&(<""V<<`Jvx&'mRz1Wr,YS eQ8S9#Q:`%#jͰ;J	JqxmĬ$!w>>~m~4_f(K	+akrU#<66mAs'ǧδȽ;iϦ6=k	)R]{9}N/Kdv1[˷Gc7UmхZ""κnx	0 J%wHf6RoIx4sbA!EtoGi+ax3Dg6oMĻMa4/Gf$̞ﮭ*2̗tMzb*{d*4G>
;cI)enXcG<\H5hA*:4l/uQ	Ҿ2Ja:2[ZSC]
W&*EYvkC$%U sn P]KE`IwxF5K)^G%'	'GE7+2rKo\x9]At!ꢕS+:(Ap1SkӒ6_s;W dʯiLe[]\e))`LY{Oк+,ZR7Ц  *dJXʮ5K'(-̈́i_%S<tq{cEgP	͇hkEHbi5O+=E2]Vmi,
öxG%}ꣿu7g*?Kr""#EDN'G#-^.]Ӈ&`MY4*mB/ZEֶ6]YY) 5#z7V;XWəO*V^6\Bq,TEES(YS0ک۴9Y.""Mik
v6Sv`l?*)7bs^-KN3QvKbV	zyRNX>dL	TJtVH1hȮmW|B,k99(O]1vvrz:riQW%YMO<X4""L(g`*?gwn̽mP-/#777(l,ƛ)o^)gMXXCM,i׼)	#d#B5r~묨#I۵5;Og""??G!3Sm0s۸b`^̧eQ76IN0,Mca܇!7}?)=a9I­[81+a`|%n$ks6ёv\6_r@(vk慒U,B\ֵ$h7-`L	B|u_bΆ!u[
d )
%un7fh6024xZZFQXօ	?*
 Yt~oDIFeś""ڝJeEЃݔwJ~Ķ
J""8% MI<Nv+tCh6<cZf&܉ krHlioM˱z06EOE@L9Qb)ey~,.5o]+ݮ`VzHLv"":M+PiעΑ
XGw`4RΙB٥ao&KO'cиo4w""s:o8
mqz]Abfz>-֟{ $bteL	:KIݿCtpvRS$M޳gOI0e`chKT-uҒbhi$85SJ2
ʆ02`)
WaiN#wڄ9941xٙ?sq{16u:ZbѥPr
[n*gZ`geM_¿4s:hѐEʄj~x| riQѴFbZtXyF""xtjZ.]wwwLš^8{*9\Uח
4y/գP""֩SGlI-
?tV2oˊU]ٺ6US*2fM]<eЅIn\7Z(҃ԑeަۄQȫ.Hᬪ,n
-m:&Z_3ɌFanҀϊׂ\ꕯrY)uI{K/cFtƜAGw܂k$3+2,3&nN"" +VT aLZX6X Y {L3O}o{wI9|s*uUީT
`L}lS#1t
¦ϟE~3G}1j\-\тv9A&SՁm-""P:bZɚJOͺ""hl%wM>=n-
e x椙 `L	0&DNnL	0& ` +1g `L	0&Pte1& `L	<zV>|\=j`	 `L	0&P	pz_.`L	0&t>B0& `Lv`v/	0& `V:j`! `L	0&P	YK `L	0ǂ +E5L	0& X˥cL	0&cAǢX& `L	nt1& `L JcQ
,`L	0&j7V:Ejr2
P%BjvS iqTsS!9ZWs<Uc䬩3RM;Fh͔v
CJɆ0ۛ)Qh3&j@-V:i8&#\MO M>$$et-quj-/|
$ǄcT%,c2JǢﺫ&&b暌ٚ*ƴ&x6z_g.@DuLNKxzUIW""[z/ClѮ&9ٟ""v!<ueЍ1g R8{""tv,;^
XW
ֺPϗGpj{||fRi[Ư~ԝMʿɰƎ'cq_GUFZJ*
UIl    IDATAL!PNz`A\jJn5G]
jzx̆4Ygp0c= (݌twkcnvYSpZtϷ58{m^@rGߎVs=qICQ-Rw vvҪ 
	t2
^	5Y͟f:HGaȋϚoBP6**U/_0` zok#1%cY(V9^Fqj
XY,FR2yV+cv>|?wGQ2D\}Cw#,,r55i#w}bqxVMϦ|_|W
veޭfr4uڿUKG}oyz 	<
=VW
ix?ԥBzۆ=֣lG >4RڴH$PzxɬB!Grqp9IzC2p.#١S'sЩZ䥝AZ^veUa^64/'/Q>
RDФ`qZJ4GvmHOéhܺ\ӈlr6ڡ[iY!pע m Z:ʴ /~=4nv2maoۢ],Z5oVm, )=yѺ{	4ŤKhRԏ18/*0%nSq
2R)܇pAE+q&ߒ݂3$iN0&.b':cJr:WhȂr,
vACP9%9LҒ}ڴj"")3pBvC2ΜC^Q1dOy!yRDhC^[>EЮZ
ԭ]}""N蝹W^T8}!s[G!kYCuGđ_kcYJm\E[[;6m޺!d6nAhghC'R%XZu	DDL A/t(mF_ˠkTvJW 
:ZCqRۺB&W} I~k.[{7OZڐd]]6E%n
ܚSxXǸg!5^^X6:[b[6\TL0GV[:*_4Ao~5w,s!u	Oeב:<?4i 4G-GwQQJRb&;؇§}{INҐp	???x4V7T@]Ҷ9;χU0j
<zBS
m˫K[0V~*O7|Hy@ DCND
uSrHV*<uA-tۿ_GOguJ,	ё_-EG?'s<ItN0]$_VNl$|<<SdYal|9J50Yzm:m}Yn-)RY·_w7ipwMj7QT^_Hz&y[{z?xwAC""䎮L-E
#pw+R-݅ GyP>p?+Sԭ-ڗ4Xh{ee;vKmGlJfڃNNCToM n\:Ak0CF<1>&U6_YPR(f`Q@d\N6a3W~R	egZ56t1""L|]ّ9ܖeWnp$Pur{`wV8LVi]Pifw& <ӝ*Mް	WlBiH[hneeVpT{i];)_rDZEPLJ?AʝFX#!`/w
4gcg\ybH!lw@%PΛ~%R6222h[0tj*n7}#JY9	~IJAJbn%eP,8-l
ߚeS0Y8H&nQ
*=+>Y?
CøAV9Y-a-DLp5)TD;I	iO!FH{siI{鯷fYFJ
nKIm)YIpyTߣGQ /]Íkm%8:$ٯ!+mٺH7#Id{(~R%TXzk3ſ]aS7GHp""Yiuƾ\R~ͩvĶoڮHJ+[ue$,r""WoJB{	37ݎ-ȜYB.)m>ڢ/㖢-1xHR""ɖh#7V!hװ9#P<""tTr4!5q+-&G.lZ""$*tg؆5$Jux""嶧o/Au~).
j=H_yn&""*vm*r'k{SIVIGktېnx\',Y""τ`'̂
YuXnG&J
k!1RFsJPg2eO[@(OõkiXJopF3U땠
A!{qО-U'$->
⥂\$>pF[`wF)yӓpb\GDJڶ
>ߊSNVF8Y$.J)]wD3717ۿ +G<FMAuPB4܏`װΖFHv+=tyj5Zto$nСd=s#+;܃w tkZ 1:35nٿ)i.}thKD8g<o&n
lڟԪS*t&M
ФQ='{ѩVb0uۊDxّmQ =LBP[ɣ<Ec kKEN{zJy8Ry:\x}&6g:v/
W^y0jsOrk+mTаA8JOƊie`R@Gхd's!iy3<.a9!m!(݉Zq>
)
( 
3tA=HCÕ~4,ĦMTO{R2;4$
u̅]hk1J< 8$Q*|Y-
.YV/
ytz\*gz>,&PОrS˨e0.T2wo/޶L!	9S~35WRid(uY8;Rs'T^h!R4{/KmCg꺅:{g W,Bc(+R=bh:gC>]D*OK]Oz!!*zt&P$1N""5)1B)*ݡKٍtܾKJg505}.DbR^g*oB(a/z ɭ
npBa:}>7	t-l!7t݀`ax4z\v==zE<?^`
d!DV`ȜO1ZFV+(Y$k၉z+zl(<P\<%eU:i))<,٘E6:HwV<ps!霤DIA{1dK~)u@qCQ8aP&tc0i3iIX%KtHø=qWƧ	%L?JVY1dG:8A@8yO%q&h~s2vXnc?i#q8_
]j
 ȒbL2Hq<@)'.3_cqA=ڌh<'HA>x'o6Gh4VҾiB|n!Y:ޒSܛRϸJ--.BOҡ5):IctyY7Y
(pU5]n,=]{y}rK>2膐lr.8
NADHuL+B.6cݵ^̶ymCu[xFuI= xZ<܆&]ܦa%
бїpGw-Gg<q ҋʾ9C3g8]qV
S}qC@ANث}S)oI6l`*@Nj}U!)ɥ>OѠy9-zQ(o	Z]ݻowh5/=Cݸ+rhI{D`lex2	=aLMufˤYe'|BHU%%	=CShIƾ쬄R}R!&#wC0p7.ݍ;Cυ.r9jl6\6L7:4F)\%%0t|'.SB
&w389ü5Uu%o7n`Rl]Nݼ­-NH7NzOVʍeY.FBgH܆?P`,
LsƮJRI,@h\x&Q׵4pKEY.	ٴPidi3BGu&l\BchCNXwȐbu۟r(</	h/2+*zh_/;aEK
+)Jnܗ輰	gS˵:4\{*r&YRd9qF""R6`s5J㋘Lm|]FC,a@N{v4u+5#)1ݟr=~IdAKnfEѥ;xE~̸.%뼁~%r}3vzJ|s_Cx)]CkP:%P*j#S]*/%Gcǳ0ѣ{*J""K33IV[:Ue.9hMOZPYFAv-L]UIPfXY׬~umǶS);131Jʌ +WD-ȸ#açHd.V'$i؟-NJcSX=eg1-
R?4
+""mm()7ghOE)mX)baڻtʇZ#Ѻ+WbZ
i`	BF:mnfu;Ƅ7S+qWCXF:uRXi0dգ'OR10{y9≛X8;r`e{i˻)9)e4i$1VG@=&PH-hnDKfP7Qrn{v""Uj'0{)ꁘE]ɱ j+rf0v=ʥ'o&J""^Z-ECӁ֟A:ki(^:VcߚH4CFR,چ&6}ݪqB]mqx&mTǯih{k, U'ϜDi//MJ^v-oj7v^6O0gJs^L1MMMa7ѕ\5wK-vOi}0o]^d{HCY A>|:JfqemҰ+qvW
QRWkpIhBNV
256MODjGCKLxjgJ^Sim
lEd'۶EG7Mǃum!e	&ĻC4k3.`wt>8xKTף,ԕdBGgg%%,%䫽ҰXj4]C1 Jm:IJ :=/Y""_V-nʤaF#G4>V4Qk=Qg>18)!-r +48'fbxQZY_/Tućb]'~_(J$[[!KdC$YB4 }qdr_xAR$hZoD,Ln6Wg%%$03dv>s+
	4P|Кn!^2ҔK\sᡴ}""qJWszB8A[gwLYYUBzj:lR^YA$mb{Q_
o
|rcY>ףl2y:^4^ヶx3s[j
׭=^O3hཕ>~jM_""e
:&֒:I%1 0mZesibԣK(wq+@GZ	""7lMlgj^&3RB7N%LzTN~+]lGzlxL}0 m0^'r̆24w%cG=fx7F%k=ߍcJ˧;Vm4337BzxFIsH\&]P9ӊ=Wzd$DBt6D'~-i߹TQxn_o,ǏCع*Q]XZ+L*c/Z)
u0ld)3!j>֫gl5V3yʩ>{n.o&pn@8ć$~t~dTרJDGڗ)ƺ5dU* Ub\-sXH`g,m|.ڻʩGPTZQ&e*#+J!YSʷтCO]:Ԏԃ9_gQ{xp΢-iUkS\/tʹyCq*[qjP}>ˇR5ߖE+, &ˤe94C^KyB=""ye""]Yhe
p0S8{&T 't$N'Ұ%G%~7Y\Q
{<h4TQ~Ejfј	.]&J2{*..Z8̣ׯ4h@ڊ}q4*z֭[uԑ~jOTO7Ak@L]Dxݬ)R-n	EB*'	xL+}CriGٛgkO3
D3ܵ5>)&jhB$@>)%B/OD1UXw#hx˳jR3LĠ=gіʜPˎHxZsW(&٢۟$MCFHW9/\4w(*SaٳzbW'PC;xL8liwٌuo!*Va@t=&Pk߉K:{$ZS\mn>
ȌG
ZUo
JqH>bL6`Kgm].xBt썎O,f9[a8+>bL	v""Q䄘 `L	0&*%`i8J {yc٘ `L	0&PMZS3K6,.`L	0&	p!
gL	0& x(X|(X9Q& `L	0Ct}& `L	0B·eL	0& 0$J!
gL	0& x(jBIL2/\Cö̮t\&8MK~rjp)GcL	0&I-g9Z)Nįb~'s,=5$s\;H,AAoǥ4K~S2X1& ` +8hhܪXٵ	wJ^J.`Jg)2V lQY {v$10[3'M	0& xTG.c%@	.9K71u7	]$[^ؽи}9%~.EY/0Qw    IDAT1}7Śp4.c |~LYn8zrbLXUj-jXtƨ4r51Jё)қ[9.1|/ֵqDsG`.t,zm
Nv>K,.E8|NƼL#W{؜م_;L|&d{1iZ > `Lv`Kz,EAr,f o.stw&Ÿi1o0><CCxdB0p`OP]z_^;t 7$TPtjqPl)?
Ư@XȻ(@;
Yk{m:#:9ܨ\i(*.AbA]6W>5-c
0~jz؆eS5[$,\@prKKtC15|*ܰ}ҩwrS6jtCpL>{
%xZ[ `L1!`dzLdz|!3cI=OQXsMMsX,9ŲW$r\6N(EE7ړ)Θ3S_	j]kCSd]9!_r]Fa
B[{ēz,-(12Yr3EPi~b_B=J6EVc=k	)xi)Uر].FwD4v-lI/""gE`L	0Ǜ +-)""ذG0.J2ҤXsbA!Eʔn))iI3u{s /i\wOkNlGH8	FR-T6-?لj|eXw""i}-iI&PpCH婸9d[%{!:[Kqn
YkKԃtl'7YO#	0&@*鞡bWu J<bqڔV)J""Yfvw
	E/޷S>)LY)hNQT1| 3(=DJlm$_ h-*Qx*k`9h(Ә48/خUCiuQIJ2if!
eϲdx	0&@m$c:+U0GpvmBtCf/Yzrr1C

ۑ-&-J8y'hD64v3,/#777H+Yȥ~mGPX,X7iyeTeP7̱N(vk慢̖j>Q<c& `S
USe+97Ȯ+lX96/a4A 36,.tvd?aY>GaEw.H8We8F=)Q:g|u3wE""u[Omcޯ`l#x#=&U'@%[xsn!
g+Vwl4afDI;А,b SS},o	0&Aw~ 00Jя?gmSR""L|*Z9DJQRB%U6rrZؘXX._uDIV4cN7:<8R5̙ `L	tjڪT/]ww...Z8Z\:_>06hР\=Z\E4N:үfj0K-ͻ&˺6Oe|Knާ.H|݃_|IL	0&41OSmsY `L	0&sL	0& x46	0& ` +<g `L	0 +OSmsY `L	0&bvL	0& `@U:n:WX& `L	nܽ^K `L	0ǂ +E5L	0& jm&;& `L	<IjZt&*`L	0&'돾X& `L	zt*2& `L`K `L	0ZOZ_\@& `L	<zt>:`	 `L	0&P	kO[7ԍ{()\^yښ|/ջrM:I.5ΟD.]ѬݜP!bxp|g `LI&Z:飱pyW֡;fB^So?2I~MƧwqyxO\`L	0&P{<vјҵs#k{tcjU	RmЎbX!m[/D}5R5Y84`L	0&xJ-2JߵQuhq>q=f`ĈY!Tf#Bg hSs'/D] ``OADЅ[3M@&Pi~d,[OWS[ܧcײpO|9:Aͦ0B?Q~/~ ^Ao""A|B؈2'Y)$7YB0| `L	<jT՝8^
p]hXN}0;rb)<,Ɖ5JWq}[4ZA_`v;EE!r4nDxTM)1vJN-r${uëk׏éc1kyR#z""2*iIsǲ~GPO[7FұbOanR>0& `O{BkN#r{-+OrM $Ml{|,aƯ?/:2	,L5v_ vNp1 xKCҜS	Uq=?
N4<`P,2tC܁b37v+E\<a1͠/7!k*:VƾCj8a3OuW6MB$פ?f""	B9}pW%2J	0& MiXBc1<+_>#0/pW@stn(!hy]ocHB8hx4K
WYhʓvG}ndw]75\\dt+C%Sȴ'6~ egW^)+O6[rz!kyp,W-NC/{ɓ `L	0 [:MT՜[@Wc΁}'%Tŭ<@(IɔJ5sgc=Ӎݰ.
bA]2rm&I""X9)DȬs*D+f7v1f]a{(F5F=%i~=-$it'bV @pS	0&J~~ӅmiX^.~u*Y##'&oE
I|qp \I㑕VϦne`+.)ؿ?|54x叜P,Aŋ:k678d$&.[df⾭u:KI蝥45p-6휣X8eg$O V6VQ6M1o*1}'̄oO81& `O"")6T2u8/uNNKŨ[Z(nM	&kd7֫hH]d6	""JN͍Xs⩟-<E<Ŭ	Lү,^P?=U׳/YOaE7ѯ.9_	M
:OVXM(YYڱ7fN8k҅FhҐBqE#*-M`'GnD̓萜-Iz|x<HL	0&TL\nݺzlOݾ$V!pq8;;W)Nuٳ~~~f־ĺ[fj44<Q
C-j
l鑢ikk""^Ӑ	9݊jd^pQą#
)IWw	Cz:GhAJf+ L	0&hjMet钴a
š^1z\ڒ>#+%6ezd?:uHR-D~-QQ}BEcmǴr(`O
gU)*4U~$.Ekb
C©JĒq0tY8=& `LRTsB)c^(OҩB@tA	}{f\pJM+Fg'Sh<вg	0& x k](:eS)BatʧʕN[
#[&`	ѼuNSZ0O} `L	<^tJP<~yeS(O+S{F	0& `71YHIY:uMCK(P:o߾͛Lz;>Z18s	hvaƌxt3& `U% &		ݓJ?1dQl޽+u_.)<+U]ZZs![7zyTuqx#2ztN{G' `L	aVKXHR@*	͛7k׮I	KDBM5KP]?}&w3Cq4C~""^_`'!UIĩy`!N	0& ƍIR6b)LaѼzh+W]tAӦL%{}_ۣ}z屺~+[]K&#4tRع0y2R_QEtL^FVAy,'vaaZ+ KOeFGϠGӠNq @Nsҵ8u&Hi~O3k|l$G蒭)~$JҤ;8xߗ) `L	0'nPvгgO4iDR/((˗%Sԩ^z%*+Stz]bIbQ""^6@1|`мuc$,ϋɩOan8}bQ|'+^ŉc( ""6
RSWn(K/2N^70s`l,Kз(""Oϒ?®/""""1/+)[wCgeD&Aq/?& `L' ׅS]vE=0h ꫤxK;w7,ko#p7xHĊ	I5~ʤB'/t""[OAɘbkf{""`<}|zHg|9+ kq6?;߉5w""<).}=bql$Qo<u),Nfq?dї>&Q`N[*I%-,KcܑI'׃eQ2uM%{G/D_B7L	0&,bnP<n;wH*SiAcg#Lxb(yVbqN/_~#BwE
sxM:M.UD?^Nb\#qN{8ɟ&}y+vkWQr$33TqbRzvvȉOg""t7Ml
CIiT.H=;& `L
64Zb*:*Xᧆ`W$,:W]?]|[:WX,;ciRcz
' hfԻIZ -z%TX`(q
t^yR
Oe^:k'):~7v1}g*&QNR:a;W"">}Y~	aL	0&D孙B_N(86T*ꋉm	Sqnn""H~f4qkg\<}Yj;d	_ga<}ep}npy<.""%ӯdf⾭2Z9rUinI[4l9GpST%	/v(c]y	0& xR,ׯSDtn+>J籘Qi<S#^NNҫ.]b#x_1Hig~h	_Lx9biˏGSZSx	zEްd?
ZQPdme?䏍S .xN4nr(l=E:w({""5nP `L	0ZE_իIF0hfvn_RYg{jpvvR޳g!
ZeK?]6Z$.WȌtu7h=>.?EʩUg|=$%kVѝӳ""sd""iЍokV$A `L	<jzt钴aUš^ǪD1
ۢsϡuvRxb_;;;#ÕQpSi4PpjHkrp#:W)B&}P+j""

g˓Eglgr*[{Y۔,7ON1cN+ r& `1a?Cw?^:d)N4M+Fgr4./Щ3λY)89/ҀGik'!pG$g `L	<1""%LqN[?HN#`[AMx`:y:ΩX';& `LV0^_#2t۶mCpp0[:
>`L	0&@5
>>>(--vnJ}Eu9
S57ǃ@-ť<OsOΜ`L	0߁ wW\/
zcT;
;i{ |~Zjrc7'FuKH8-k\+G`<Slh.ܻ{>h^G75-Ls `L	0߃ [:K
y؀;em]sn5x=+-Oq]:[}`yHFwH{غ(f/=3UvNz
-8 `L!x-c{qR/$~/pQ}hnÈAqXz%O|C,Vj8t>/UW
]J.욿7kCo{J@Ŗ#ڝW<H)qv].KVdU/XZ>!/3|ј՗a gb$FQ<jS̜ `L	0ǊSk鼓BlёѐԮ睻a{*rp];OhPf蓔;c;X7\HpUOO{D@H?<lH$
?ݰtk0ܵ.Ţ
or!ˏg.Gyc}3
+>""KE/(pH
9K6{{r1UvsV|XuT|^ aL	0&ׯ#;;8v~'߿CpAi+<y$Ґ§sɤ̟Ԙh5,kb=Jqg>Q5O11-w\  TTyA𱯰n@cxxxxk#J^nf8\ĭiƏި/q= ~!,BO""M2159/
~y5jٸc}	_QH>~cKQC	0&@$ F GGG/ncc#-$u#E
'S8
E	A}[!45tkHɠ),Rsw~ҹW8	+hi_	jX?  
NIDATǫҙCBPQMЖWl_eK]Cί}#zvL	0&cIS:Uab{^hY8
}A'\[^-_JpzuK}
'7ÏECɪ\A*
FRRd[=p3ى~RNm,:i
jJ|$\J.cՂ`FYW2& `rL+>^>-s`Lĝ4^I_LnF3/\)
ר38};E׺+Ft)DgVm\tۣaN򷁬""m1rsr1VtEq
x¿AYL'~t_Õ:ē{ 9g.wSH눅?ae`h|	0& x<uN=sUK_0peI;L_gPIK}pIq8&&ŋ𗰿adAuGޘ(1CW4`tH_į>Jj>!WaoF6'zr\_6J~ɩD\~s-`GA `L	0Iw~n 00Jя?gg*ũN={ϯ:Q8Дh+܆)O_-%nByyL]ߝ1Sr2	QwJ`Nשn:UIb|	0&cD@V[%%nUX]8k;eFvAos?H#GJ^OD""5PKuX{0
רzH)""A.)uKd
P|p>_FuOɺl!en:@<)X#}I܅QXn2)pK-%qAHXDgޘlʋB].Ltd.Dol?`m3,Մl`,.6vJzB=0zOrs<isޅG+q4D86}(@
P [
BУ{ףP
$`6B Пr54̖X^y/75J=i) ;:K೺fGX.$YXUò?<_^A?nMYO>ڗ^wŽ<.Q-r
4}sw*A&~?Z[[c6]v食ֶ&ځLMG?bͰ
`wg03J~&7
R3j7J""(@
PI(Q*PVqRhгrOϓL&!47n 
f02tZնi^(N)Cnֹ
P [`:@T
I][
~΍F}gg:QahcJ;NCk_N9.#eE<S/}9#rS (@
XFgއ-8I]]](1z\4dzn{w(7q-sU
P RR҇^ Z~mWe]]2S9|""AdNгح[%C
P K =P{H$N	F{yud\7O|'j g(@
P@
H#Xb1sDSiL6ɑyt?͈vl (@
P $L!ryy6߿BF;ez#tʲ1s:q7Ѝ;LG#Rح_w (@
X$@NLL`nnx\rUOqWc^duiE
;]x;
suo (@
P 	Dv#X
b|זj(@
PsGtF'o0z|vWeu[(@
P@#Co1(~с֥r (@
P CMM3<ѷ8W`.6(@
Pp^<yҙӱ<w (@
(p1/\ޡO@s%ZQu~#|{ (@W`tfgK>\rY\xӾg5B
E>7Ee5=+(@
P$pJ-}җkN	>ak
=(
h*^lįS7 (@
츀N黥%wa\~Ǐ8yNgYQ`{Jvk%zu6 (@
P`䐺pJ]&YrHoիWyNgnzR[_A<R37E (@
윀Ù:=.8/g^`)#%әgN-xsx>'86 (@
PB0e8eVf (@
P
	N	R:m s
P (tF4G8er]oh""hooiATWWS (@
GCC77Y|2%围\̕ &fS    IENDB`","Binary files /dev/null and b/docs/_static/debugger.png differ
",add missing comments to debug.js,add missing comments to debug.js,add missing comments to debug.js,llm_rectified,0.0,5,True,100.0,0,0,0,0,0,-100.0,0,0
40e0024d7b87150ed694829a5335bd2435962225,"Added screenshot of the debugger to Flask docs.  Flask now runs from the
shell again.",quickstart.rst,".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://localhost:5000/

Head over to `http://localhost:5000/ <http://localhost:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. admonition:: Troubleshooting

   The browser is unable to access the server?  Sometimes this is
   unfortunately caused by broken IPv6 support in your operating system,
   browser or a combination.  For example on Snow Leopard Google Chrome is
   known to exhibit this behaviour.

   If the browser does not load up the page, you can change the `app.run`
   call to force IPv4 usage::

      if __name__ == '__main__':
          app.run(host='127.0.0.1')


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`database-pattern` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
",".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://localhost:5000/

Head over to `http://localhost:5000/ <http://localhost:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. admonition:: Troubleshooting

   The browser is unable to access the server?  Sometimes this is
   unfortunately caused by broken IPv6 support in your operating system,
   browser or a combination.  For example on Snow Leopard Google Chrome is
   known to exhibit this behaviour.

   If the browser does not load up the page, you can change the `app.run`
   call to force IPv4 usage::

      if __name__ == '__main__':
          app.run(host='127.0.0.1')


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`database-pattern` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
","@@ -97,6 +97,13 @@ Both will have exactly the same effect.
    major security risk and **must never be used on production machines**
    because of that.
 
+Screenshot of the debugger in action:
+
+.. image:: _static/debugger.png
+   :align: center
+   :class: screenshot
+   :alt: screenshot of debugger in action
+
 
 Routing
 -------
",add documentation for the routes,add documentation for the routes,add documentation for the routes,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
40e0024d7b87150ed694829a5335bd2435962225,"Added screenshot of the debugger to Flask docs.  Flask now runs from the
shell again.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = os.path.abspath(os.path.dirname(
            sys.modules[self.package_name].__file__))

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -153,6 +153,14 @@ def _default_template_ctx_processor():
     )
 
 
+def _get_package_path(name):
+    """"""Returns the path to a package or cwd if that cannot be found.""""""
+    try:
+        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
+    except (KeyError, AttributeError):
+        return os.getcwd()
+
+
 class Flask(object):
     """"""The flask object implements a WSGI application and acts as the central
     object.  It is passed the name of the module or package of the
@@ -213,8 +221,7 @@ class Flask(object):
         self.package_name = package_name
 
         #: where is the app root located?
-        self.root_path = os.path.abspath(os.path.dirname(
-            sys.modules[self.package_name].__file__))
+        self.root_path = _get_package_path(self.package_name)
 
         #: a dictionary of all view functions registered.  The keys will
         #: be function names which are also used to generate URLs and
",add more info to flask.py,add more info to flask.py,add more info to flask.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
7b5015010bc8c2a2d56c7c50b37e5b9facdad102,"Preserve the request context in debug mode.

This makes it possible to access request information in the interactive
debugger.  Closes #8.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    @contextmanager
    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            yield
        finally:
            _request_ctx_stack.pop()

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -14,7 +14,6 @@ import os
 import sys
 
 from threading import local
-from contextlib import contextmanager
 from jinja2 import Environment, PackageLoader, FileSystemLoader
 from werkzeug import Request as RequestBase, Response as ResponseBase, \
      LocalStack, LocalProxy, create_environ, cached_property, \
@@ -84,6 +83,16 @@ class _RequestContext(object):
         self.g = _RequestGlobals()
         self.flashes = None
 
+    def __enter__(self):
+        _request_ctx_stack.push(self)
+
+    def __exit__(self, exc_type, exc_value, tb):
+        # do not pop the request stack if we are in debug mode and an
+        # exception happened.  This will allow the debugger to still
+        # access the request object in the interactive shell.
+        if tb is None or not self.app.debug:
+            _request_ctx_stack.pop()
+
 
 def url_for(endpoint, **values):
     """"""Generates a URL to the given endpoint with the method provided.
@@ -618,7 +627,6 @@ class Flask(object):
             response = self.process_response(response)
             return response(environ, start_response)
 
-    @contextmanager
     def request_context(self, environ):
         """"""Creates a request context from the given environment and binds
         it to the current context.  This must be used in combination with
@@ -632,11 +640,7 @@ class Flask(object):
 
         :params environ: a WSGI environment
         """"""
-        _request_ctx_stack.push(_RequestContext(self, environ))
-        try:
-            yield
-        finally:
-            _request_ctx_stack.pop()
+        return _RequestContext(self, environ)
 
     def test_request_context(self, *args, **kwargs):
         """"""Creates a WSGI environment from the given values (see
",add tests for werkzeug,add tests for werkzeug,add tests for werkzeug,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",patterns.rst,".. _patterns:

Patterns in Flask
=================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.

In Flask you can implement such things with the
:meth:`~flask.Flask.request_init` and
:meth:`~flask.Flask.request_shutdown` decorators in combination with the
special :class:`~flask.g` object.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.request_init
    def before_request():
        g.db = connect_db()

    @app.request_shutdown
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()

.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
",".. _patterns:

Patterns in Flask
=================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.

In Flask you can implement such things with the
:meth:`~flask.Flask.before_request` and
:meth:`~flask.Flask.after_request` decorators in combination with the
special :class:`~flask.g` object.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()

.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
","@@ -11,8 +11,8 @@ request and get the information of the currently logged in user.  At the
 end of the request, the database connection is closed again.
 
 In Flask you can implement such things with the
-:meth:`~flask.Flask.request_init` and
-:meth:`~flask.Flask.request_shutdown` decorators in combination with the
+:meth:`~flask.Flask.before_request` and
+:meth:`~flask.Flask.after_request` decorators in combination with the
 special :class:`~flask.g` object.
 
 
@@ -31,11 +31,11 @@ So here a simple example how you can use SQLite 3 with Flask::
     def connect_db():
         return sqlite3.connect(DATABASE)
 
-    @app.request_init
+    @app.before_request
     def before_request():
         g.db = connect_db()
 
-    @app.request_shutdown
+    @app.after_request
     def after_request(response):
         g.db.close()
         return response
",add more examples to the docs,add more examples to the docs,add more examples to the docs,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",tutorial.rst,".. _tutorial:

Tutorial
========

You want to develop an application with Python and Flask?  Here you have
the chance to learn that by example.  In this tutorial we will create a
simple microblog application.  It only supports one user that can create
text-only entries and there are no feeds or comments, but it still
features everything you need to get started.  We will use Flask and SQLite
as database which comes out of the box with Python, so there is nothing
else you need.

If you want the full sourcecode in advance or for comparison, check out
the `example source`_.

.. _example source:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

Introducing Flaskr
------------------

We will call our blogging application flaskr here, feel free to chose a
less web-2.0-ish name ;)  Basically we want it to do the following things:

1. let the user sign in and out with credentials specified in the
   configuration.  Only one user is supported.
2. when the user is logged in he or she can add new entries to the page
   consisting of a text-only title and some HTML for the text.  This HTML
   is not sanitized because we trust the user here.
3. the page shows all entries so far in reverse order (newest on top) and
   the user can add new ones from there if logged in.

We will be using SQlite3 directly for that application because it's good
enough for an application of that size.  For larger applications however
it makes a lot of sense to use `SQLAlchemy`_ that handles database
connections in a more intelligent way, allows you to target different
relational databases at once and more.  You might also want to consider
one of the popular NoSQL databases if your data is more suited for those.

Here a screenshot from the final application:

.. image:: _static/flaskr.png
   :align: center
   :class: screenshot
   :alt: screenshot of the final application

.. _SQLAlchemy: http://www.sqlalchemy.org/

Step 0: Creating The Folders
----------------------------

Before we get started, let's create the folders needed for this
application::

    /flaskr
        /static
        /templates

The `flaskr` folder is not a python package, but just something where we
drop our files.  Directly into this folder we will then put our database
schema as well as main module in the following steps.  The files inside
the `static` folder are available to users of the application via `HTTP`.
This is the place where css and javascript files go.  Inside the
`templates` folder Flask will look for `Jinja2`_ templates.  Drop all the
templates there.

.. _Jinja2: http://jinja.pocoo.org/2/

Step 1: Database Schema
-----------------------

First we want to create the database schema.  For this application only a
single table is needed and we only want to support SQLite so that is quite
easy.  Just put the following contents into a file named `schema.sql` in
the just created `flaskr` folder:

.. sourcecode:: sql

    drop table if exists entries;
    create table entries (
      id integer primary key autoincrement,
      title string not null,
      text string not null
    );

This schema consists of a single table called `entries` and each row in
this table has an `id`, a `title` and a `text`.  The `id` is an
automatically incrementing integer and a primary key, the other two are
strings that must not be null.

Step 2: Application Setup Code
------------------------------

Now that we have the schema in place we can create the application module.
Let's call it `flaskr.py` inside the `flaskr` folder.  For starters we
will add the imports we will need as well as the config section.  For
small applications it's a possibility to drop the configuration directly
into the module which we will be doing here.  However a cleaner solution
would be to create a separate `.ini` or `.py` file and load that or import
the values from there.

::

    # all the imports
    import sqlite3
    from flask import Flask, request, session, g, redirect, url_for, \
         abort, render_template, flash

    # configuration
    DATABASE = '/tmp/flaskr.db'
    DEBUG = True
    SECRET_KEY = 'development key'
    USERNAME = 'admin'
    PASSWORD = 'default'

Next we can create our actual application and initialize it with the
config::

    # create our little application :)
    app = Flask(__name__)
    app.secret_key = SECRET_KEY
    app.debug = DEBUG

The `secret_key` is needed to keep the client-side sessions secure.
Choose that key wisely and as hard to guess and complex as possible.  The
debug flag enables or disables the interactive debugger.  Never leave
debug mode activated in a production system because it will allow users to
executed code on the server!

We also add a method to easily connect to the database specified.  That
can be used to open a connection on request and also from the interactive
Python shell or a script.  This will come in handy later

::

    def connect_db():
        return sqlite3.connect(DATABASE)

Finally we just add a line to the bottom of the file that fires up the
server if we run that file as standalone application::

    if __name__ == '__main__':
        app.run()

With that out of the way you should be able to start up the application
without problems.  When you head over to the server you will get an 404
page not found error because we don't have any views yet.  But we will
focus on that a little later.  First we should get the database working.

.. admonition:: Troubleshooting

   If you notice later that the browser cannot connect to the server
   during development, you might want to try this line instead::

       app.run(host='127.0.0.1')

   In a nutshell: Werkzeug starts up as IPv6 on many operating systems by
   default and not every browser is happy with that.  This forces IPv4
   usage.

Step 3: Creating The Database
-----------------------------

Flaskr is a database powered application as outlined earlier, and more
precisely, an application powered by a relational database system.  Such
systems need a schema that tells them how to store that information. So
before starting the server for the first time it's important to create
that schema.

Such a schema can be created by piping the `schema.sql` file into the
`sqlite3` command as follows::

    sqlite3 /tmp/flaskr.db < schema.sql

The downside of this is that it requires the sqlite3 command to be
installed which is not necessarily the case on every system.  Also one has
to provide the path to the database there which leaves some place for
errors.  It's a good idea to add a function that initializes the database
for you to the application.

If you want to do that, you first have to import the
:func:`contextlib.closing` function from the contextlib package.  If you
want to use Python 2.5 it's also necessary to enable the `with` statement
first (`__future__` imports must be the very first import)::

    from __future__ import with_statement
    from contextlib import closing

Next we can create a function called `init_db` that initializes the
database.  For this we can use the `connect_db` function we defined
earlier.  Just add that function below the `connect_db` function::
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

The :func:`~contextlib.closing` helper function allows us to keep a
connection open for the duration of the `with` block.  The
:func:`~flask.Flask.open_resource` method of the application object
supports that functionality out of the box, so it can be used in the
`with` block directly.  This function opens a file from the resource
location (your `flaskr` folder) and allows you to read from it.  We are
using this here to execute a script on the database connection.

When we connect to a database we get a connection object (here called
`db`) that can give us a cursor.  On that cursor there is a method to
execute a complete script.  Finally we only have to commit the changes.
SQLite 3 and other transactional databases will not commit unless you
explicitly tell it to.

Now it is possible to create a database by starting up a Python shell and
importing and calling that function::

>>> from flaskr import init_db
>>> init_db()

Step 4: Request Database Connections
------------------------------------

Now we know how we can open database connections and use them for scripts,
but how can we elegantly do that for requests?  We will need the database
connection in all our functions so it makes sense to initialize them
before each request and shut them down afterwards.

Flask allows us to do that with the :meth:`~flask.Flask.request_init` and
:meth:`~flask.Flask.request_shutdown` decorators::

    @app.request_init
    def before_request():
        g.db = connect_db()

    @app.request_shutdown
    def after_request(response):
        g.db.close()
        return response

Functions marked with :meth:`~flask.Flask.request_init` are called before
a request and passed no arguments, functions marked with
:meth:`~flask.Flask.request_shutdown` are called after a request and
passed the response that will be sent to the client.  They have to return
that response object or a different one.  In this case we just return it
unchanged.

We store our current database connection on the special :data:`~flask.g`
object that flask provides for us.  This object stores information for one
request only and is available from within each function.  Never store such
things on other objects because this would not work with threaded
environments.  That special :data:`~flask.g` object does some magic behind
the scenes to ensure it does the right thing.

Step 5: The View Functions
--------------------------

Now that the database connections are working we can start writing the
view functions.  We will need for of them:

Show Entries
````````````

This view shows all the entries stored in the database.  It listens on the
root of the application and will select title and text from the database.
The one with the highest id (the newest entry) on top.  The rows returned
from the cursor are tuples with the columns ordered like specified in the
select statement.  This is good enough for small applications like here,
but you might want to convert them into a dict.  If you are interested how
to do that, check out the :ref:`easy-querying` example.

The view function will pass the entries as dicts to the
`show_entries.html` template and return the rendered one::

    @app.route('/')
    def show_entries():
        cur = g.db.execute('select title, text from entries order by id desc')
        entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]
        return render_template('show_entries.html', entries=entries)

Add New Entry
`````````````

This view lets the user add new entries if he's logged in.  This only
responds to `POST` requests, the actual form is shown on the
`show_entries` page.  If everything worked out well we will
:func:`~flask.flash` an information message to the next request and
redirect back to the `show_entries` page::

    @app.route('/add', methods=['POST'])
    def add_entry():
        if not session.get('logged_in'):
            abort(401)
        g.db.execute('insert into entries (title, text) values (?, ?)',
                     [request.form['title'], request.form['text']])
        g.db.commit()
        flash('New entry was successfully posted')
        return redirect(url_for('show_entries'))

Note that we check that the user is logged in here (the `logged_in` key is
present in the session and `True`).

Login and Logout
````````````````

These functions are used to sign the user in and out.  Login checks the
username and password against the ones from the configuration and sets the
`logged_in` key in the session.  If the user logged in successfully that
key is set to `True` and the user is redirected back to the `show_entries`
page.  In that case also a message is flashed that informs the user he or
she was logged in successfully.  If an error occoured the template is
notified about that and the user asked again::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != USERNAME:
                error = 'Invalid username'
            elif request.form['password'] != PASSWORD:
                error = 'Invalid password'
            else:
                session['logged_in'] = True
                flash('You were logged in')
                return redirect(url_for('show_entries'))
        return render_template('login.html', error=error)

The logout function on the other hand removes that key from the session
again.  We use a neat trick here: if you use the :meth:`~dict.pop` method
of the dict and pass a second parameter to it (the default) the method
will delete the key from the dictionary if present or do nothing when that
key was not in there.  This is helpful because we don't have to check in
that case if the user was logged in.

::

    @app.route('/logout')
    def logout():
        session.pop('logged_in', None)
        flash('You were logged out')
        return redirect(url_for('show_entries'))

Step 6: The Templates
---------------------

Now we should start working on the templates.  If we request the URLs now
we would only get an exception that Flask cannot find the templates.  The
templates are using `Jinja2`_ syntax and have autoescaping enabled by
default.  This means that unless you mark a value in the code with
:class:`~flask.Markup` or with the ``|safe`` filter in the template,
Jinja2 will ensure that special characters such as ``<`` or ``>`` are
escaped with their XML equivalents.

We are also using template inheritance which makes it possible to reuse
the layout of the website in all pages.

Put the following templates into the `templates` folder:

layout.html
```````````

This template contains the HTML skeleton, the header and a link to log in
(or log out if the user was already logged in).  It also displays the
flashed messages if there are any.  The ``{% block body %}`` block can be
replaced by a block of the same name (``body``) in a child template.

The :class:`~flask.session` dict is available in the template as well and
you can use that to check if the user is logged in or not.  Note that in
Jinja you can access missing attributes and items of objects / dicts which
makes the following code work, even if there is no ``'logged_in'`` key in
the session:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Flaskr</title>
    <link rel=stylesheet type=text/css href=""{{ url_for('static', filename='style.css') }}"">
    <div class=page>
      <h1>Flaskr</h1>
      <div class=metanav>
      {% if not session.logged_in %}
        <a href=""{{ url_for('login') }}"">log in</a>
      {% else %}
        <a href=""{{ url_for('logout') }}"">log out</a>
      {% endif %}
      </div>
      {% for message in get_flashed_messages() %}
        <div class=flash>{{ message }}</div>
      {% endfor %}
      {% block body %}{% endblock %}
    </div>

show_entries.html
`````````````````

This template extends the `layout.html` template from above to display the
messages.  Note that the `for` loop iterates over the messages we passed
in with the :func:`~flask.render_template` function.  We also tell the
form to submit to your `add_entry` function and use `POST` as `HTTP`
method:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block body %}
      {% if session.logged_in %}
        <form action=""{{ url_for('add_entry') }}"" method=post class=add-entry>
          <dl>
            <dt>Title:
            <dd><input type=text size=30 name=title>
            <dt>Text:
            <dd><textarea name=text rows=5 cols=40></textarea>
            <dd><input type=submit value=Share>
          </dl>
        </form>
      {% endif %}
      <ul class=entries>
      {% for entry in entries %}
        <li><h2>{{ entry.title }}</h2>{{ entry.text|safe }}
      {% else %}
        <li><em>Unbelievable.  No entries here so far</em>
      {% endfor %}
      </ul>
    {% endblock %}

login.html
``````````

Finally the login template which basically just displays a form to allow
the user to login:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block body %}
      <h2>Login</h2>
      {% if error %}<p class=error><strong>Error:</strong> {{ error }}{% endif %}
      <form action=""{{ url_for('login') }}"" method=post>
        <dl>
          <dt>Username:
          <dd><input type=text name=username>
          <dt>Password:
          <dd><input type=password name=password>
          <dd><input type=submit value=Login>
        </dl>
      </form>
    {% endblock %}

Step 7: Adding Style
--------------------

Now that everything else works, it's time to add some style to the
application.  Just create a stylesheet called `style.css` in the `static`
folder we created before:

.. sourcecode:: css

    body            { font-family: sans-serif; background: #eee; }
    a, h1, h2       { color: #377BA8; }
    h1, h2          { font-family: 'Georgia', serif; margin: 0; }
    h1              { border-bottom: 2px solid #eee; }
    h2              { font-size: 1.2em; }
    
    .page           { margin: 2em auto; width: 35em; border: 5px solid #ccc;
                      padding: 0.8em; background: white; }
    .entries        { list-style: none; margin: 0; padding: 0; }
    .entries li     { margin: 0.8em 1.2em; }
    .entries li h2  { margin-left: -1em; }
    .add-entry      { font-size: 0.9em; border-bottom: 1px solid #ccc; }
    .add-entry dl   { font-weight: bold; }
    .metanav        { text-align: right; font-size: 0.8em; padding: 0.3em;
                      margin-bottom: 1em; background: #fafafa; }
    .flash          { background: #CEE5F5; padding: 0.5em;
                      border: 1px solid #AACBE2; }
    .error          { background: #F0D6D6; padding: 0.5em; }

Bonus: Testing the Application
-------------------------------

Now that you have finished the application and everything works as
expected, it's probably not the best idea to add automated tests to
simplify modifications in the future.  The application above is used as a
basic example of how to perform unittesting in the :ref:`testing` section
of the documentation.  Go there to see how easy it is to test Flask
applications.
",".. _tutorial:

Tutorial
========

You want to develop an application with Python and Flask?  Here you have
the chance to learn that by example.  In this tutorial we will create a
simple microblog application.  It only supports one user that can create
text-only entries and there are no feeds or comments, but it still
features everything you need to get started.  We will use Flask and SQLite
as database which comes out of the box with Python, so there is nothing
else you need.

If you want the full sourcecode in advance or for comparison, check out
the `example source`_.

.. _example source:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

Introducing Flaskr
------------------

We will call our blogging application flaskr here, feel free to chose a
less web-2.0-ish name ;)  Basically we want it to do the following things:

1. let the user sign in and out with credentials specified in the
   configuration.  Only one user is supported.
2. when the user is logged in he or she can add new entries to the page
   consisting of a text-only title and some HTML for the text.  This HTML
   is not sanitized because we trust the user here.
3. the page shows all entries so far in reverse order (newest on top) and
   the user can add new ones from there if logged in.

We will be using SQlite3 directly for that application because it's good
enough for an application of that size.  For larger applications however
it makes a lot of sense to use `SQLAlchemy`_ that handles database
connections in a more intelligent way, allows you to target different
relational databases at once and more.  You might also want to consider
one of the popular NoSQL databases if your data is more suited for those.

Here a screenshot from the final application:

.. image:: _static/flaskr.png
   :align: center
   :class: screenshot
   :alt: screenshot of the final application

.. _SQLAlchemy: http://www.sqlalchemy.org/

Step 0: Creating The Folders
----------------------------

Before we get started, let's create the folders needed for this
application::

    /flaskr
        /static
        /templates

The `flaskr` folder is not a python package, but just something where we
drop our files.  Directly into this folder we will then put our database
schema as well as main module in the following steps.  The files inside
the `static` folder are available to users of the application via `HTTP`.
This is the place where css and javascript files go.  Inside the
`templates` folder Flask will look for `Jinja2`_ templates.  Drop all the
templates there.

.. _Jinja2: http://jinja.pocoo.org/2/

Step 1: Database Schema
-----------------------

First we want to create the database schema.  For this application only a
single table is needed and we only want to support SQLite so that is quite
easy.  Just put the following contents into a file named `schema.sql` in
the just created `flaskr` folder:

.. sourcecode:: sql

    drop table if exists entries;
    create table entries (
      id integer primary key autoincrement,
      title string not null,
      text string not null
    );

This schema consists of a single table called `entries` and each row in
this table has an `id`, a `title` and a `text`.  The `id` is an
automatically incrementing integer and a primary key, the other two are
strings that must not be null.

Step 2: Application Setup Code
------------------------------

Now that we have the schema in place we can create the application module.
Let's call it `flaskr.py` inside the `flaskr` folder.  For starters we
will add the imports we will need as well as the config section.  For
small applications it's a possibility to drop the configuration directly
into the module which we will be doing here.  However a cleaner solution
would be to create a separate `.ini` or `.py` file and load that or import
the values from there.

::

    # all the imports
    import sqlite3
    from flask import Flask, request, session, g, redirect, url_for, \
         abort, render_template, flash

    # configuration
    DATABASE = '/tmp/flaskr.db'
    DEBUG = True
    SECRET_KEY = 'development key'
    USERNAME = 'admin'
    PASSWORD = 'default'

Next we can create our actual application and initialize it with the
config::

    # create our little application :)
    app = Flask(__name__)
    app.secret_key = SECRET_KEY
    app.debug = DEBUG

The `secret_key` is needed to keep the client-side sessions secure.
Choose that key wisely and as hard to guess and complex as possible.  The
debug flag enables or disables the interactive debugger.  Never leave
debug mode activated in a production system because it will allow users to
executed code on the server!

We also add a method to easily connect to the database specified.  That
can be used to open a connection on request and also from the interactive
Python shell or a script.  This will come in handy later

::

    def connect_db():
        return sqlite3.connect(DATABASE)

Finally we just add a line to the bottom of the file that fires up the
server if we run that file as standalone application::

    if __name__ == '__main__':
        app.run()

With that out of the way you should be able to start up the application
without problems.  When you head over to the server you will get an 404
page not found error because we don't have any views yet.  But we will
focus on that a little later.  First we should get the database working.

.. admonition:: Troubleshooting

   If you notice later that the browser cannot connect to the server
   during development, you might want to try this line instead::

       app.run(host='127.0.0.1')

   In a nutshell: Werkzeug starts up as IPv6 on many operating systems by
   default and not every browser is happy with that.  This forces IPv4
   usage.

Step 3: Creating The Database
-----------------------------

Flaskr is a database powered application as outlined earlier, and more
precisely, an application powered by a relational database system.  Such
systems need a schema that tells them how to store that information. So
before starting the server for the first time it's important to create
that schema.

Such a schema can be created by piping the `schema.sql` file into the
`sqlite3` command as follows::

    sqlite3 /tmp/flaskr.db < schema.sql

The downside of this is that it requires the sqlite3 command to be
installed which is not necessarily the case on every system.  Also one has
to provide the path to the database there which leaves some place for
errors.  It's a good idea to add a function that initializes the database
for you to the application.

If you want to do that, you first have to import the
:func:`contextlib.closing` function from the contextlib package.  If you
want to use Python 2.5 it's also necessary to enable the `with` statement
first (`__future__` imports must be the very first import)::

    from __future__ import with_statement
    from contextlib import closing

Next we can create a function called `init_db` that initializes the
database.  For this we can use the `connect_db` function we defined
earlier.  Just add that function below the `connect_db` function::
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

The :func:`~contextlib.closing` helper function allows us to keep a
connection open for the duration of the `with` block.  The
:func:`~flask.Flask.open_resource` method of the application object
supports that functionality out of the box, so it can be used in the
`with` block directly.  This function opens a file from the resource
location (your `flaskr` folder) and allows you to read from it.  We are
using this here to execute a script on the database connection.

When we connect to a database we get a connection object (here called
`db`) that can give us a cursor.  On that cursor there is a method to
execute a complete script.  Finally we only have to commit the changes.
SQLite 3 and other transactional databases will not commit unless you
explicitly tell it to.

Now it is possible to create a database by starting up a Python shell and
importing and calling that function::

>>> from flaskr import init_db
>>> init_db()

Step 4: Request Database Connections
------------------------------------

Now we know how we can open database connections and use them for scripts,
but how can we elegantly do that for requests?  We will need the database
connection in all our functions so it makes sense to initialize them
before each request and shut them down afterwards.

Flask allows us to do that with the :meth:`~flask.Flask.before_request` and
:meth:`~flask.Flask.after_request` decorators::

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

Functions marked with :meth:`~flask.Flask.before_request` are called before
a request and passed no arguments, functions marked with
:meth:`~flask.Flask.after_request` are called after a request and
passed the response that will be sent to the client.  They have to return
that response object or a different one.  In this case we just return it
unchanged.

We store our current database connection on the special :data:`~flask.g`
object that flask provides for us.  This object stores information for one
request only and is available from within each function.  Never store such
things on other objects because this would not work with threaded
environments.  That special :data:`~flask.g` object does some magic behind
the scenes to ensure it does the right thing.

Step 5: The View Functions
--------------------------

Now that the database connections are working we can start writing the
view functions.  We will need four of them:

Show Entries
````````````

This view shows all the entries stored in the database.  It listens on the
root of the application and will select title and text from the database.
The one with the highest id (the newest entry) on top.  The rows returned
from the cursor are tuples with the columns ordered like specified in the
select statement.  This is good enough for small applications like here,
but you might want to convert them into a dict.  If you are interested how
to do that, check out the :ref:`easy-querying` example.

The view function will pass the entries as dicts to the
`show_entries.html` template and return the rendered one::

    @app.route('/')
    def show_entries():
        cur = g.db.execute('select title, text from entries order by id desc')
        entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]
        return render_template('show_entries.html', entries=entries)

Add New Entry
`````````````

This view lets the user add new entries if he's logged in.  This only
responds to `POST` requests, the actual form is shown on the
`show_entries` page.  If everything worked out well we will
:func:`~flask.flash` an information message to the next request and
redirect back to the `show_entries` page::

    @app.route('/add', methods=['POST'])
    def add_entry():
        if not session.get('logged_in'):
            abort(401)
        g.db.execute('insert into entries (title, text) values (?, ?)',
                     [request.form['title'], request.form['text']])
        g.db.commit()
        flash('New entry was successfully posted')
        return redirect(url_for('show_entries'))

Note that we check that the user is logged in here (the `logged_in` key is
present in the session and `True`).

Login and Logout
````````````````

These functions are used to sign the user in and out.  Login checks the
username and password against the ones from the configuration and sets the
`logged_in` key in the session.  If the user logged in successfully that
key is set to `True` and the user is redirected back to the `show_entries`
page.  In that case also a message is flashed that informs the user he or
she was logged in successfully.  If an error occoured the template is
notified about that and the user asked again::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != USERNAME:
                error = 'Invalid username'
            elif request.form['password'] != PASSWORD:
                error = 'Invalid password'
            else:
                session['logged_in'] = True
                flash('You were logged in')
                return redirect(url_for('show_entries'))
        return render_template('login.html', error=error)

The logout function on the other hand removes that key from the session
again.  We use a neat trick here: if you use the :meth:`~dict.pop` method
of the dict and pass a second parameter to it (the default) the method
will delete the key from the dictionary if present or do nothing when that
key was not in there.  This is helpful because we don't have to check in
that case if the user was logged in.

::

    @app.route('/logout')
    def logout():
        session.pop('logged_in', None)
        flash('You were logged out')
        return redirect(url_for('show_entries'))

Step 6: The Templates
---------------------

Now we should start working on the templates.  If we request the URLs now
we would only get an exception that Flask cannot find the templates.  The
templates are using `Jinja2`_ syntax and have autoescaping enabled by
default.  This means that unless you mark a value in the code with
:class:`~flask.Markup` or with the ``|safe`` filter in the template,
Jinja2 will ensure that special characters such as ``<`` or ``>`` are
escaped with their XML equivalents.

We are also using template inheritance which makes it possible to reuse
the layout of the website in all pages.

Put the following templates into the `templates` folder:

layout.html
```````````

This template contains the HTML skeleton, the header and a link to log in
(or log out if the user was already logged in).  It also displays the
flashed messages if there are any.  The ``{% block body %}`` block can be
replaced by a block of the same name (``body``) in a child template.

The :class:`~flask.session` dict is available in the template as well and
you can use that to check if the user is logged in or not.  Note that in
Jinja you can access missing attributes and items of objects / dicts which
makes the following code work, even if there is no ``'logged_in'`` key in
the session:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Flaskr</title>
    <link rel=stylesheet type=text/css href=""{{ url_for('static', filename='style.css') }}"">
    <div class=page>
      <h1>Flaskr</h1>
      <div class=metanav>
      {% if not session.logged_in %}
        <a href=""{{ url_for('login') }}"">log in</a>
      {% else %}
        <a href=""{{ url_for('logout') }}"">log out</a>
      {% endif %}
      </div>
      {% for message in get_flashed_messages() %}
        <div class=flash>{{ message }}</div>
      {% endfor %}
      {% block body %}{% endblock %}
    </div>

show_entries.html
`````````````````

This template extends the `layout.html` template from above to display the
messages.  Note that the `for` loop iterates over the messages we passed
in with the :func:`~flask.render_template` function.  We also tell the
form to submit to your `add_entry` function and use `POST` as `HTTP`
method:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block body %}
      {% if session.logged_in %}
        <form action=""{{ url_for('add_entry') }}"" method=post class=add-entry>
          <dl>
            <dt>Title:
            <dd><input type=text size=30 name=title>
            <dt>Text:
            <dd><textarea name=text rows=5 cols=40></textarea>
            <dd><input type=submit value=Share>
          </dl>
        </form>
      {% endif %}
      <ul class=entries>
      {% for entry in entries %}
        <li><h2>{{ entry.title }}</h2>{{ entry.text|safe }}
      {% else %}
        <li><em>Unbelievable.  No entries here so far</em>
      {% endfor %}
      </ul>
    {% endblock %}

login.html
``````````

Finally the login template which basically just displays a form to allow
the user to login:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block body %}
      <h2>Login</h2>
      {% if error %}<p class=error><strong>Error:</strong> {{ error }}{% endif %}
      <form action=""{{ url_for('login') }}"" method=post>
        <dl>
          <dt>Username:
          <dd><input type=text name=username>
          <dt>Password:
          <dd><input type=password name=password>
          <dd><input type=submit value=Login>
        </dl>
      </form>
    {% endblock %}

Step 7: Adding Style
--------------------

Now that everything else works, it's time to add some style to the
application.  Just create a stylesheet called `style.css` in the `static`
folder we created before:

.. sourcecode:: css

    body            { font-family: sans-serif; background: #eee; }
    a, h1, h2       { color: #377BA8; }
    h1, h2          { font-family: 'Georgia', serif; margin: 0; }
    h1              { border-bottom: 2px solid #eee; }
    h2              { font-size: 1.2em; }
    
    .page           { margin: 2em auto; width: 35em; border: 5px solid #ccc;
                      padding: 0.8em; background: white; }
    .entries        { list-style: none; margin: 0; padding: 0; }
    .entries li     { margin: 0.8em 1.2em; }
    .entries li h2  { margin-left: -1em; }
    .add-entry      { font-size: 0.9em; border-bottom: 1px solid #ccc; }
    .add-entry dl   { font-weight: bold; }
    .metanav        { text-align: right; font-size: 0.8em; padding: 0.3em;
                      margin-bottom: 1em; background: #fafafa; }
    .flash          { background: #CEE5F5; padding: 0.5em;
                      border: 1px solid #AACBE2; }
    .error          { background: #F0D6D6; padding: 0.5em; }

Bonus: Testing the Application
-------------------------------

Now that you have finished the application and everything works as
expected, it's probably not the best idea to add automated tests to
simplify modifications in the future.  The application above is used as a
basic example of how to perform unittesting in the :ref:`testing` section
of the documentation.  Go there to see how easy it is to test Flask
applications.
","@@ -225,21 +225,21 @@ but how can we elegantly do that for requests?  We will need the database
 connection in all our functions so it makes sense to initialize them
 before each request and shut them down afterwards.
 
-Flask allows us to do that with the :meth:`~flask.Flask.request_init` and
-:meth:`~flask.Flask.request_shutdown` decorators::
+Flask allows us to do that with the :meth:`~flask.Flask.before_request` and
+:meth:`~flask.Flask.after_request` decorators::
 
-    @app.request_init
+    @app.before_request
     def before_request():
         g.db = connect_db()
 
-    @app.request_shutdown
+    @app.after_request
     def after_request(response):
         g.db.close()
         return response
 
-Functions marked with :meth:`~flask.Flask.request_init` are called before
+Functions marked with :meth:`~flask.Flask.before_request` are called before
 a request and passed no arguments, functions marked with
-:meth:`~flask.Flask.request_shutdown` are called after a request and
+:meth:`~flask.Flask.after_request` are called after a request and
 passed the response that will be sent to the client.  They have to return
 that response object or a different one.  In this case we just return it
 unchanged.
@@ -255,7 +255,7 @@ Step 5: The View Functions
 --------------------------
 
 Now that the database connections are working we can start writing the
-view functions.  We will need for of them:
+view functions.  We will need four of them:
 
 Show Entries
 ````````````
",add docs for view functions,add docs for view functions,add docs for view functions,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",flaskr.py,"# -*- coding: utf-8 -*-
""""""
    Flaskr
    ~~~~~~

    A microblog example application written as Flask tutorial with
    Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import sqlite3
from contextlib import closing
from flask import Flask, request, session, g, redirect, url_for, abort, \
     render_template, flash

# configuration
DATABASE = '/tmp/flaskr.db'
DEBUG = True
SECRET_KEY = 'development key'
USERNAME = 'admin'
PASSWORD = 'default'

# create our little application :)
app = Flask(__name__)
app.secret_key = SECRET_KEY
app.debug = DEBUG


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


@app.request_init
def before_request():
    """"""Make sure we are connected to the database each request.""""""
    g.db = connect_db()


@app.request_shutdown
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def show_entries():
    cur = g.db.execute('select title, text from entries order by id desc')
    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]
    return render_template('show_entries.html', entries=entries)


@app.route('/add', methods=['POST'])
def add_entry():
    if not session.get('logged_in'):
        abort(401)
    g.db.execute('insert into entries (title, text) values (?, ?)',
                 [request.form['title'], request.form['text']])
    g.db.commit()
    flash('New entry was successfully posted')
    return redirect(url_for('show_entries'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        if request.form['username'] != USERNAME:
            error = 'Invalid username'
        elif request.form['password'] != PASSWORD:
            error = 'Invalid password'
        else:
            session['logged_in'] = True
            flash('You were logged in')
            return redirect(url_for('show_entries'))
    return render_template('login.html', error=error)


@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('show_entries'))


if __name__ == '__main__':
    app.run()
","# -*- coding: utf-8 -*-
""""""
    Flaskr
    ~~~~~~

    A microblog example application written as Flask tutorial with
    Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import sqlite3
from contextlib import closing
from flask import Flask, request, session, g, redirect, url_for, abort, \
     render_template, flash

# configuration
DATABASE = '/tmp/flaskr.db'
DEBUG = True
SECRET_KEY = 'development key'
USERNAME = 'admin'
PASSWORD = 'default'

# create our little application :)
app = Flask(__name__)
app.secret_key = SECRET_KEY
app.debug = DEBUG


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request.""""""
    g.db = connect_db()


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def show_entries():
    cur = g.db.execute('select title, text from entries order by id desc')
    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]
    return render_template('show_entries.html', entries=entries)


@app.route('/add', methods=['POST'])
def add_entry():
    if not session.get('logged_in'):
        abort(401)
    g.db.execute('insert into entries (title, text) values (?, ?)',
                 [request.form['title'], request.form['text']])
    g.db.commit()
    flash('New entry was successfully posted')
    return redirect(url_for('show_entries'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        if request.form['username'] != USERNAME:
            error = 'Invalid username'
        elif request.form['password'] != PASSWORD:
            error = 'Invalid password'
        else:
            session['logged_in'] = True
            flash('You were logged in')
            return redirect(url_for('show_entries'))
    return render_template('login.html', error=error)


@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('show_entries'))


if __name__ == '__main__':
    app.run()
","@@ -41,13 +41,13 @@ def init_db():
         db.commit()
 
 
-@app.request_init
+@app.before_request
 def before_request():
     """"""Make sure we are connected to the database each request.""""""
     g.db = connect_db()
 
 
-@app.request_shutdown
+@app.after_request
 def after_request(response):
     """"""Closes the database again at the end of the request.""""""
     g.db.close()
",add tests for the new microblog example,add tests for the new microblog example,add tests for the new microblog example,llm_rectified,0.0,7,False,70.28534779104871,70.28534779104871,13,13,98,98,0.0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",minitwit.py,"# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.request_init
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.request_shutdown
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    offset = request.args.get('offset', type=int)
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followd = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    offset = request.args.get('offset', type=int)
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followd = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","@@ -69,7 +69,7 @@ def gravatar_url(email, size=80):
         (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)
 
 
-@app.request_init
+@app.before_request
 def before_request():
     """"""Make sure we are connected to the database each request and look
     up the current user so that we know he's there.
@@ -81,7 +81,7 @@ def before_request():
                           [session['user_id']], one=True)
 
 
-@app.request_shutdown
+@app.after_request
 def after_request(response):
     """"""Closes the database again at the end of the request.""""""
     g.db.close()
",add more application-level functions,add more application-level functions,add more application-level functions,llm_rectified,0.0,4,False,48.73457184659348,48.73457184659348,44,44,250,250,0.0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`request_init`
        #: decorator.
        self.request_init_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`request_shtdown`
        #: decorator.
        self.request_shutdown_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def request_init(self, f):
        """"""Registers a function to run before each request.""""""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """"""Register a function to be run after each request.""""""
        self.request_shutdown_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -249,16 +249,16 @@ class Flask(object):
         #: of the request before request dispatching kicks in.  This
         #: can for example be used to open database connections or
         #: getting hold of the currently logged in user.
-        #: To register a function here, use the :meth:`request_init`
+        #: To register a function here, use the :meth:`before_request`
         #: decorator.
-        self.request_init_funcs = []
+        self.before_request_funcs = []
 
         #: a list of functions that are called at the end of the
         #: request.  Tha function is passed the current response
         #: object and modify it in place or replace it.
-        #: To register a function here use the :meth:`request_shtdown`
+        #: To register a function here use the :meth:`after_request`
         #: decorator.
-        self.request_shutdown_funcs = []
+        self.after_request_funcs = []
 
         #: a list of functions that are called without arguments
         #: to populate the template context.  Each returns a dictionary
@@ -509,14 +509,14 @@ class Flask(object):
             return f
         return decorator
 
-    def request_init(self, f):
+    def before_request(self, f):
         """"""Registers a function to run before each request.""""""
-        self.request_init_funcs.append(f)
+        self.before_request_funcs.append(f)
         return f
 
-    def request_shutdown(self, f):
+    def after_request(self, f):
         """"""Register a function to be run after each request.""""""
-        self.request_shutdown_funcs.append(f)
+        self.after_request_funcs.append(f)
         return f
 
     def context_processor(self, f):
@@ -583,19 +583,20 @@ class Flask(object):
 
     def preprocess_request(self):
         """"""Called before the actual request dispatching and will
-        call every as :func:`request_init` decorated function.
+        call every as :meth:`before_request` decorated function.
         If any of these function returns a value it's handled as
         if it was the return value from the view and further
         request handling is stopped.
         """"""
-        for func in self.request_init_funcs:
+        for func in self.before_request_funcs:
             rv = func()
             if rv is not None:
                 return rv
 
     def process_response(self, response):
         """"""Can be overridden in order to modify the response object
-        before it's sent to the WSGI server.
+        before it's sent to the WSGI server.  By default this will
+        call all the :meth:`after_request` decorated functions.
 
         :param response: a :attr:`response_class` object.
         :return: a new response object or the same, has to be an
@@ -604,7 +605,7 @@ class Flask(object):
         session = _request_ctx_stack.top.session
         if session is not None:
             self.save_session(session, response)
-        for handler in self.request_shutdown_funcs:
+        for handler in self.after_request_funcs:
             response = handler(response)
         return response
 
",add missing docstring to flask/views/view.py,add missing docstring to flask/views/view.py,add missing docstring to flask/views/view.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
fb2d2e446bdd806ea3de7b869c7371e2dae57a23,"request_init -> before_request and request_shutdown -> after_request

This fixes #9.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionality(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.request_init
        def before_request():
            evts.append('before')
        @app.request_shutdown
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class Templating(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]


if __name__ == '__main__':
    unittest.main()
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionality(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class Templating(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]


if __name__ == '__main__':
    unittest.main()
","@@ -75,10 +75,10 @@ class BasicFunctionality(unittest.TestCase):
     def test_request_processing(self):
         app = flask.Flask(__name__)
         evts = []
-        @app.request_init
+        @app.before_request
         def before_request():
             evts.append('before')
-        @app.request_shutdown
+        @app.after_request
         def after_request(response):
             response.data += '|after'
             evts.append('after')
",add tests for context and client context,add tests for context and client context,add tests for context and client context,llm_rectified,0.0,7,False,41.33783424823284,41.33783424823284,55,55,188,188,0.0,0,0
f54c4fd04f326d94684c7fcbf12df5cecae653c4,Fixed wording for circular imports,patterns.rst,".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when one module depends on another one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the modules into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, subclass the `Base` class the above code generated.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
",".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when two module depend on each one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the modules into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, subclass the `Base` class the above code generated.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
","@@ -87,7 +87,7 @@ And this is what `views.py` would look like::
 .. admonition:: Circular Imports
 
    Every Python programmer hates it, and yet we just did that: circular
-   imports (That's when one module depends on another one.  In this case
+   imports (That's when two module depend on each one.  In this case
    `views.py` depends on `__init__.py`).  Be advised that this is a bad
    idea in general but here it is actually fine.  The reason for this is
    that we are not actually using the views in `__init__.py` and just
",add more info about the module changes,add more info about the module changes,add more info about the module changes,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
6418551efb1d24320c261b1e24c186d5394e6dcf,More typo fixes,becomingbig.rst,".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bringing those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expanding on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large applications consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here some suggestions how Flask can be modified to better accomodate large
scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifing the target functions explictliy or by name and importing
    them when needed.
-   switch to explicit request object passing.  This makes it more to type
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does not Flask do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code or something of larger scale.  At one
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and less easy to get started with.
",".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bringing those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expanding on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large applications consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here some suggestions how Flask can be modified to better accomodate large
scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifing the target functions explictly or by name and importing
    them when needed.
-   switch to explicit request object passing.  This makes it more to type
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does not Flask do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code or something of larger scale.  At one
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and less easy to get started with.
","@@ -33,7 +33,7 @@ scale applications:
     also requires that the whole application is imported when the system
     initializes or certain URLs will not be available right away.   A
     better solution would be to have one module with all URLs in there and
-    specifing the target functions explictliy or by name and importing
+    specifing the target functions explictly or by name and importing
     them when needed.
 -   switch to explicit request object passing.  This makes it more to type
     (because you now have something to pass around) but it makes it a
",add more info about the type of module,add more info about the type of module,add more info about the type of module,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
6418551efb1d24320c261b1e24c186d5394e6dcf,More typo fixes,patterns.rst,".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when two module depend on each one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the modules into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, subclass the `Base` class the above code generated.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
",".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when two module depend on each one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the models into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, just subclass the `Base` class that was created by
the code above.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module.  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
","@@ -195,7 +195,7 @@ SQLAlchemy in Flask
 
 Many people prefer `SQLAlchemy`_ for database access.  In this case it's
 encouraged to use a package instead of a module for your flask application
-and drop the modules into a separate module (:ref:`larger-applications`).
+and drop the models into a separate module (:ref:`larger-applications`).
 Although that is not necessary but makes a lot of sense.
 
 There are three very common ways to use SQLAlchemy.  I will outline each
@@ -225,10 +225,11 @@ Here the example `database.py` module for your application::
     def init_db():
         Base.metadata.create_all(bind=engine)
 
-To define your models, subclass the `Base` class the above code generated.
+To define your models, just subclass the `Base` class that was created by
+the code above.
 
 To use SQLAlchemy in a declarative way with your application, you just
-have to put the following code into your application module  Flask will
+have to put the following code into your application module.  Flask will
 automatically remove database sessions at the end of the request for you::
 
     from yourapplication.database import db_session
",add documentation for database module,add documentation for database module,add documentation for database module,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
7c9303b7502403c372171e1e045433b57259a56b,More typo fixes,becomingbig.rst,".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bringing those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expanding on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large applications consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here some suggestions how Flask can be modified to better accomodate large
scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifing the target functions explictly or by name and importing
    them when needed.
-   switch to explicit request object passing.  This makes it more to type
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does not Flask do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code or something of larger scale.  At one
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and less easy to get started with.
",".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bringing those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expanding on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large applications consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here some suggestions how Flask can be modified to better accomodate large
scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifing the target functions explicitly or by name and importing
    them when needed.
-   switch to explicit request object passing.  This makes it more to type
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directly into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does not Flask do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code or something of larger scale.  At one
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and less easy to get started with.
","@@ -33,12 +33,12 @@ scale applications:
     also requires that the whole application is imported when the system
     initializes or certain URLs will not be available right away.   A
     better solution would be to have one module with all URLs in there and
-    specifing the target functions explictly or by name and importing
+    specifing the target functions explicitly or by name and importing
     them when needed.
 -   switch to explicit request object passing.  This makes it more to type
     (because you now have something to pass around) but it makes it a
     whole lot easier to debug hairy situations and to test the code.
--   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directl into the
+-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directly into the
     core framework.
 
 .. _Babel: http://babel.edgewall.org/
",add more info about url rule,add more info about url rule,add more info about url rule,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
5348eff4457a528cd605bbbd5e0152c282819962,fixed headers,patterns.rst,".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when two module depend on each one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the models into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, just subclass the `Base` class that was created by
the code above.  If you are wondering why we don't have to care about
threads here (like we did in the SQLite3 example above with the
:data:`~flask.g` object): that's because SQLAlchemy does that for us
already with the :class:`~sqlalchemy.orm.scoped_session`.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module.  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html

Manual Object Relational Mapping
--------------------------------

*coming soon*

SQL Abstraction Layer
---------------------

*coming soon*


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
",".. _patterns:

Patterns for Flask
==================

Certain things are common enough that the changes are high you will find
them in most web applications.  For example quite a lot of applications
are using relational databases and user authentication.  In that case,
changes are they will open a database connection at the beginning of the
request and get the information of the currently logged in user.  At the
end of the request, the database connection is closed again.


.. _larger-applications:

Larger Applications
-------------------

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation have to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resole to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the objects itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates it, and yet we just did that: circular
   imports (That's when two module depend on each one.  In this case
   `views.py` depends on `__init__.py`).  Be advised that this is a bad
   idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.


.. _database-pattern:

Using SQLite 3 with Flask
-------------------------

In Flask you can implement opening of dabase connections at the beginning
of the request and closing at the end with the
:meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request`
decorators in combination with the special :class:`~flask.g` object.

So here a simple example how you can use SQLite 3 with Flask::

    import sqlite3
    from flask import g

    DATABASE = '/path/to/database.db'

    def connect_db():
        return sqlite3.connect(DATABASE)

    @app.before_request
    def before_request():
        g.db = connect_db()

    @app.after_request
    def after_request(response):
        g.db.close()
        return response

.. _easy-querying:

Easy Querying
`````````````

Now in each request handling function you can access `g.db` to get the
current open database connection.  To simplify working with SQLite a
helper function can be useful::

    def query_db(query, args=(), one=False):
        cur = g.db.execute(query, args)
        rv = [dict((cur.description[idx][0], value)
                   for idx, value in enumerate(row)) for row in cur.fetchall()]
        return (rv[0] if rv else None) if one else rv

This handy little function makes working with the database much more
pleasant than it is by just using the raw cursor and connection objects.

Here is how you can use it::

    for user in query_db('select * from users'):
        print user['username'], 'has the id', user['user_id']

Or if you just want a single result::

    user = query_db('select * from users where username = ?',
                    [the_username], one=True)
    if user is None:
        print 'No such user'
    else:
        print the_username, 'has the id', user['user_id']

To pass variable parts to the SQL statement, use a question mark in the
statement and pass in the arguments as a list.  Never directly add them to
the SQL statement with string formattings because this makes it possible
to attack the application using `SQL Injections
<http://en.wikipedia.org/wiki/SQL_injection>`_.

Initial Schemas
```````````````

Relational databases need schemas, so applications often ship a
`schema.sql` file that creates the database.  It's a good idea to provide
a function that creates the database bases on that schema.  This function
can do that for you::

    from contextlib import closing
    
    def init_db():
        with closing(connect_db()) as db:
            with app.open_resource('schema.sql') as f:
                db.cursor().executescript(f.read())
            db.commit()

You can then create such a database from the python shell:

>>> from yourapplication import init_db
>>> init_db()


.. _sqlalchemy-pattern:

SQLAlchemy in Flask
-------------------

Many people prefer `SQLAlchemy`_ for database access.  In this case it's
encouraged to use a package instead of a module for your flask application
and drop the models into a separate module (:ref:`larger-applications`).
Although that is not necessary but makes a lot of sense.

There are three very common ways to use SQLAlchemy.  I will outline each
of them here:

Declarative
```````````

The declarative extension in SQLAlchemy is the most recent method of using
SQLAlchemy.  It allows you to define tables and models in one go, similar
to how Django works.  In addition to the following text I recommend the
official documentation on the `declarative`_ extension.

Here the example `database.py` module for your application::

    from sqlalchemy import create_engine
    from sqlalchemy.orm import scoped_session, sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    engine = create_engine('sqlite:////tmp/test.db')
    db_session = scoped_session(sessionmaker(autocommit=False,
                                             autoflush=False,
                                             bind=engine)) 
    Base = declarative_base()
    Base.query = db_session.query_property()

    def init_db():
        Base.metadata.create_all(bind=engine)

To define your models, just subclass the `Base` class that was created by
the code above.  If you are wondering why we don't have to care about
threads here (like we did in the SQLite3 example above with the
:data:`~flask.g` object): that's because SQLAlchemy does that for us
already with the :class:`~sqlalchemy.orm.scoped_session`.

To use SQLAlchemy in a declarative way with your application, you just
have to put the following code into your application module.  Flask will
automatically remove database sessions at the end of the request for you::

    from yourapplication.database import db_session

    @app.after_request
    def shutdown_session(response):
        db_session.remove()
        return response

Here an example model (put that into `models.py` for instance)::

    from sqlalchemy import Column, Integer, String
    from yourapplication.database import Base

    class User(Base):
        __tablename__ = 'users'
        id = Column(Integer, primary_key=True)
        name = Column(String(50), unique=True)
        email = Column(String(120), unique=True)

        def __init__(self, name=None, email=None):
            self.name = name
            self.email = email

        def __repr__(self):
            return '<User %r>' % (self.name, self.email)

You can insert entries into the database like this then:

>>> from yourapplication.database import db_session
>>> from yourapplication.models import User
>>> u = User('admin', 'admin@localhost')
>>> db_session.add(u)
>>> db_session.commit()

Querying is simple as well:

>>> User.query.all()
[<User u'admin'>]
>>> User.query.filter(User.name == 'admin').first()
<User u'admin'>

.. _SQLAlchemy: http://www.sqlalchemy.org/
.. _declarative:
   http://www.sqlalchemy.org/docs/reference/ext/declarative.html

Manual Object Relational Mapping
````````````````````````````````

*coming soon*

SQL Abstraction Layer
`````````````````````

*coming soon*


.. _template-inheritance:

Template Inheritance
--------------------

The most powerful part of Jinja is template inheritance. Template inheritance
allows you to build a base ""skeleton"" template that contains all the common
elements of your site and defines **blocks** that child templates can override.

Sounds complicated but is very basic. It's easiest to understand it by starting
with an example.


Base Template
`````````````

This template, which we'll call ``layout.html``, defines a simple HTML skeleton
document that you might use for a simple two-column page. It's the job of
""child"" templates to fill the empty blocks with content:

.. sourcecode:: html+jinja

    <!doctype html>
    <html>
      <head>
        {% block head %}
        <link rel=""stylesheet"" href=""{{ url_for('static', filename='style.css') }}"">
        <title>{% block title %}{% endblock %} - My Webpage</title>
        {% endblock %}
      </head>
    <body>
      <div id=""content"">{% block content %}{% endblock %}</div>
      <div id=""footer"">
        {% block footer %}
        &copy; Copyright 2010 by <a href=""http://domain.invalid/"">you</a>.
        {% endblock %}
      </div>
    </body>

In this example, the ``{% block %}`` tags define four blocks that child templates
can fill in. All the `block` tag does is to tell the template engine that a
child template may override those portions of the template.

Child Template
``````````````

A child template might look like this:

.. sourcecode:: html+jinja

    {% extends ""layout.html"" %}
    {% block title %}Index{% endblock %}
    {% block head %}
      {{ super() }}
      <style type=""text/css"">
        .important { color: #336699; }
      </style>
    {% endblock %}
    {% block content %}
      <h1>Index</h1>
      <p class=""important"">
        Welcome on my awesome homepage.
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template ""extends"" another template.  When the template system evaluates
this template, first it locates the parent.  The extends tag must be the
first tag in the template.  To render the contents of a block defined in
the parent template, use ``{{ super() }}``.

.. _message-flashing-pattern:

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

So here a full example::

    from flask import flash, redirect, url_for, render_template

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        error = None
        if request.method == 'POST':
            if request.form['username'] != 'admin' or \
               request.form['password'] != 'secret':
                error = 'Invalid credentials'
            else:
                flash('You were sucessfully logged in')
                return redirect(url_for('index'))
        return render_template('login.html', error=error)

And here the ``layout.html`` template which does the magic:

.. sourcecode:: html+jinja

   <!doctype html>
   <title>My Application</title>
   {% with messages = get_flashed_messages() %}
     {% if messages %}
       <ul class=flashes>
       {% for message in messages %}
         <li>{{ message }}</li>
       {% endfor %}
       </ul>
     {% endif %}
   {% endwith %}
   {% block body %}{% endblock %}

And here the index.html template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Overview</h1>
     <p>Do you want to <a href=""{{ url_for('login') }}"">log in?</a>
   {% endblock %}

And of course the login template:

.. sourcecode:: html+jinja

   {% extends ""layout.html"" %}
   {% block body %}
     <h1>Login</h1>
     {% if error %}
       <p class=error><strong>Error:</strong> {{ error }}
     {% endif %}
     <form action="""" method=post>
       <dl>
         <dt>Username:
         <dd><input type=text name=username value=""{{
             request.form.username }}"">
         <dt>Password:
         <dd><input type=password name=password>
       </dl>
       <p><input type=submit value=Login>
     </form>
   {% endblock %}
","@@ -280,12 +280,12 @@ Querying is simple as well:
    http://www.sqlalchemy.org/docs/reference/ext/declarative.html
 
 Manual Object Relational Mapping
---------------------------------
+````````````````````````````````
 
 *coming soon*
 
 SQL Abstraction Layer
----------------------
+`````````````````````
 
 *coming soon*
 
",add documentation for a new module,add documentation for a new module,add documentation for a new module,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
791cdb28f593d4d7649d88407fcd193834512219,Fixed capitalization on website,index.html,"<!doctype html>
<title>Flask (A Python Microframework)</title>
<style type=text/css>
  body  { font-family: 'Georgia', serif; font-size: 17px; color: #000; }
  a     { color: #444; font-weight: bold; }
  .box  { width: 540px; margin: 40px auto; }
  h1    { margin: 0 0 30px 0; background: url(logo.png) no-repeat center; height: 165px; }
  h2    { font-size: 26px; margin: 15px 0 5px 0; font-variant: small-caps; }
  code,
  pre   { font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono',
          monospace; font-size: 15px; background: #eee; }
  pre   { padding: 7px 30px; margin: 15px -30px; }
  .ig   { color: #888; }
  ul    { margin: 15px 0; padding: 0; }
  h1 span, p.tagline { display: none; }
  blockquote { margin: 0; font-style: italic; color: #444; }
  .footer { font-size: 13px; color: #888; text-align: right; margin-top: 25px; }
  pre a, blockquote a, .footer a { font-weight: normal; color: inherit; }
</style>
<div class=box>
  <h1><span>Flask</span></h1>
  <p class=tagline>because sometimes a pocket knife is not enough
  <blockquote>
    Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.
    And before you ask: It's <a href=http://github.com/mitsuhiko/flask/blob/master/LICENSE>BSD licensed</a>!
  </blockquote>
  <h2>Flask is Fun</h2>
  <pre><span class=ig>from flask import Flask
app = Flask(__name__)</span>

@app.route(""/"")
def hello():
    return ""Hello World!""

<span class=ig>if __name__ == ""__main__"":
    app.run()</span></pre>
  <h2>And Easy to Setup</h2>
  <pre><span class=ig>$ </span>easy_install Flask
<span class=ig>$ </span>python hello.py
<span class=ig> * Running on <a href=http://localhost:5000/>http://localhost:5000/</a></span></pre>
  <h2>Interested?</h2>
  <ul>
    <li><a href=docs/>Read the documentation</a>
    <li><a href=http://github.com/mitsuhiko/flask>fork it on github</a>
    <li><a href=http://pypi.python.org/pypi/Flask>download it from PyPI</a>
  </ul>
  <h2>Contribute</h2>
  <p>Found a bug? Have a good idea for improving Flask? Head over to
    <a href=http://github.com/mitsuhiko/flask>Flask's github</a> page and
    create a new ticket or fork.  If you just want to chat with the
    developers, go to <code>#pocoo</code> on irc.freenode.net 
  <p class=footer>&copy; Copyright 2010 by <a href=http://lucumr.pocoo.org/>Armin Ronacher</a>
</div>

<a href=""http://github.com/mitsuhiko/flask""><img style=""position: fixed; top: 0; right: 0; border: 0;""
  src=""http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"" alt=""Fork me on GitHub""></a>
","<!doctype html>
<title>Flask (A Python Microframework)</title>
<style type=text/css>
  body  { font-family: 'Georgia', serif; font-size: 17px; color: #000; }
  a     { color: #444; font-weight: bold; }
  .box  { width: 540px; margin: 40px auto; }
  h1    { margin: 0 0 30px 0; background: url(logo.png) no-repeat center; height: 165px; }
  h2    { font-size: 26px; margin: 15px 0 5px 0; font-variant: small-caps; }
  code,
  pre   { font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono',
          monospace; font-size: 15px; background: #eee; }
  pre   { padding: 7px 30px; margin: 15px -30px; }
  .ig   { color: #888; }
  ul    { margin: 15px 0; padding: 0; }
  h1 span, p.tagline { display: none; }
  blockquote { margin: 0; font-style: italic; color: #444; }
  .footer { font-size: 13px; color: #888; text-align: right; margin-top: 25px; }
  pre a, blockquote a, .footer a { font-weight: normal; color: inherit; }
</style>
<div class=box>
  <h1><span>Flask</span></h1>
  <p class=tagline>because sometimes a pocket knife is not enough
  <blockquote>
    Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.
    And before you ask: It's <a href=http://github.com/mitsuhiko/flask/blob/master/LICENSE>BSD licensed</a>!
  </blockquote>
  <h2>Flask is Fun</h2>
  <pre><span class=ig>from flask import Flask
app = Flask(__name__)</span>

@app.route(""/"")
def hello():
    return ""Hello World!""

<span class=ig>if __name__ == ""__main__"":
    app.run()</span></pre>
  <h2>And Easy to Setup</h2>
  <pre><span class=ig>$ </span>easy_install Flask
<span class=ig>$ </span>python hello.py
<span class=ig> * Running on <a href=http://localhost:5000/>http://localhost:5000/</a></span></pre>
  <h2>Interested?</h2>
  <ul>
    <li><a href=docs/>Read the documentation</a>
    <li><a href=http://github.com/mitsuhiko/flask>Fork it on github</a>
    <li><a href=http://pypi.python.org/pypi/Flask>Download it from PyPI</a>
  </ul>
  <h2>Contribute</h2>
  <p>Found a bug? Have a good idea for improving Flask? Head over to
    <a href=http://github.com/mitsuhiko/flask>Flask's github</a> page and
    create a new ticket or fork.  If you just want to chat with the
    developers, go to <code>#pocoo</code> on irc.freenode.net 
  <p class=footer>&copy; Copyright 2010 by <a href=http://lucumr.pocoo.org/>Armin Ronacher</a>
</div>

<a href=""http://github.com/mitsuhiko/flask""><img style=""position: fixed; top: 0; right: 0; border: 0;""
  src=""http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"" alt=""Fork me on GitHub""></a>
","@@ -41,8 +41,8 @@ def hello():
   <h2>Interested?</h2>
   <ul>
     <li><a href=docs/>Read the documentation</a>
-    <li><a href=http://github.com/mitsuhiko/flask>fork it on github</a>
-    <li><a href=http://pypi.python.org/pypi/Flask>download it from PyPI</a>
+    <li><a href=http://github.com/mitsuhiko/flask>Fork it on github</a>
+    <li><a href=http://pypi.python.org/pypi/Flask>Download it from PyPI</a>
   </ul>
   <h2>Contribute</h2>
   <p>Found a bug? Have a good idea for improving Flask? Head over to
",add a few more examples to the example,add a few more examples to the example,add a few more examples to the example,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
5310fc38227b1907cb541f4a30ea8dfef46c2e19,"Session falls back to a dummy object now if secret_key is missing.

This makes it possible to still read-only access the empty session but
requires the secret key to be set for write access.  The error message
raised explains that.  This closes #10.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from threading import local
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, cached_property, \
     SharedDataMiddleware
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail



class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        reqctx = _request_ctx_stack.top
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -68,6 +68,22 @@ class _RequestGlobals(object):
     pass
 
 
+class _NullSession(SecureCookie):
+    """"""Class used to generate nicer error messages if sessions are not
+    available.  Will still allow read-only access to the empty session
+    but fail on setting.
+    """"""
+
+    def _fail(self, *args, **kwargs):
+        raise RuntimeError('the session is unavailable because no secret '
+                           'key was set.  Set the secret_key on the '
+                           'application to something unique and secret')
+    __setitem__ = __delitem__ = clear = pop = popitem = \
+        update = setdefault = _fail
+    del _fail
+
+
+
 class _RequestContext(object):
     """"""The request context contains all request relevant information.  It is
     created at the beginning of the request and pushed to the
@@ -80,6 +96,8 @@ class _RequestContext(object):
         self.url_adapter = app.url_map.bind_to_environ(environ)
         self.request = app.request_class(environ)
         self.session = app.open_session(self.request)
+        if self.session is None:
+            self.session = _NullSession()
         self.g = _RequestGlobals()
         self.flashes = None
 
@@ -384,8 +402,7 @@ class Flask(object):
                         object)
         :param response: an instance of :attr:`response_class`
         """"""
-        if session is not None:
-            session.save_cookie(response, self.session_cookie_name)
+        session.save_cookie(response, self.session_cookie_name)
 
     def add_url_rule(self, rule, endpoint, **options):
         """"""Connects a URL rule.  Works exactly like the :meth:`route`
@@ -603,7 +620,7 @@ class Flask(object):
                  instance of :attr:`response_class`.
         """"""
         session = _request_ctx_stack.top.session
-        if session is not None:
+        if not isinstance(session, _NullSession):
             self.save_session(session, response)
         for handler in self.after_request_funcs:
             response = handler(response)
",add more info about the routes,add more info about the routes,add more info about the routes,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
5310fc38227b1907cb541f4a30ea8dfef46c2e19,"Session falls back to a dummy object now if secret_key is missing.

This makes it possible to still read-only access the empty session but
requires the secret key to be set for write access.  The error message
raised explains that.  This closes #10.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionality(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class Templating(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]


if __name__ == '__main__':
    unittest.main()
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionality(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class Templating(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]


if __name__ == '__main__':
    unittest.main()
","@@ -72,6 +72,20 @@ class BasicFunctionality(unittest.TestCase):
         assert c.post('/set', data={'value': '42'}).data == 'value set'
         assert c.get('/get').data == '42'
 
+    def test_missing_session(self):
+        app = flask.Flask(__name__)
+        def expect_exception(f, *args, **kwargs):
+            try:
+                f(*args, **kwargs)
+            except RuntimeError, e:
+                assert e.args and 'session is unavailable' in e.args[0]
+            else:
+                assert False, 'expected exception'
+        with app.test_request_context():
+            assert flask.session.get('missing_key') is None
+            expect_exception(flask.session.__setitem__, 'foo', 42)
+            expect_exception(flask.session.pop, 'foo')
+
     def test_request_processing(self):
         app = flask.Flask(__name__)
         evts = []
",add tests for context context binding,add tests for context context binding,add tests for context context binding,llm_rectified,0.0,6,False,41.33783424823284,0,55,0,188,0,-41.33783424823284,-55,-188
42dd94b7565052120423dbd86a5ab0f96938f8cc,Fixed title.,404.html,"<!doctype html>
<title>Awwww.  What you searched cannot be found</title>
<style type=text/css>
body, html {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  background: url(/ship.png) no-repeat center right;
}

body:after {
  content: """";
  display: block;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 30px;
  background: url(/mask.png) repeat-y left;
}

a { color: #004B6B; }
a:hover { color: #6D4100; }

h1 {
  font-family: 'Garamond', 'Georgia', serif;
  font-weight: normal;
  color: #222;
  font-size: 40px;
  padding: 50px 0 10px 50px;
  margin: 0;
}

p {
  font-family: 'Georgia', serif;
  color: #000;
  font-size: 20px;
  padding: 10px 0 0 90px;
  margin: 0;
  width: 360px;
}
</style>
<h1>Chapter 404: The Lost Page</h1>
<p>A careful and diligent search has been made for the desired page, but it just cannot be found.
<p>And so they returned to <a href=/>familiar waters</a>.
","<!doctype html>
<title>Chapter 404: The Lost Page</title>
<style type=text/css>
body, html {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  background: url(/ship.png) no-repeat center right;
}

body:after {
  content: """";
  display: block;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 30px;
  background: url(/mask.png) repeat-y left;
}

a { color: #004B6B; }
a:hover { color: #6D4100; }

h1 {
  font-family: 'Garamond', 'Georgia', serif;
  font-weight: normal;
  color: #222;
  font-size: 40px;
  padding: 50px 0 10px 50px;
  margin: 0;
}

p {
  font-family: 'Georgia', serif;
  color: #000;
  font-size: 20px;
  padding: 10px 0 0 90px;
  margin: 0;
  width: 360px;
}
</style>
<h1>Chapter 404: The Lost Page</h1>
<p>A careful and diligent search has been made for the desired page, but it just cannot be found.
<p>And so they returned to <a href=/>familiar waters</a>.
","@@ -1,5 +1,5 @@
 <!doctype html>
-<title>Awwww.  What you searched cannot be found</title>
+<title>Chapter 404: The Lost Page</title>
 <style type=text/css>
 body, html {
   height: 100%;
",add missing style to the 404 page,add missing style to the 404 page,add missing style to the 404 page,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
42a46ed09b745c0560de354c0cb236295000f296,Fixed homepage links,index.html,"<!doctype html>
<title>Flask (A Python Microframework)</title>
<meta charset=utf-8>
<style type=text/css>
  body    { font-family: 'Georgia', serif; font-size: 17px; color: #000; }
  a       { color: #004B6B; }
  a:hover { color: #6D4100; }
  .box    { width: 540px; margin: 40px auto; }
  h1, h2  { font-family: 'Garamond', 'Georgia', serif; font-weight: normal; }
  h1      { margin: 0 0 30px 0; background: url(logo.png) no-repeat center; height: 165px; }
  h2      { font-size: 28px; margin: 15px 0 5px 0; }
  code,
  pre     { font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono',
          monospace; font-size: 15px; background: #eee; }
  pre     { padding: 7px 30px; margin: 15px -30px; line-height: 1.3; }
  .ig     { color: #888; }
  p       { line-height: 1.4; }
  ul      { margin: 15px 0 15px 0; padding: 0; list-style: none; }
  ul li:before { content: ""\00BB \0020""; color: #888; position: absolute; margin-left: -19px; }
  h1 span, p.tagline { display: none; }
  blockquote { margin: 0; font-style: italic; color: #444; }
  .footer { font-size: 13px; color: #888; text-align: right; margin-top: 25px; }
</style>
<div class=box>
  <h1><span>Flask</span></h1>
  <p class=tagline>because sometimes a pocket knife is not enough
  <blockquote>
    Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.
    And before you ask: It's <a href=http://github.com/mitsuhiko/flask/blob/master/LICENSE>BSD licensed</a>!
  </blockquote>
  <h2>Flask is Fun</h2>
  <pre><span class=ig>from flask import Flask
app = Flask(__name__)</span>

@app.route(""/"")
def hello():
    return ""Hello World!""

<span class=ig>if __name__ == ""__main__"":
    app.run()</span></pre>
  <h2>And Easy to Setup</h2>
  <pre><span class=ig>$ </span>easy_install Flask
<span class=ig>$ </span>python hello.py
<span class=ig> * Running on http://localhost:5000/</span></pre>
  <h2>Interested?</h2>
  <ul>
    <li><a href=docs/>Read the documentation</a>
    <li><a href=http://github.com/mitsuhiko/flask>Fork it on github</a>
    <li><a href=http://pypi.python.org/pypi/Flask>Download it from PyPI</a>
  </ul>
  <h2>What’s in the Box?</h2>
  <ul>
    <li>built in development server and <a href=docs/quickstart.html#debug-mode>debugger</a>
    <li>integrated support for <a href=docs/testing.html>unittesting support</a>
    <li>RESTful <a href=docs/quickstart.html#routing>request dispatching</a>
    <li>uses <a href=http://jinja.pocoo.org/2/documentation/templates>Jinja2 templating</a>
    <li>support for <a href=docs/quickstart.html#sessions>secure cookies</a> (client side sessions)
    <li>100% <a href=http://www.python.org/dev/peps/pep-0333/>WSGI 1.0</a> compliant
    <li>Unicode based
  </ul>
  <h2>What do Flask Apps look like?</h2>
  <p>
    If you are looking for some example code of applications written with Flask,
    have a look at the sources of the examples on github:
  <ul>
    <li><a href=http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/>flaskr</a>
      — a microblog
    <li><a href=http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/>minitwit</a>
      — a twitter clone
  </ul>
  <h2>Contribute</h2>
  <p>Found a bug? Have a good idea for improving Flask? Head over to
    <a href=http://github.com/mitsuhiko/flask>Flask's github</a> page and
    create a new ticket or fork.  If you just want to chat with fellow
    developers, go to <code>#pocoo</code> on irc.freenode.net.

  <p class=footer>&copy; Copyright 2010 by <a href=http://lucumr.pocoo.org/>Armin Ronacher</a>
</div>

<a href=""http://github.com/mitsuhiko/flask""><img style=""position: fixed; top: 0; right: 0; border: 0;""
  src=""http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"" alt=""Fork me on GitHub""></a>
","<!doctype html>
<title>Flask (A Python Microframework)</title>
<meta charset=utf-8>
<style type=text/css>
  body    { font-family: 'Georgia', serif; font-size: 17px; color: #000; }
  a       { color: #004B6B; }
  a:hover { color: #6D4100; }
  .box    { width: 540px; margin: 40px auto; }
  h1, h2  { font-family: 'Garamond', 'Georgia', serif; font-weight: normal; }
  h1      { margin: 0 0 30px 0; background: url(logo.png) no-repeat center; height: 165px; }
  h2      { font-size: 28px; margin: 15px 0 5px 0; }
  code,
  pre     { font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono',
          monospace; font-size: 15px; background: #eee; }
  pre     { padding: 7px 30px; margin: 15px -30px; line-height: 1.3; }
  .ig     { color: #888; }
  p       { line-height: 1.4; }
  ul      { margin: 15px 0 15px 0; padding: 0; list-style: none; }
  ul li:before { content: ""\00BB \0020""; color: #888; position: absolute; margin-left: -19px; }
  h1 span, p.tagline { display: none; }
  blockquote { margin: 0; font-style: italic; color: #444; }
  .footer { font-size: 13px; color: #888; text-align: right; margin-top: 25px; }
</style>
<div class=box>
  <h1><span>Flask</span></h1>
  <p class=tagline>because sometimes a pocket knife is not enough
  <blockquote>
    Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.
    And before you ask: It's <a href=http://github.com/mitsuhiko/flask/blob/master/LICENSE>BSD licensed</a>!
  </blockquote>
  <h2>Flask is Fun</h2>
  <pre><span class=ig>from flask import Flask
app = Flask(__name__)</span>

@app.route(""/"")
def hello():
    return ""Hello World!""

<span class=ig>if __name__ == ""__main__"":
    app.run()</span></pre>
  <h2>And Easy to Setup</h2>
  <pre><span class=ig>$ </span>easy_install Flask
<span class=ig>$ </span>python hello.py
<span class=ig> * Running on http://localhost:5000/</span></pre>
  <h2>Interested?</h2>
  <ul>
    <li><a href=docs/>Read the documentation</a>
    <li><a href=http://github.com/mitsuhiko/flask>Fork it on github</a>
    <li><a href=http://pypi.python.org/pypi/Flask>Download it from PyPI</a>
  </ul>
  <h2>What’s in the Box?</h2>
  <ul>
    <li>built in development server and <a href=docs/quickstart/#debug-mode>debugger</a>
    <li>integrated support for <a href=docs/testing/>unittesting support</a>
    <li>RESTful <a href=docs/quickstart/#routing>request dispatching</a>
    <li>uses <a href=http://jinja.pocoo.org/2/documentation/templates>Jinja2 templating</a>
    <li>support for <a href=docs/quickstart/#sessions>secure cookies</a> (client side sessions)
    <li>100% <a href=http://www.python.org/dev/peps/pep-0333/>WSGI 1.0</a> compliant
    <li>Unicode based
  </ul>
  <h2>What do Flask Apps look like?</h2>
  <p>
    If you are looking for some example code of applications written with Flask,
    have a look at the sources of the examples on github:
  <ul>
    <li><a href=http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/>flaskr</a>
      — a microblog
    <li><a href=http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/>minitwit</a>
      — a twitter clone
  </ul>
  <h2>Contribute</h2>
  <p>Found a bug? Have a good idea for improving Flask? Head over to
    <a href=http://github.com/mitsuhiko/flask>Flask's github</a> page and
    create a new ticket or fork.  If you just want to chat with fellow
    developers, go to <code>#pocoo</code> on irc.freenode.net.

  <p class=footer>&copy; Copyright 2010 by <a href=http://lucumr.pocoo.org/>Armin Ronacher</a>
</div>

<a href=""http://github.com/mitsuhiko/flask""><img style=""position: fixed; top: 0; right: 0; border: 0;""
  src=""http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"" alt=""Fork me on GitHub""></a>
","@@ -50,11 +50,11 @@ def hello():
   </ul>
   <h2>What’s in the Box?</h2>
   <ul>
-    <li>built in development server and <a href=docs/quickstart.html#debug-mode>debugger</a>
-    <li>integrated support for <a href=docs/testing.html>unittesting support</a>
-    <li>RESTful <a href=docs/quickstart.html#routing>request dispatching</a>
+    <li>built in development server and <a href=docs/quickstart/#debug-mode>debugger</a>
+    <li>integrated support for <a href=docs/testing/>unittesting support</a>
+    <li>RESTful <a href=docs/quickstart/#routing>request dispatching</a>
     <li>uses <a href=http://jinja.pocoo.org/2/documentation/templates>Jinja2 templating</a>
-    <li>support for <a href=docs/quickstart.html#sessions>secure cookies</a> (client side sessions)
+    <li>support for <a href=docs/quickstart/#sessions>secure cookies</a> (client side sessions)
     <li>100% <a href=http://www.python.org/dev/peps/pep-0333/>WSGI 1.0</a> compliant
     <li>Unicode based
   </ul>
",add a few more examples to the quickstart example,add a few more examples to the quickstart example,add a few more examples to the quickstart example,llm_rectified,0.0,9,False,0,0,0,0,0,0,0,0,0
ab5492418694b5cc14601a953084d61f47785ea4,Fixed a font name.,flasky.css_t,"/*
 * flasky.css_t
 * ~~~~~~~~~~~~
 *
 * Sphinx stylesheet -- flasky theme based on nature theme.
 *
 * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 *
 */
 
@import url(""basic.css"");
 
/* -- page layout ----------------------------------------------------------- */
 
body {
    font-family: 'Georgia', serif;
    font-size: 17px;
    background-color: #ddd;
    color: #000;
    margin: 0;
    padding: 0;
}

div.document {
    background: #fafafa;
}

div.documentwrapper {
    float: left;
    width: 100%;
}

div.bodywrapper {
    margin: 0 0 0 230px;
}

hr {
    border: 1px solid #B1B4B6;
}
 
div.body {
    background-color: #ffffff;
    color: #3E4349;
    padding: 0 30px 30px 30px;
    min-height: 34em;
}

img.floatingflask {
    padding: 0 0 10px 10px;
    float: right;
}
 
div.footer {
    position: absolute;
    right: 0;
    margin-top: -70px;
    text-align: right;
    color: #888;
    padding: 10px;
    font-size: 14px;
}
 
div.footer a {
    color: #888;
    text-decoration: underline;
}
 
div.related {
    line-height: 32px;
    color: #888;
}

div.related ul {
    padding: 0 0 0 10px;
}
 
div.related a {
    color: #444;
}
 
div.sphinxsidebar {
    font-size: 14px;
    line-height: 1.5;
}

div.sphinxsidebarwrapper {
    padding: 0 20px;
}

div.sphinxsidebarwrapper p.logo {
    padding: 20px 0 10px 0;
    margin: 0;
    text-align: center;
}
 
div.sphinxsidebar h3,
div.sphinxsidebar h4 {
    font-family: 'Garamond', 'Georgia', serif;
    color: #222;
    font-size: 24px;
    font-weight: normal;
    margin: 20px 0 5px 0;
    padding: 0;
}

div.sphinxsidebar h4 {
    font-size: 20px;
}
 
div.sphinxsidebar h3 a {
    color: #444;
}
 
div.sphinxsidebar p {
    color: #555;
    margin: 10px 0;
}
 
div.sphinxsidebar ul {
    margin: 10px 0;
    padding: 0;
    color: #000;
}
 
div.sphinxsidebar a {
    color: #444;
    text-decoration: none;
}

div.sphinxsidebar a:hover {
    text-decoration: underline;
}
 
div.sphinxsidebar input {
    border: 1px solid #ccc;
    font-family: 'Georgia', serif;
    font-size: 1em;
}
 
/* -- body styles ----------------------------------------------------------- */
 
a {
    color: #004B6B;
    text-decoration: underline;
}
 
a:hover {
    color: #6D4100;
    text-decoration: underline;
}

div.body {
    padding-bottom: 40px; /* saved for footer */
}
 
div.body h1,
div.body h2,
div.body h3,
div.body h4,
div.body h5,
div.body h6 {
    font-family: 'Garamond', 'Georiga', serif;
    font-weight: normal;
    margin: 30px 0px 10px 0px;
    padding: 0;
}
 
div.body h1 { margin-top: 0; padding-top: 20px; font-size: 240%; }
div.body h2 { font-size: 180%; }
div.body h3 { font-size: 150%; }
div.body h4 { font-size: 130%; }
div.body h5 { font-size: 100%; }
div.body h6 { font-size: 100%; }
 
a.headerlink {
    color: white;
    padding: 0 4px;
    text-decoration: none;
}
 
a.headerlink:hover {
    color: #444;
    background: #eaeaea;
}
 
div.body p, div.body dd, div.body li {
    line-height: 1.4em;
}

div.admonition {
    background: #fafafa;
    margin: 20px -30px;
    padding: 10px 30px;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
}

div.admonition p.admonition-title {
    font-family: 'Garamond', 'Georiga', serif;
    font-weight: normal;
    font-size: 24px;
    margin: 0 0 10px 0;
    padding: 0;
    line-height: 1;
}

div.admonition p.last {
    margin-bottom: 0;
}

div.highlight{
    background-color: white;
}

dt:target, .highlight {
    background: #FAF3E8;
}

div.note {
    background-color: #eee;
    border: 1px solid #ccc;
}
 
div.seealso {
    background-color: #ffc;
    border: 1px solid #ff6;
}
 
div.topic {
    background-color: #eee;
}
 
div.warning {
    background-color: #ffe4e4;
    border: 1px solid #f66;
}
 
p.admonition-title {
    display: inline;
}
 
p.admonition-title:after {
    content: "":"";
}

pre, tt {
    font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
    font-size: 0.9em;
}

img.screenshot {
}

tt.descname, tt.descclassname {
    font-size: 0.95em;
}

tt.descname {
    padding-right: 0.08em;
}

img.screenshot {
    -moz-box-shadow: 2px 2px 4px #eee;
    -webkit-box-shadow: 2px 2px 4px #eee;
    box-shadow: 2px 2px 4px #eee;
}

table.docutils {
    border: 1px solid #888;
    -moz-box-shadow: 2px 2px 4px #eee;
    -webkit-box-shadow: 2px 2px 4px #eee;
    box-shadow: 2px 2px 4px #eee;
}

table.docutils td, table.docutils th {
    border: 1px solid #888;
    padding: 0.25em 0.7em;
}

table.field-list, table.footnote {
    border: none;
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
}

table.footnote {
    margin: 15px 0;
    width: 100%;
    border: 1px solid #eee;
}

table.field-list th {
    padding: 0 0.8em 0 0;
}

table.field-list td {
    padding: 0;
}

table.footnote td {
    padding: 0.5em;
}

dl {
    margin: 0;
    padding: 0;
}

dl dd {
    margin-left: 30px;
}
 
pre {
    background: #eee;
    padding: 7px 30px;
    margin: 15px -30px;
    line-height: 1.3em;
}

dl pre {
    margin-left: -60px;
    padding-left: 60px;
}

dl dl pre {
    margin-left: -90px;
    padding-left: 90px;
}
 
tt {
    background-color: #ecf0f3;
    color: #222;
    /* padding: 1px 2px; */
}

tt.xref, a tt {
    background-color: #FBFBFB;
}

a:hover tt {
    background: #EEE;
}
","/*
 * flasky.css_t
 * ~~~~~~~~~~~~
 *
 * Sphinx stylesheet -- flasky theme based on nature theme.
 *
 * :copyright: Copyright 2007-2010 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 *
 */
 
@import url(""basic.css"");
 
/* -- page layout ----------------------------------------------------------- */
 
body {
    font-family: 'Georgia', serif;
    font-size: 17px;
    background-color: #ddd;
    color: #000;
    margin: 0;
    padding: 0;
}

div.document {
    background: #fafafa;
}

div.documentwrapper {
    float: left;
    width: 100%;
}

div.bodywrapper {
    margin: 0 0 0 230px;
}

hr {
    border: 1px solid #B1B4B6;
}
 
div.body {
    background-color: #ffffff;
    color: #3E4349;
    padding: 0 30px 30px 30px;
    min-height: 34em;
}

img.floatingflask {
    padding: 0 0 10px 10px;
    float: right;
}
 
div.footer {
    position: absolute;
    right: 0;
    margin-top: -70px;
    text-align: right;
    color: #888;
    padding: 10px;
    font-size: 14px;
}
 
div.footer a {
    color: #888;
    text-decoration: underline;
}
 
div.related {
    line-height: 32px;
    color: #888;
}

div.related ul {
    padding: 0 0 0 10px;
}
 
div.related a {
    color: #444;
}
 
div.sphinxsidebar {
    font-size: 14px;
    line-height: 1.5;
}

div.sphinxsidebarwrapper {
    padding: 0 20px;
}

div.sphinxsidebarwrapper p.logo {
    padding: 20px 0 10px 0;
    margin: 0;
    text-align: center;
}
 
div.sphinxsidebar h3,
div.sphinxsidebar h4 {
    font-family: 'Garamond', 'Georgia', serif;
    color: #222;
    font-size: 24px;
    font-weight: normal;
    margin: 20px 0 5px 0;
    padding: 0;
}

div.sphinxsidebar h4 {
    font-size: 20px;
}
 
div.sphinxsidebar h3 a {
    color: #444;
}
 
div.sphinxsidebar p {
    color: #555;
    margin: 10px 0;
}
 
div.sphinxsidebar ul {
    margin: 10px 0;
    padding: 0;
    color: #000;
}
 
div.sphinxsidebar a {
    color: #444;
    text-decoration: none;
}

div.sphinxsidebar a:hover {
    text-decoration: underline;
}
 
div.sphinxsidebar input {
    border: 1px solid #ccc;
    font-family: 'Georgia', serif;
    font-size: 1em;
}
 
/* -- body styles ----------------------------------------------------------- */
 
a {
    color: #004B6B;
    text-decoration: underline;
}
 
a:hover {
    color: #6D4100;
    text-decoration: underline;
}

div.body {
    padding-bottom: 40px; /* saved for footer */
}
 
div.body h1,
div.body h2,
div.body h3,
div.body h4,
div.body h5,
div.body h6 {
    font-family: 'Garamond', 'Georgia', serif;
    font-weight: normal;
    margin: 30px 0px 10px 0px;
    padding: 0;
}
 
div.body h1 { margin-top: 0; padding-top: 20px; font-size: 240%; }
div.body h2 { font-size: 180%; }
div.body h3 { font-size: 150%; }
div.body h4 { font-size: 130%; }
div.body h5 { font-size: 100%; }
div.body h6 { font-size: 100%; }
 
a.headerlink {
    color: white;
    padding: 0 4px;
    text-decoration: none;
}
 
a.headerlink:hover {
    color: #444;
    background: #eaeaea;
}
 
div.body p, div.body dd, div.body li {
    line-height: 1.4em;
}

div.admonition {
    background: #fafafa;
    margin: 20px -30px;
    padding: 10px 30px;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
}

div.admonition p.admonition-title {
    font-family: 'Garamond', 'Georgia', serif;
    font-weight: normal;
    font-size: 24px;
    margin: 0 0 10px 0;
    padding: 0;
    line-height: 1;
}

div.admonition p.last {
    margin-bottom: 0;
}

div.highlight{
    background-color: white;
}

dt:target, .highlight {
    background: #FAF3E8;
}

div.note {
    background-color: #eee;
    border: 1px solid #ccc;
}
 
div.seealso {
    background-color: #ffc;
    border: 1px solid #ff6;
}
 
div.topic {
    background-color: #eee;
}
 
div.warning {
    background-color: #ffe4e4;
    border: 1px solid #f66;
}
 
p.admonition-title {
    display: inline;
}
 
p.admonition-title:after {
    content: "":"";
}

pre, tt {
    font-family: 'Consolas', 'Menlo', 'Deja Vu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
    font-size: 0.9em;
}

img.screenshot {
}

tt.descname, tt.descclassname {
    font-size: 0.95em;
}

tt.descname {
    padding-right: 0.08em;
}

img.screenshot {
    -moz-box-shadow: 2px 2px 4px #eee;
    -webkit-box-shadow: 2px 2px 4px #eee;
    box-shadow: 2px 2px 4px #eee;
}

table.docutils {
    border: 1px solid #888;
    -moz-box-shadow: 2px 2px 4px #eee;
    -webkit-box-shadow: 2px 2px 4px #eee;
    box-shadow: 2px 2px 4px #eee;
}

table.docutils td, table.docutils th {
    border: 1px solid #888;
    padding: 0.25em 0.7em;
}

table.field-list, table.footnote {
    border: none;
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
}

table.footnote {
    margin: 15px 0;
    width: 100%;
    border: 1px solid #eee;
}

table.field-list th {
    padding: 0 0.8em 0 0;
}

table.field-list td {
    padding: 0;
}

table.footnote td {
    padding: 0.5em;
}

dl {
    margin: 0;
    padding: 0;
}

dl dd {
    margin-left: 30px;
}
 
pre {
    background: #eee;
    padding: 7px 30px;
    margin: 15px -30px;
    line-height: 1.3em;
}

dl pre {
    margin-left: -60px;
    padding-left: 60px;
}

dl dl pre {
    margin-left: -90px;
    padding-left: 90px;
}
 
tt {
    background-color: #ecf0f3;
    color: #222;
    /* padding: 1px 2px; */
}

tt.xref, a tt {
    background-color: #FBFBFB;
}

a:hover tt {
    background: #EEE;
}
","@@ -160,7 +160,7 @@ div.body h3,
 div.body h4,
 div.body h5,
 div.body h6 {
-    font-family: 'Garamond', 'Georiga', serif;
+    font-family: 'Garamond', 'Georgia', serif;
     font-weight: normal;
     margin: 30px 0px 10px 0px;
     padding: 0;
@@ -197,7 +197,7 @@ div.admonition {
 }
 
 div.admonition p.admonition-title {
-    font-family: 'Garamond', 'Georiga', serif;
+    font-family: 'Garamond', 'Georgia', serif;
     font-weight: normal;
     font-size: 24px;
     margin: 0 0 10px 0;
",add missing styles to the page layout,add missing styles to the page layout,add missing styles to the page layout,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
73a47a0db1a181bb305684115d3dacded0c5a58b,Removed unused stuff from minitwit and fixed a bug.,minitwit.py,"# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    offset = request.args.get('offset', type=int)
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followd = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followed = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","@@ -9,7 +9,6 @@
     :license: BSD, see LICENSE for more details.
 """"""
 from __future__ import with_statement
-import re
 import time
 import sqlite3
 from hashlib import md5
@@ -96,7 +95,6 @@ def timeline():
     """"""
     if not g.user:
         return redirect(url_for('public_timeline'))
-    offset = request.args.get('offset', type=int)
     return render_template('timeline.html', messages=query_db('''
         select message.*, user.* from message, user
         where message.author_id = user.user_id and (
@@ -123,7 +121,7 @@ def user_timeline(username):
                             [username], one=True)
     if profile_user is None:
         abort(404)
-    followd = False
+    followed = False
     if g.user:
         followed = query_db('''select 1 from follower where
             follower.who_id = ? and follower.whom_id = ?''',
",add minitwit_test.py,,,fallback_short,1.0,0,False,48.73457184659348,48.945650333297216,44,44,250,248,0.21107848670373386,0,-2
56675b3bade603a458d01443bda8070ca0489005,Fixed indentation of an example.,wtforms.rst,"Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is WTForms which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [Required(),
            EqualTo('confirm', mesage='Passwords must match')])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
     {% if field.errors %}
       <ul class=""errors"">
       {% for error in field.errors %}
         <li>{{ error }}</li>
       {% endfor %}
       </ul>
     {% endif %}
     </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""POST"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms website: http://wtforms.simplecodes.com/
","Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is WTForms which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [Required(),
            EqualTo('confirm', mesage='Passwords must match')])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""POST"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms website: http://wtforms.simplecodes.com/
","@@ -73,14 +73,12 @@ Here an example `_formhelpers.html` template with such a macro:
     {% macro render_field(field) %}
       <dt>{{ field.label }}
       <dd>{{ field(**kwargs)|safe }}
-     {% if field.errors %}
-       <ul class=""errors"">
-       {% for error in field.errors %}
-         <li>{{ error }}</li>
-       {% endfor %}
-       </ul>
-     {% endif %}
-     </dd>
+      {% if field.errors %}
+        <ul class=""errors"">
+        {% for error in field.errors %}<li>{{ error }}{% endfor %}
+        </ul>
+      {% endif %}
+      </dd>
     {% endmacro %}
 
 This macro accepts a couple of keyword arguments that are forwarded to
",add examples for formhelper,add examples for formhelper,add examples for formhelper,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
ade490514dd6d83adc7610f69f9c4cd68df47110,"Fixed a security problem caused by changed simplejson semantics.

Notice: this was never in a release version of Flask.",api.rst,".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `url`         ``http://www.example.com/myapplication/page.html``
      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
      `root_url`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g
   
   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
",".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `url`         ``http://www.example.com/myapplication/page.html``
      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
      `root_url`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g
   
   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

    Note that the ``|tojson`` filter escapes forward slashes properly.

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
","@@ -250,6 +250,8 @@ Returning JSON
             doSomethingWith({{ user.username|tojson|safe }});
         </script>
 
+    Note that the ``|tojson`` filter escapes forward slashes properly.
+
 Template Rendering
 ------------------
 
",add docs for request and requestdata filter,add docs for request and requestdata filter,add docs for request and requestdata filter,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
ade490514dd6d83adc7610f69f9c4cd68df47110,"Fixed a security problem caused by changed simplejson semantics.

Notice: this was never in a release version of Flask.",jquery.rst,"AJAX with jQuery
================

`jQuery`_ is a small JavaScript library commonly used to simplify working
with the DOM and JavaScript in general.  It is the perfect tool to make
web applications more dynamic by exchanging JSON between server and
client.

JSON itself is a very lightweight transport format, very similar to how
Python primitives (numbers, strings, dicts and lists) look like which is
widely supported and very easy to parse.  It became popular a few years
ago and quickly replaced XML as transport format in web applications.

If you have Python 2.6 JSON will work out of the box, in Python 2.5 you
will have to install the `simplejson`_ library from PyPI.

.. _jQuery: http://jquery.com/
.. _simplejson: http://pypi.python.org/pypi/simplejson

Loading jQuery
--------------

In order to use jQuery, you have to download it first and place it in the
static folder of your application and then ensure it's loaded.  Ideally
you have a layout template that is used for all pages where you just have
to add a script statement to your `head` to load jQuery:

.. sourcecode:: html

   <script type=text/javascript src=""{{
     url_for('static', filename='jquery.js') }}""></script>

Another method is using Google's `AJAX Libraries API
<http://code.google.com/apis/ajaxlibs/documentation/>`_ to load jQuery:

.. sourcecode:: html

    <script type=text/javascript
      src=""http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js""></script>

In this case you don't have to put jQuery into your static folder, it will
instead be loaded from Google directly.  This has the advantage that your
website will probably load faster for users if they were to at least one
other website before using the same jQuery version from Google because it
will already be in the browser cache.  Downside is that if you don't have
network connectivity during development jQuery will not load.

Where is My Site?
-----------------

Do you know where your application is?  If you are developing the answer
is quite simple: it's on localhost port something and directly on the root
of that server.  But what if you later decide to move your application to
a different location?  For example to ``http://example.com/myapp``?  On
the server side this never was a problem because we were using the handy
:func:`~flask.url_for` function that did could answer that question for
us, but if we are using jQuery we should better not hardcode the path to
the application but make that dynamic, so how can we do that?

A simple method would be to add a script tag to our page that sets a
global variable to the prefix to the root of the application.  Something
like this:

.. sourcecode:: html+jinja

   <script type=text/javascript>
     $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
   </script>

The ``|safe`` is necessary so that Jinja does not escape the JSON encoded
string with HTML rules.  Usually this would be necessary, but we are
inside a `script` block here where different rules apply.

.. admonition:: Information for Pros

   In HTML the `script` tag is declared `CDATA` which means that entities
   will not be parsed.  Everything until ``</script>`` is handled as script.
   This also means that there must never be any ``</`` between the script
   tags.  ``|tojson`` is kindly enough to do the right thing here and
   escape backslashes for you.


JSON View Functions
-------------------

Now let's create a server side function that accepts two URL arguments of
numbers which should be added together and then sent back to the
application in a JSON object.  This is a really ridiculous example and is
something you usually would do on the client side alone, but a simple
example that shows how you would use jQuer and Flask nonetheless::

    from flask import Flask, jsonify, render_template, request
    app = Flask(__name__)

    @app.route('/_add_numbers')
    def add_numbers():
        a = request.args.get('a', 0, type=int)
        b = request.args.get('b', 0, type=int)
        return jsonify(result=a + b)

    @app.route('/')
    def index():
        return render_template('index.html')

As you can see I also added an `index` method here that renders a
template.  This template will load jQuery as above and have a little form
we can add two numbers and a link to trigger the function on the server
side.

The HTML
--------

You index.html template either has to extend a `layout.html` template with
jQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.
Here the HTML code needed for our little application (`index.html`).
Notice that we also drop the script directly into the HTML here.  It is
usually a better idea to have that in a separate script file:

.. sourcecode:: html

    <script type=text/javascript>
      $(function() {
        $('a#calculate').bind('click', function() {
          $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
            a: $('input[name=""a""]').val(),
            b: $('input[name=""b""]').val()
          }, function(data) {
            $(""#result"").text(data.result);
          });
          return false;
        });
      });
    </script>
    <h1>jQuery Example</h1>
    <p><input type=text size=5 name=a> +
       <input type=text size=5 name=b> =
       <span id=result>?</span>
    <p><a href=# id=calculate>calculate server side</a>

I won't got into detail here about how jQuery works, just a very quick
explanation of the little bit of code above:

1. ``$(function() { ... })`` specifies code that should run once the
   browser is done loading the basic parts of the page.
2. ``#('selector')`` selects an element and lets you operate on it.
3. ``element.bind('event', func)`` specifies a function that should run
   when the user clicked on the element.  If that function returns
   `false`, the default behaviour will not kick in (in this case, navigate
   to the `#` URL).
4. ``$.getJSON(url, data, func)`` sends a `GET` request to `url` and will
   send the contents of the `data` object as query parameters.  Once the
   data arrived, it will call the given function with the return value as
   argument.  Note that we can use the `$SCRIPT_ROOT` variable here that
   we set earlier.

If you don't get the whole picture, download the `sourcecode
for this example
<http://github.com/mitsuhiko/flask/tree/master/examples/jqueryexample>`_
from github.
","AJAX with jQuery
================

`jQuery`_ is a small JavaScript library commonly used to simplify working
with the DOM and JavaScript in general.  It is the perfect tool to make
web applications more dynamic by exchanging JSON between server and
client.

JSON itself is a very lightweight transport format, very similar to how
Python primitives (numbers, strings, dicts and lists) look like which is
widely supported and very easy to parse.  It became popular a few years
ago and quickly replaced XML as transport format in web applications.

If you have Python 2.6 JSON will work out of the box, in Python 2.5 you
will have to install the `simplejson`_ library from PyPI.

.. _jQuery: http://jquery.com/
.. _simplejson: http://pypi.python.org/pypi/simplejson

Loading jQuery
--------------

In order to use jQuery, you have to download it first and place it in the
static folder of your application and then ensure it's loaded.  Ideally
you have a layout template that is used for all pages where you just have
to add a script statement to your `head` to load jQuery:

.. sourcecode:: html

   <script type=text/javascript src=""{{
     url_for('static', filename='jquery.js') }}""></script>

Another method is using Google's `AJAX Libraries API
<http://code.google.com/apis/ajaxlibs/documentation/>`_ to load jQuery:

.. sourcecode:: html

    <script type=text/javascript
      src=""http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js""></script>

In this case you don't have to put jQuery into your static folder, it will
instead be loaded from Google directly.  This has the advantage that your
website will probably load faster for users if they were to at least one
other website before using the same jQuery version from Google because it
will already be in the browser cache.  Downside is that if you don't have
network connectivity during development jQuery will not load.

Where is My Site?
-----------------

Do you know where your application is?  If you are developing the answer
is quite simple: it's on localhost port something and directly on the root
of that server.  But what if you later decide to move your application to
a different location?  For example to ``http://example.com/myapp``?  On
the server side this never was a problem because we were using the handy
:func:`~flask.url_for` function that did could answer that question for
us, but if we are using jQuery we should better not hardcode the path to
the application but make that dynamic, so how can we do that?

A simple method would be to add a script tag to our page that sets a
global variable to the prefix to the root of the application.  Something
like this:

.. sourcecode:: html+jinja

   <script type=text/javascript>
     $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
   </script>

The ``|safe`` is necessary so that Jinja does not escape the JSON encoded
string with HTML rules.  Usually this would be necessary, but we are
inside a `script` block here where different rules apply.

.. admonition:: Information for Pros

   In HTML the `script` tag is declared `CDATA` which means that entities
   will not be parsed.  Everything until ``</script>`` is handled as script.
   This also means that there must never be any ``</`` between the script
   tags.  ``|tojson`` is kindly enough to do the right thing here and
   escape slashes for you (``{{ ""</script>""|tojson|safe }`` is rendered as
   ``""<\/script>""``).


JSON View Functions
-------------------

Now let's create a server side function that accepts two URL arguments of
numbers which should be added together and then sent back to the
application in a JSON object.  This is a really ridiculous example and is
something you usually would do on the client side alone, but a simple
example that shows how you would use jQuer and Flask nonetheless::

    from flask import Flask, jsonify, render_template, request
    app = Flask(__name__)

    @app.route('/_add_numbers')
    def add_numbers():
        a = request.args.get('a', 0, type=int)
        b = request.args.get('b', 0, type=int)
        return jsonify(result=a + b)

    @app.route('/')
    def index():
        return render_template('index.html')

As you can see I also added an `index` method here that renders a
template.  This template will load jQuery as above and have a little form
we can add two numbers and a link to trigger the function on the server
side.

The HTML
--------

You index.html template either has to extend a `layout.html` template with
jQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.
Here the HTML code needed for our little application (`index.html`).
Notice that we also drop the script directly into the HTML here.  It is
usually a better idea to have that in a separate script file:

.. sourcecode:: html

    <script type=text/javascript>
      $(function() {
        $('a#calculate').bind('click', function() {
          $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
            a: $('input[name=""a""]').val(),
            b: $('input[name=""b""]').val()
          }, function(data) {
            $(""#result"").text(data.result);
          });
          return false;
        });
      });
    </script>
    <h1>jQuery Example</h1>
    <p><input type=text size=5 name=a> +
       <input type=text size=5 name=b> =
       <span id=result>?</span>
    <p><a href=# id=calculate>calculate server side</a>

I won't got into detail here about how jQuery works, just a very quick
explanation of the little bit of code above:

1. ``$(function() { ... })`` specifies code that should run once the
   browser is done loading the basic parts of the page.
2. ``#('selector')`` selects an element and lets you operate on it.
3. ``element.bind('event', func)`` specifies a function that should run
   when the user clicked on the element.  If that function returns
   `false`, the default behaviour will not kick in (in this case, navigate
   to the `#` URL).
4. ``$.getJSON(url, data, func)`` sends a `GET` request to `url` and will
   send the contents of the `data` object as query parameters.  Once the
   data arrived, it will call the given function with the return value as
   argument.  Note that we can use the `$SCRIPT_ROOT` variable here that
   we set earlier.

If you don't get the whole picture, download the `sourcecode
for this example
<http://github.com/mitsuhiko/flask/tree/master/examples/jqueryexample>`_
from github.
","@@ -77,7 +77,8 @@ inside a `script` block here where different rules apply.
    will not be parsed.  Everything until ``</script>`` is handled as script.
    This also means that there must never be any ``</`` between the script
    tags.  ``|tojson`` is kindly enough to do the right thing here and
-   escape backslashes for you.
+   escape slashes for you (``{{ ""</script>""|tojson|safe }`` is rendered as
+   ``""<\/script>""``).
 
 
 JSON View Functions
",add a note about the syntax of the script block,add a note about the syntax of the script block,add a note about the syntax of the script block,llm_rectified,0.0,10,False,0,0,0,0,0,0,0,0,0
ade490514dd6d83adc7610f69f9c4cd68df47110,"Fixed a security problem caused by changed simplejson semantics.

Notice: this was never in a release version of Flask.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if not json_available:
            raise AttributeError('simplejson not available')
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        if json_available:
            self.jinja_env.filters['tojson'] = json.dumps

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if not json_available:
            raise AttributeError('simplejson not available')
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    return json.dumps(string, *args, **kwargs).replace('/', '\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        if json_available:
            self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -259,6 +259,11 @@ def _get_package_path(name):
         return os.getcwd()
 
 
+def _tojson_filter(string, *args, **kwargs):
+    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
+    return json.dumps(string, *args, **kwargs).replace('/', '\\/')
+
+
 class Flask(object):
     """"""The flask object implements a WSGI application and acts as the central
     object.  It is passed the name of the module or package of the
@@ -379,7 +384,7 @@ class Flask(object):
             get_flashed_messages=get_flashed_messages
         )
         if json_available:
-            self.jinja_env.filters['tojson'] = json.dumps
+            self.jinja_env.filters['tojson'] = _tojson_filter
 
     def create_jinja_loader(self):
         """"""Creates the Jinja loader.  By default just a package loader for
",add more info to the flask class,add more info to the flask class,add more info to the flask class,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
ade490514dd6d83adc7610f69f9c4cd68df47110,"Fixed a security problem caused by changed simplejson semantics.

Notice: this was never in a release version of Flask.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


if __name__ == '__main__':
    unittest.main()
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


if __name__ == '__main__':
    unittest.main()
","@@ -194,6 +194,12 @@ class JSONTestCase(unittest.TestCase):
                             content_type='application/json')
         assert rv.data == '3'
 
+    def test_template_escaping(self):
+        app = flask.Flask(__name__)
+        with app.test_request_context():
+            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
+            assert rv == '""<\\/script>""'
+
 
 class TemplatingTestCase(unittest.TestCase):
 
",add tests for flask-test-rest.py,add tests for flask-test-rest.py,add tests for flask-test-rest.py,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
3088a9371e065808fd0091741f62bc242bcab1f9,"Make it easier to associate a rule, endpoint and view_function
This resolves http://github.com/mitsuhiko/flask/issues/issue/11",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if not json_available:
            raise AttributeError('simplejson not available')
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    return json.dumps(string, *args, **kwargs).replace('/', '\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        if json_available:
            self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator but does not register the view function for the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('index', '/')
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if not json_available:
            raise AttributeError('simplejson not available')
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    return json.dumps(string, *args, **kwargs).replace('/', '\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(Rule(self.static_path + '/<filename>',
                                  build_only=True, endpoint='static'))
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        if json_available:
            self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)
            
         If the view_func is not provided you will need to connect the endpoint to a 
         view function like so:
            app.view_functions['index'] = index

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, **options)
            self.view_functions[f.__name__] = f
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -481,9 +481,9 @@ class Flask(object):
         """"""
         session.save_cookie(response, self.session_cookie_name)
 
-    def add_url_rule(self, rule, endpoint, **options):
+    def add_url_rule(self, rule, endpoint, view_func=None, **options):
         """"""Connects a URL rule.  Works exactly like the :meth:`route`
-        decorator but does not register the view function for the endpoint.
+        decorator. If a view_func is provided it will be registered with the endpoint.
 
         Basically this example::
 
@@ -495,19 +495,25 @@ class Flask(object):
 
             def index():
                 pass
-            app.add_url_rule('index', '/')
+            app.add_url_rule('/', 'index', index)
+            
+         If the view_func is not provided you will need to connect the endpoint to a 
+         view function like so:
             app.view_functions['index'] = index
 
         :param rule: the URL rule as string
         :param endpoint: the endpoint for the registered URL rule.  Flask
                          itself assumes the name of the view function as
                          endpoint
+        :param view_func: the function to call when servicing a request to the provided endpoint
         :param options: the options to be forwarded to the underlying
                         :class:`~werkzeug.routing.Rule` object
         """"""
         options['endpoint'] = endpoint
         options.setdefault('methods', ('GET',))
         self.url_map.add(Rule(rule, **options))
+        if view_func is not None:
+            self.view_functions[endpoint] = view_func
 
     def route(self, rule, **options):
         """"""A decorator that is used to register a view function for a
",add more documentation to flask.routing.route,add more documentation to flask.routing.route,add more documentation to flask.routing.route,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
3088a9371e065808fd0091741f62bc242bcab1f9,"Make it easier to associate a rule, endpoint and view_function
This resolves http://github.com/mitsuhiko/flask/issues/issue/11",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


if __name__ == '__main__':
    unittest.main()
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import flask
import unittest
import tempfile


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method
        
        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


if __name__ == '__main__':
    unittest.main()
","@@ -57,6 +57,30 @@ class BasicFunctionalityTestCase(unittest.TestCase):
         assert rv.status_code == 405
         assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']
 
+    def test_url_mapping(self):
+        app = flask.Flask(__name__)
+        def index():
+            return flask.request.method
+        def more():
+            return flask.request.method
+        
+        app.add_url_rule('/', 'index', index)
+        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])
+
+        c = app.test_client()
+        assert c.get('/').data == 'GET'
+        rv = c.post('/')
+        assert rv.status_code == 405
+        assert sorted(rv.allow) == ['GET', 'HEAD']
+        rv = c.head('/')
+        assert rv.status_code == 200
+        assert not rv.data # head truncates
+        assert c.post('/more').data == 'POST'
+        assert c.get('/more').data == 'GET'
+        rv = c.delete('/more')
+        assert rv.status_code == 405
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']
+
     def test_session(self):
         app = flask.Flask(__name__)
         app.secret_key = 'testkey'
",add test for context and url mapping,add test for context and url mapping,add test for context and url mapping,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
50a331307114a641d1d9447453f8fddc52fe680f,Fixed typo in form docs,wtforms.rst,"Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [Required(),
            EqualTo('confirm', mesage='Passwords must match')])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""POST"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [Required(),
            EqualTo('confirm', message='Passwords must match')])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""POST"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","@@ -23,7 +23,7 @@ This is an example form for a typical registration page::
         username = TextField('Username', [validators.Length(min=4, max=25)])
         email = TextField('Email Address', [validators.Length(min=6, max=35)])
         password = PasswordField('New Password', [Required(),
-            EqualTo('confirm', mesage='Passwords must match')])
+            EqualTo('confirm', message='Passwords must match')])
         confirm = PasswordField('Repeat Password')
         accept_tos = BooleanField('I accept the TOS', [validators.Required()])
 
",add examples for form registration,add examples for form registration,add examples for form registration,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
1404a85bc554f96bff5463e6eadb14662b945f2e,Fixed WTForms example.,wtforms.rst,"Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [Required(),
            EqualTo('confirm', message='Passwords must match')])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""post"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [validators.Required()])
        confirm = PasswordField('Repeat Password', [validators.EqualTo(
            'confirm', message='Passwords must match')])
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""post"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","@@ -22,9 +22,9 @@ This is an example form for a typical registration page::
     class RegistrationForm(Form):
         username = TextField('Username', [validators.Length(min=4, max=25)])
         email = TextField('Email Address', [validators.Length(min=6, max=35)])
-        password = PasswordField('New Password', [Required(),
-            EqualTo('confirm', message='Passwords must match')])
-        confirm = PasswordField('Repeat Password')
+        password = PasswordField('New Password', [validators.Required()])
+        confirm = PasswordField('Repeat Password', [validators.EqualTo(
+            'confirm', message='Passwords must match')])
         accept_tos = BooleanField('I accept the TOS', [validators.Required()])
 
 In the View
",add examples for form validation with wtf forms,add examples for form validation with wtf forms,add examples for form validation with wtf forms,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
3a1e51865786474c44a04c0d422515047dd27223,Fixed typo and added AUTHORS file and license text to docs.,AUTHORS,,"Flask is written and maintained by Armin Ronacher and
various contributors:

Development Lead
````````````````

- Armin Ronacher <armin.ronacher@active-4.com>

Patches and Suggestions
```````````````````````

- Chris Edgemon
- Chris Grindstaff
","@@ -0,0 +1,13 @@
+Flask is written and maintained by Armin Ronacher and
+various contributors:
+
+Development Lead
+````````````````
+
+- Armin Ronacher <armin.ronacher@active-4.com>
+
+Patches and Suggestions
+```````````````````````
+
+- Chris Edgemon
+- Chris Grindstaff
",add missing tags to the missing diff,add missing tags to the missing diff,add missing tags to the missing diff,llm_rectified,0.0,7,False,100.0,0,0,0,0,0,-100.0,0,0
3a1e51865786474c44a04c0d422515047dd27223,Fixed typo and added AUTHORS file and license text to docs.,LICENSE,"Copyright (c) 2010 by Armin Ronacher.

Some rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * The names of the contributors may not be used to endorse or
      promote products derived from this software without specific
      prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
","Copyright (c) 2010 by Armin Ronacher and contributors.  See AUTHORS
for more details.

Some rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following
  disclaimer in the documentation and/or other materials provided
  with the distribution.

* The names of the contributors may not be used to endorse or
  promote products derived from this software without specific
  prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
","@@ -1,4 +1,5 @@
-Copyright (c) 2010 by Armin Ronacher.
+Copyright (c) 2010 by Armin Ronacher and contributors.  See AUTHORS
+for more details.
 
 Some rights reserved.
 
@@ -6,17 +7,17 @@ Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:
 
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
 
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
+* Redistributions in binary form must reproduce the above
+  copyright notice, this list of conditions and the following
+  disclaimer in the documentation and/or other materials provided
+  with the distribution.
 
-    * The names of the contributors may not be used to endorse or
-      promote products derived from this software without specific
-      prior written permission.
+* The names of the contributors may not be used to endorse or
+  promote products derived from this software without specific
+  prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
",add missing docs to diff-base.js,add missing docs to diff-base.js,add missing docs to diff-base.js,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
3a1e51865786474c44a04c0d422515047dd27223,Fixed typo and added AUTHORS file and license text to docs.,index.rst,"Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :class: floatingflask

Welcome to Flask's documentation.  This documentation is divided in
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.
Besides the quickstart there is also a more detailed :ref:`tutorial` that
shows how to create a complete (albeit small) application with Flask.  If
you rather want to dive into all the internal parts of Flask, check out
the :ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

Flask also depends on two external libraries: the `Jinja2`_ template
engine and the `Werkzeug`_ WSGI toolkit.  both of which are not documented
here.  If you want to dive into their documentation check out the
following links:

-   `Jinja2 Documentation <http://jinja.pocoo.org/2/documentation/>`_
-   `Werkzeug Documentation <http://werkzeug.pocoo.org/documentation/>`_

.. _Jinja2: http://jinja.pocoo.org/2/
.. _Werkzeug: http://werkzeug.pocoo.org/

Textual Documentation
---------------------

This part of the documentation is written text and should give you an idea
how to work with Flask.  It's a series of step-by-step instructions for
web development.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   tutorial/index
   testing
   patterns/index
   deploying/index
   becomingbig
   design

Reference
---------

If you are looking for information on a specific function, class or
method, this part of the documentation is for you:

.. toctree::
   :maxdepth: 2

   api
","Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :class: floatingflask

Welcome to Flask's documentation.  This documentation is divided in
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.
Besides the quickstart there is also a more detailed :ref:`tutorial` that
shows how to create a complete (albeit small) application with Flask.  If
you rather want to dive into all the internal parts of Flask, check out
the :ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

Flask also depends on two external libraries: the `Jinja2`_ template
engine and the `Werkzeug`_ WSGI toolkit.  both of which are not documented
here.  If you want to dive into their documentation check out the
following links:

-   `Jinja2 Documentation <http://jinja.pocoo.org/2/documentation/>`_
-   `Werkzeug Documentation <http://werkzeug.pocoo.org/documentation/>`_

.. _Jinja2: http://jinja.pocoo.org/2/
.. _Werkzeug: http://werkzeug.pocoo.org/

Textual Documentation
---------------------

This part of the documentation is written text and should give you an idea
how to work with Flask.  It's a series of step-by-step instructions for
web development.

.. toctree::
   :maxdepth: 2

   foreword
   installation
   quickstart
   tutorial/index
   testing
   patterns/index
   deploying/index
   becomingbig
   design
   license

Reference
---------

If you are looking for information on a specific function, class or
method, this part of the documentation is for you:

.. toctree::
   :maxdepth: 2

   api
","@@ -44,6 +44,7 @@ web development.
    deploying/index
    becomingbig
    design
+   license
 
 Reference
 ---------
",add documentation for the reference sequence,add documentation for the reference sequence,add documentation for the reference sequence,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
3a1e51865786474c44a04c0d422515047dd27223,Fixed typo and added AUTHORS file and license text to docs.,license.rst,,"License
=======

Flask is licensed under a three clause `BSD License`_.  It basically
means: do whatever you want with it as long as the copyright in Flask
sticks around, the conditions are not modified and the disclaimer is
present.  Furthermore you must not use the names of the authors to promote
derivates of the software without written consent.

.. _BSD License:
   http://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22New_BSD_License.22.29

Authors
-------

.. include:: ../AUTHORS

License Text
------------

.. include:: ../LICENSE
","@@ -0,0 +1,21 @@
+License
+=======
+
+Flask is licensed under a three clause `BSD License`_.  It basically
+means: do whatever you want with it as long as the copyright in Flask
+sticks around, the conditions are not modified and the disclaimer is
+present.  Furthermore you must not use the names of the authors to promote
+derivates of the software without written consent.
+
+.. _BSD License:
+   http://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22New_BSD_License.22.29
+
+Authors
+-------
+
+.. include:: ../AUTHORS
+
+License Text
+------------
+
+.. include:: ../LICENSE
",add missing docs to diff.js,add missing docs to diff.js,add missing docs to diff.js,llm_rectified,0.0,5,False,100.0,0,0,0,0,0,-100.0,0,0
3a1e51865786474c44a04c0d422515047dd27223,Fixed typo and added AUTHORS file and license text to docs.,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  Tha function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -358,7 +358,7 @@ class Flask(object):
         self.before_request_funcs = []
 
         #: a list of functions that are called at the end of the
-        #: request.  Tha function is passed the current response
+        #: request.  The function is passed the current response
         #: object and modify it in place or replace it.
         #: To register a function here use the :meth:`after_request`
         #: decorator.
",add missing imports to the flask module,add missing imports to the flask module,add missing imports to the flask module,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
9f6bc93e4de36fc209eb1203845e9505df1ca379,"Fixed XSS problem by escaping all slashes in JSON.

This also probes simplejson first to figure out if it escapes slashes
which it did in earlier versions.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if json_available:
    _json_escapes_slashes = '\\/' in json.dumps('/')


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    rv = json.dumps(string, *args, **kwargs)
    if not _json_escapes_slashes:
        rv = rv.replace('/', '\\/')
    return rv


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -10,6 +10,7 @@
     :license: BSD, see LICENSE for more details.
 """"""
 from __future__ import with_statement
+import re
 import os
 import sys
 
@@ -47,6 +48,12 @@ except (ImportError, AttributeError):
     pkg_resources = None
 
 
+# figure out if simplejson escapes slashes.  This behaviour was changed
+# from one version to another without reason.
+if json_available:
+    _json_escapes_slashes = '\\/' in json.dumps('/')
+
+
 class Request(RequestBase):
     """"""The request object used by default in flask.  Remembers the
     matched endpoint and view arguments.
@@ -271,7 +278,10 @@ def _tojson_filter(string, *args, **kwargs):
     """"""Calls dumps for the template engine, escaping Slashes properly.""""""
     if __debug__:
         _assert_have_json()
-    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')
+    rv = json.dumps(string, *args, **kwargs)
+    if not _json_escapes_slashes:
+        rv = rv.replace('/', '\\/')
+    return rv
 
 
 class Flask(object):
",add tests for simplejson escaping slashes,add tests for simplejson escaping slashes,add tests for simplejson escaping slashes,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
9f6bc93e4de36fc209eb1203845e9505df1ca379,"Fixed XSS problem by escaping all slashes in JSON.

This also probes simplejson first to figure out if it escapes slashes
which it did in earlier versions.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import flask
import unittest
import tempfile


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                return ','.join(super(ListConverter, self).to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import flask
import unittest
import tempfile


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                return ','.join(super(ListConverter, self).to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = flask.render_template_string('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","@@ -245,6 +245,8 @@ class JSONTestCase(unittest.TestCase):
         with app.test_request_context():
             rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
             assert rv == '""<\\/script>""'
+            rv = flask.render_template_string('{{ ""<\0/script>""|tojson|safe }}')
+            assert rv == '""<\\u0000\\/script>""'
 
 
 class TemplatingTestCase(unittest.TestCase):
",add test for template template in flask,add test for template template in flask,add test for template template in flask,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,api.rst,".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `url`         ``http://www.example.com/myapplication/page.html``
      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
      `url_root`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g
   
   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

    Note that the ``|tojson`` filter escapes forward slashes properly.

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
",".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `url`         ``http://www.example.com/myapplication/page.html``
      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
      `url_root`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g

   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

    Note that the ``|tojson`` filter escapes forward slashes properly.

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
","@@ -186,7 +186,7 @@ different values for each request.  In a nutshell: it does the right
 thing, like it does for :class:`request` and :class:`session`.
 
 .. data:: g
-   
+
    Just store on this whatever you want.  For example a database
    connection or the user that is currently logged in.
 
",add documentation for global object,add documentation for global object,add documentation for global object,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,jquery.rst,"AJAX with jQuery
================

`jQuery`_ is a small JavaScript library commonly used to simplify working
with the DOM and JavaScript in general.  It is the perfect tool to make
web applications more dynamic by exchanging JSON between server and
client.

JSON itself is a very lightweight transport format, very similar to how
Python primitives (numbers, strings, dicts and lists) look like which is
widely supported and very easy to parse.  It became popular a few years
ago and quickly replaced XML as transport format in web applications.

If you have Python 2.6 JSON will work out of the box, in Python 2.5 you
will have to install the `simplejson`_ library from PyPI.

.. _jQuery: http://jquery.com/
.. _simplejson: http://pypi.python.org/pypi/simplejson

Loading jQuery
--------------

In order to use jQuery, you have to download it first and place it in the
static folder of your application and then ensure it's loaded.  Ideally
you have a layout template that is used for all pages where you just have
to add a script statement to your `head` to load jQuery:

.. sourcecode:: html

   <script type=text/javascript src=""{{
     url_for('static', filename='jquery.js') }}""></script>

Another method is using Google's `AJAX Libraries API
<http://code.google.com/apis/ajaxlibs/documentation/>`_ to load jQuery:

.. sourcecode:: html

    <script type=text/javascript
      src=""http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js""></script>

In this case you don't have to put jQuery into your static folder, it will
instead be loaded from Google directly.  This has the advantage that your
website will probably load faster for users if they were to at least one
other website before using the same jQuery version from Google because it
will already be in the browser cache.  Downside is that if you don't have
network connectivity during development jQuery will not load.

Where is My Site?
-----------------

Do you know where your application is?  If you are developing the answer
is quite simple: it's on localhost port something and directly on the root
of that server.  But what if you later decide to move your application to
a different location?  For example to ``http://example.com/myapp``?  On
the server side this never was a problem because we were using the handy
:func:`~flask.url_for` function that did could answer that question for
us, but if we are using jQuery we should better not hardcode the path to
the application but make that dynamic, so how can we do that?

A simple method would be to add a script tag to our page that sets a
global variable to the prefix to the root of the application.  Something
like this:

.. sourcecode:: html+jinja

   <script type=text/javascript>
     $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
   </script>

The ``|safe`` is necessary so that Jinja does not escape the JSON encoded
string with HTML rules.  Usually this would be necessary, but we are
inside a `script` block here where different rules apply.

.. admonition:: Information for Pros

   In HTML the `script` tag is declared `CDATA` which means that entities
   will not be parsed.  Everything until ``</script>`` is handled as script.
   This also means that there must never be any ``</`` between the script
   tags.  ``|tojson`` is kindly enough to do the right thing here and
   escape slashes for you (``{{ ""</script>""|tojson|safe }`` is rendered as
   ``""<\/script>""``).


JSON View Functions
-------------------

Now let's create a server side function that accepts two URL arguments of
numbers which should be added together and then sent back to the
application in a JSON object.  This is a really ridiculous example and is
something you usually would do on the client side alone, but a simple
example that shows how you would use jQuery and Flask nonetheless::

    from flask import Flask, jsonify, render_template, request
    app = Flask(__name__)

    @app.route('/_add_numbers')
    def add_numbers():
        a = request.args.get('a', 0, type=int)
        b = request.args.get('b', 0, type=int)
        return jsonify(result=a + b)

    @app.route('/')
    def index():
        return render_template('index.html')

As you can see I also added an `index` method here that renders a
template.  This template will load jQuery as above and have a little form
we can add two numbers and a link to trigger the function on the server
side.

Note that we are using the :meth:`~werkzeug.MultiDict.get` method here
which will never fail.  If the key is missing a default value (here ``0``)
is returned.  Furthermore it can convert values to a specific type (like
in our case `int`).  This is especially handy for code that that is
triggered by a script (APIs, JavaScript etc.) because you don't need
special error reporting in that case.

The HTML
--------

You index.html template either has to extend a `layout.html` template with
jQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.
Here the HTML code needed for our little application (`index.html`).
Notice that we also drop the script directly into the HTML here.  It is
usually a better idea to have that in a separate script file:

.. sourcecode:: html

    <script type=text/javascript>
      $(function() {
        $('a#calculate').bind('click', function() {
          $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
            a: $('input[name=""a""]').val(),
            b: $('input[name=""b""]').val()
          }, function(data) {
            $(""#result"").text(data.result);
          });
          return false;
        });
      });
    </script>
    <h1>jQuery Example</h1>
    <p><input type=text size=5 name=a> +
       <input type=text size=5 name=b> =
       <span id=result>?</span>
    <p><a href=# id=calculate>calculate server side</a>

I won't got into detail here about how jQuery works, just a very quick
explanation of the little bit of code above:

1. ``$(function() { ... })`` specifies code that should run once the
   browser is done loading the basic parts of the page.
2. ``#('selector')`` selects an element and lets you operate on it.
3. ``element.bind('event', func)`` specifies a function that should run
   when the user clicked on the element.  If that function returns
   `false`, the default behaviour will not kick in (in this case, navigate
   to the `#` URL).
4. ``$.getJSON(url, data, func)`` sends a `GET` request to `url` and will
   send the contents of the `data` object as query parameters.  Once the
   data arrived, it will call the given function with the return value as
   argument.  Note that we can use the `$SCRIPT_ROOT` variable here that
   we set earlier.

If you don't get the whole picture, download the `sourcecode
for this example
<http://github.com/mitsuhiko/flask/tree/master/examples/jqueryexample>`_
from github.
","AJAX with jQuery
================

`jQuery`_ is a small JavaScript library commonly used to simplify working
with the DOM and JavaScript in general.  It is the perfect tool to make
web applications more dynamic by exchanging JSON between server and
client.

JSON itself is a very lightweight transport format, very similar to how
Python primitives (numbers, strings, dicts and lists) look like which is
widely supported and very easy to parse.  It became popular a few years
ago and quickly replaced XML as transport format in web applications.

If you have Python 2.6 JSON will work out of the box, in Python 2.5 you
will have to install the `simplejson`_ library from PyPI.

.. _jQuery: http://jquery.com/
.. _simplejson: http://pypi.python.org/pypi/simplejson

Loading jQuery
--------------

In order to use jQuery, you have to download it first and place it in the
static folder of your application and then ensure it's loaded.  Ideally
you have a layout template that is used for all pages where you just have
to add a script statement to your `head` to load jQuery:

.. sourcecode:: html

   <script type=text/javascript src=""{{
     url_for('static', filename='jquery.js') }}""></script>

Another method is using Google's `AJAX Libraries API
<http://code.google.com/apis/ajaxlibs/documentation/>`_ to load jQuery:

.. sourcecode:: html

    <script type=text/javascript
      src=""http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js""></script>

In this case you don't have to put jQuery into your static folder, it will
instead be loaded from Google directly.  This has the advantage that your
website will probably load faster for users if they were to at least one
other website before using the same jQuery version from Google because it
will already be in the browser cache.  Downside is that if you don't have
network connectivity during development jQuery will not load.

Where is My Site?
-----------------

Do you know where your application is?  If you are developing the answer
is quite simple: it's on localhost port something and directly on the root
of that server.  But what if you later decide to move your application to
a different location?  For example to ``http://example.com/myapp``?  On
the server side this never was a problem because we were using the handy
:func:`~flask.url_for` function that did could answer that question for
us, but if we are using jQuery we should better not hardcode the path to
the application but make that dynamic, so how can we do that?

A simple method would be to add a script tag to our page that sets a
global variable to the prefix to the root of the application.  Something
like this:

.. sourcecode:: html+jinja

   <script type=text/javascript>
     $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
   </script>

The ``|safe`` is necessary so that Jinja does not escape the JSON encoded
string with HTML rules.  Usually this would be necessary, but we are
inside a `script` block here where different rules apply.

.. admonition:: Information for Pros

   In HTML the `script` tag is declared `CDATA` which means that entities
   will not be parsed.  Everything until ``</script>`` is handled as script.
   This also means that there must never be any ``</`` between the script
   tags.  ``|tojson`` is kindly enough to do the right thing here and
   escape slashes for you (``{{ ""</script>""|tojson|safe }`` is rendered as
   ``""<\/script>""``).


JSON View Functions
-------------------

Now let's create a server side function that accepts two URL arguments of
numbers which should be added together and then sent back to the
application in a JSON object.  This is a really ridiculous example and is
something you usually would do on the client side alone, but a simple
example that shows how you would use jQuery and Flask nonetheless::

    from flask import Flask, jsonify, render_template, request
    app = Flask(__name__)

    @app.route('/_add_numbers')
    def add_numbers():
        a = request.args.get('a', 0, type=int)
        b = request.args.get('b', 0, type=int)
        return jsonify(result=a + b)

    @app.route('/')
    def index():
        return render_template('index.html')

As you can see I also added an `index` method here that renders a
template.  This template will load jQuery as above and have a little form
we can add two numbers and a link to trigger the function on the server
side.

Note that we are using the :meth:`~werkzeug.MultiDict.get` method here
which will never fail.  If the key is missing a default value (here ``0``)
is returned.  Furthermore it can convert values to a specific type (like
in our case `int`).  This is especially handy for code that is
triggered by a script (APIs, JavaScript etc.) because you don't need
special error reporting in that case.

The HTML
--------

You index.html template either has to extend a `layout.html` template with
jQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.
Here the HTML code needed for our little application (`index.html`).
Notice that we also drop the script directly into the HTML here.  It is
usually a better idea to have that in a separate script file:

.. sourcecode:: html

    <script type=text/javascript>
      $(function() {
        $('a#calculate').bind('click', function() {
          $.getJSON($SCRIPT_ROOT + '/_add_numbers', {
            a: $('input[name=""a""]').val(),
            b: $('input[name=""b""]').val()
          }, function(data) {
            $(""#result"").text(data.result);
          });
          return false;
        });
      });
    </script>
    <h1>jQuery Example</h1>
    <p><input type=text size=5 name=a> +
       <input type=text size=5 name=b> =
       <span id=result>?</span>
    <p><a href=# id=calculate>calculate server side</a>

I won't got into detail here about how jQuery works, just a very quick
explanation of the little bit of code above:

1. ``$(function() { ... })`` specifies code that should run once the
   browser is done loading the basic parts of the page.
2. ``#('selector')`` selects an element and lets you operate on it.
3. ``element.bind('event', func)`` specifies a function that should run
   when the user clicked on the element.  If that function returns
   `false`, the default behaviour will not kick in (in this case, navigate
   to the `#` URL).
4. ``$.getJSON(url, data, func)`` sends a `GET` request to `url` and will
   send the contents of the `data` object as query parameters.  Once the
   data arrived, it will call the given function with the return value as
   argument.  Note that we can use the `$SCRIPT_ROOT` variable here that
   we set earlier.

If you don't get the whole picture, download the `sourcecode
for this example
<http://github.com/mitsuhiko/flask/tree/master/examples/jqueryexample>`_
from github.
","@@ -111,7 +111,7 @@ side.
 Note that we are using the :meth:`~werkzeug.MultiDict.get` method here
 which will never fail.  If the key is missing a default value (here ``0``)
 is returned.  Furthermore it can convert values to a specific type (like
-in our case `int`).  This is especially handy for code that that is
+in our case `int`).  This is especially handy for code that is
 triggered by a script (APIs, JavaScript etc.) because you don't need
 special error reporting in that case.
 
",add a note about the format of the key missing,add a note about the format of the key missing,add a note about the format of the key missing,llm_rectified,0.0,10,False,0,0,0,0,0,0,0,0,0
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,packages.rst,".. _larger-applications:

Larger Applications
===================

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation has to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resolve to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the object itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates them, and yet we just added some:
   circular imports (That's when two module depend on each one.  In this
   case `views.py` depends on `__init__.py`).  Be advised that this is a
   bad idea in general but here it is actually fine.  The reason for this
   is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.
",".. _larger-applications:

Larger Applications
===================

For larger applications it's a good idea to use a package instead of a
module.  That is quite simple.  Imagine a small application looks like
this::

    /yourapplication
        /yourapplication.py
        /static
            /style.css
        /templates
            layout.html
            index.html
            login.html
            ...

To convert that into a larger one, just create a new folder
`yourapplication` inside the existing one and move everything below it.
Then rename `yourapplication.py` to `__init__.py`.  (Make sure to delete
all `.pyc` files first, otherwise things would most likely break)

You should then end up with something like that::

    /yourapplication
        /yourapplication
            /__init__.py
            /static
                /style.css
            /templates
                layout.html
                index.html
                login.html
                ...

But how do you run your application now?  The naive ``python
yourapplication/__init__.py`` will not work.  Let's just say that Python
does not want modules in packages to be the startup file.  But that is not
a big problem, just add a new file called `runserver.py` next to the inner
`yourapplication` folder with the following contents::

    from yourapplication import app
    app.run(debug=True)

What did we gain from this?  Now we can restructure the application a bit
into multiple modules.  The only thing you have to remember is the
following quick checklist:

1. the `Flask` application object creation has to be in the
   `__init__.py` file.  That way each module can import it safely and the
   `__name__` variable will resolve to the correct package.
2. all the view functions (the ones with a :meth:`~flask.Flask.route`
   decorator on top) have to be imported when in the `__init__.py` file.
   Not the object itself, but the module it is in.  Do the importing at
   the *bottom* of the file.

Here an example `__init__.py`::

    from flask import Flask
    app = Flask(__name__)

    import yourapplication.views

And this is what `views.py` would look like::

    from yourapplication import app

    @app.route('/')
    def index():
        return 'Hello World!'

.. admonition:: Circular Imports

   Every Python programmer hates them, and yet we just added some:
   circular imports (That's when two modules depend on each other.  In this
   case `views.py` depends on `__init__.py`).  Be advised that this is a
   bad idea in general but here it is actually fine.  The reason for this is
   that we are not actually using the views in `__init__.py` and just
   ensuring the module is imported and we are doing that at the bottom of
   the file.

   There are still some problems with that approach but if you want to use
   decorators there is no way around that.  Check out the
   :ref:`becomingbig` section for some inspiration how to deal with that.
","@@ -74,10 +74,9 @@ And this is what `views.py` would look like::
 .. admonition:: Circular Imports
 
    Every Python programmer hates them, and yet we just added some:
-   circular imports (That's when two module depend on each one.  In this
+   circular imports (That's when two modules depend on each other.  In this
    case `views.py` depends on `__init__.py`).  Be advised that this is a
-   bad idea in general but here it is actually fine.  The reason for this
-   is
+   bad idea in general but here it is actually fine.  The reason for this is
    that we are not actually using the views in `__init__.py` and just
    ensuring the module is imported and we are doing that at the bottom of
    the file.
",add a more detailed example to the documentation,add a more detailed example to the documentation,add a more detailed example to the documentation,llm_rectified,0.0,8,False,0,0,0,0,0,0,0,0,0
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,minitwit.py,"# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followed = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']], one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","# -*- coding: utf-8 -*-
""""""
    MiniTwit
    ~~~~~~~~

    A microblogging application written with Flask and sqlite3.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import time
import sqlite3
from hashlib import md5
from datetime import datetime
from contextlib import closing
from flask import Flask, request, session, url_for, redirect, \
     render_template, abort, g, flash
from werkzeug import check_password_hash, generate_password_hash


# configuration
DATABASE = '/tmp/minitwit.db'
PER_PAGE = 30
DEBUG = True
SECRET_KEY = 'development key'

# create our little application :)
app = Flask(__name__)


def connect_db():
    """"""Returns a new connection to the database.""""""
    return sqlite3.connect(DATABASE)


def init_db():
    """"""Creates the database tables.""""""
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()


def query_db(query, args=(), one=False):
    """"""Queries the database and returns a list of dictionaries.""""""
    cur = g.db.execute(query, args)
    rv = [dict((cur.description[idx][0], value)
               for idx, value in enumerate(row)) for row in cur.fetchall()]
    return (rv[0] if rv else None) if one else rv


def get_user_id(username):
    """"""Convenience method to look up the id for a username.""""""
    rv = g.db.execute('select user_id from user where username = ?',
                       [username]).fetchone()
    return rv[0] if rv else None


def format_datetime(timestamp):
    """"""Format a timestamp for display.""""""
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d @ %H:%M')


def gravatar_url(email, size=80):
    """"""Return the gravatar image for the given email address.""""""
    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)


@app.before_request
def before_request():
    """"""Make sure we are connected to the database each request and look
    up the current user so that we know he's there.
    """"""
    g.db = connect_db()
    g.user = None
    if 'user_id' in session:
        g.user = query_db('select * from user where user_id = ?',
                          [session['user_id']], one=True)


@app.after_request
def after_request(response):
    """"""Closes the database again at the end of the request.""""""
    g.db.close()
    return response


@app.route('/')
def timeline():
    """"""Shows a users timeline or if no user is logged in it will
    redirect to the public timeline.  This timeline shows the user's
    messages as well as all the messages of followed users.
    """"""
    if not g.user:
        return redirect(url_for('public_timeline'))
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id and (
            user.user_id = ? or
            user.user_id in (select whom_id from follower
                                    where who_id = ?))
        order by message.pub_date desc limit ?''',
        [session['user_id'], session['user_id'], PER_PAGE]))


@app.route('/public')
def public_timeline():
    """"""Displays the latest messages of all users.""""""
    return render_template('timeline.html', messages=query_db('''
        select message.*, user.* from message, user
        where message.author_id = user.user_id
        order by message.pub_date desc limit ?''', [PER_PAGE]))


@app.route('/<username>')
def user_timeline(username):
    """"""Display's a users tweets.""""""
    profile_user = query_db('select * from user where username = ?',
                            [username], one=True)
    if profile_user is None:
        abort(404)
    followed = False
    if g.user:
        followed = query_db('''select 1 from follower where
            follower.who_id = ? and follower.whom_id = ?''',
            [session['user_id'], profile_user['user_id']],
            one=True) is not None
    return render_template('timeline.html', messages=query_db('''
            select message.*, user.* from message, user where
            user.user_id = message.author_id and user.user_id = ?
            order by message.pub_date desc limit ?''',
            [profile_user['user_id'], PER_PAGE]), followed=followed,
            profile_user=profile_user)


@app.route('/<username>/follow')
def follow_user(username):
    """"""Adds the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('insert into follower (who_id, whom_id) values (?, ?)',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are now following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/<username>/unfollow')
def unfollow_user(username):
    """"""Removes the current user as follower of the given user.""""""
    if not g.user:
        abort(401)
    whom_id = get_user_id(username)
    if whom_id is None:
        abort(404)
    g.db.execute('delete from follower where who_id=? and whom_id=?',
                [session['user_id'], whom_id])
    g.db.commit()
    flash('You are no longer following ""%s""' % username)
    return redirect(url_for('user_timeline', username=username))


@app.route('/add_message', methods=['POST'])
def add_message():
    """"""Registers a new message for the user.""""""
    if 'user_id' not in session:
        abort(401)
    if request.form['text']:
        g.db.execute('''insert into message (author_id, text, pub_date)
            values (?, ?, ?)''', (session['user_id'], request.form['text'],
                                  int(time.time())))
        g.db.commit()
        flash('Your message was recorded')
    return redirect(url_for('timeline'))


@app.route('/login', methods=['GET', 'POST'])
def login():
    """"""Logs the user in.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        user = query_db('''select * from user where
            username = ?''', [request.form['username']], one=True)
        if user is None:
            error = 'Invalid username'
        elif not check_password_hash(user['pw_hash'],
                                     request.form['password']):
            error = 'Invalid password'
        else:
            flash('You were logged in')
            session['user_id'] = user['user_id']
            return redirect(url_for('timeline'))
    return render_template('login.html', error=error)


@app.route('/register', methods=['GET', 'POST'])
def register():
    """"""Registers the user.""""""
    if g.user:
        return redirect(url_for('timeline'))
    error = None
    if request.method == 'POST':
        if not request.form['username']:
            error = 'You have to enter a username'
        elif not request.form['email'] or \
                 '@' not in request.form['email']:
            error = 'You have to enter a valid email address'
        elif not request.form['password']:
            error = 'You have to enter a password'
        elif request.form['password'] != request.form['password2']:
            error = 'The two passwords do not match'
        elif get_user_id(request.form['username']) is not None:
            error = 'The username is already taken'
        else:
            g.db.execute('''insert into user (
                username, email, pw_hash) values (?, ?, ?)''',
                [request.form['username'], request.form['email'],
                 generate_password_hash(request.form['password'])])
            g.db.commit()
            flash('You were successfully registered and can login now')
            return redirect(url_for('login'))
    return render_template('register.html', error=error)


@app.route('/logout')
def logout():
    """"""Logs the user out.""""""
    flash('You were logged out')
    session.pop('user_id', None)
    return redirect(url_for('public_timeline'))


# add some filters to jinja and set the secret key and debug mode
# from the configuration.
app.jinja_env.filters['datetimeformat'] = format_datetime
app.jinja_env.filters['gravatar'] = gravatar_url
app.secret_key = SECRET_KEY
app.debug = DEBUG


if __name__ == '__main__':
    app.run()
","@@ -125,7 +125,8 @@ def user_timeline(username):
     if g.user:
         followed = query_db('''select 1 from follower where
             follower.who_id = ? and follower.whom_id = ?''',
-            [session['user_id'], profile_user['user_id']], one=True) is not None
+            [session['user_id'], profile_user['user_id']],
+            one=True) is not None
     return render_template('timeline.html', messages=query_db('''
             select message.*, user.* from message, user where
             user.user_id = message.author_id and user.user_id = ?
@@ -230,7 +231,7 @@ def register():
 
 @app.route('/logout')
 def logout():
-    """"""Logs the user out""""""
+    """"""Logs the user out.""""""
     flash('You were logged out')
     session.pop('user_id', None)
     return redirect(url_for('public_timeline'))
",add minitwit integration tests,add minitwit integration tests,add minitwit integration tests,llm_rectified,0.0,4,False,48.945650333297216,48.90029400499156,44,44,248,249,-0.04535632830565817,0,1
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import re
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if json_available:
    _json_escapes_slashes = '\\/' in json.dumps('/')


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    rv = json.dumps(string, *args, **kwargs)
    if not _json_escapes_slashes:
        rv = rv.replace('/', '\\/')
    return rv


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator. If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when servicing a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if json_available:
    _json_escapes_slashes = '\\/' in json.dumps('/')


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


def _tojson_filter(string, *args, **kwargs):
    """"""Calls dumps for the template engine, escaping Slashes properly.""""""
    if __debug__:
        _assert_have_json()
    rv = json.dumps(string, *args, **kwargs)
    if not _json_escapes_slashes:
        rv = rv.replace('/', '\\/')
    return rv


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='localhost', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -10,7 +10,6 @@
     :license: BSD, see LICENSE for more details.
 """"""
 from __future__ import with_statement
-import re
 import os
 import sys
 
@@ -261,7 +260,7 @@ def _default_template_ctx_processor():
 
 
 def _assert_have_json():
-    """"""Helper function that fails if JSON is unavailable""""""
+    """"""Helper function that fails if JSON is unavailable.""""""
     if not json_available:
         raise RuntimeError('simplejson not installed')
 
@@ -517,7 +516,7 @@ class Flask(object):
 
     def add_url_rule(self, rule, endpoint, view_func=None, **options):
         """"""Connects a URL rule.  Works exactly like the :meth:`route`
-        decorator. If a view_func is provided it will be registered with the
+        decorator.  If a view_func is provided it will be registered with the
         endpoint.
 
         Basically this example::
@@ -544,7 +543,7 @@ class Flask(object):
         :param endpoint: the endpoint for the registered URL rule.  Flask
                          itself assumes the name of the view function as
                          endpoint
-        :param view_func: the function to call when servicing a request to the
+        :param view_func: the function to call when serving a request to the
                           provided endpoint
         :param options: the options to be forwarded to the underlying
                         :class:`~werkzeug.routing.Rule` object
@@ -798,7 +797,7 @@ class Flask(object):
         return self.request_context(create_environ(*args, **kwargs))
 
     def __call__(self, environ, start_response):
-        """"""Shortcut for :attr:`wsgi_app`""""""
+        """"""Shortcut for :attr:`wsgi_app`.""""""
         return self.wsgi_app(environ, start_response)
 
 
",add documentation for simplejson,add documentation for simplejson,add documentation for simplejson,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
3c821a0fa45082bcec73dfb08662fb1de5263c48,Fix typos and remove unused import.,setup.py,"""""""
Flask
-----

Flask is a microframework for Python based on Werkzeug, Jinja 2 and good
intentions. And before you ask: It's BSD licensed!

Flask is Fun
````````````

::

    from flask import Flask
    app = Flask(__name__)

    @app.route(""/"")
    def hello():
        return ""Hello World!""

    if __name__ == ""__main__"":
        app.run()

And Easy to Setup
`````````````````

::

    $ easy_install Flask
    $ python hello.py
     * Running on http://localhost:5000/

Links
`````

* `website <http://flask.pocoo.org/>`_
* `documentation <http://flask.pocoo.org/docs/>`_
* `development version <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_

""""""
from setuptools import setup


setup(
    name='Flask',
    version='0.2',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 and good intentions',
    long_description=__doc__,
    py_modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[
        'Werkzeug>=0.6.1',
        'Jinja2>=2.4'
    ],
    classifiers=[
        'Development Status :: 3 - Alpha',
        'Environment :: Web Environment',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',
        'Operating System :: OS Independent',
        'Programming Language :: Python',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
        'Topic :: Software Development :: Libraries :: Python Modules'
    ]
)
","""""""
Flask
-----

Flask is a microframework for Python based on Werkzeug, Jinja 2 and good
intentions. And before you ask: It's BSD licensed!

Flask is Fun
````````````

::

    from flask import Flask
    app = Flask(__name__)

    @app.route(""/"")
    def hello():
        return ""Hello World!""

    if __name__ == ""__main__"":
        app.run()

And Easy to Setup
`````````````````

::

    $ easy_install Flask
    $ python hello.py
     * Running on http://localhost:5000/

Links
`````

* `website <http://flask.pocoo.org/>`_
* `documentation <http://flask.pocoo.org/docs/>`_
* `development version
  <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_

""""""
from setuptools import setup


setup(
    name='Flask',
    version='0.2',
    url='http://github.com/mitsuhiko/flask/',
    license='BSD',
    author='Armin Ronacher',
    author_email='armin.ronacher@active-4.com',
    description='A microframework based on Werkzeug, Jinja2 '
                'and good intentions',
    long_description=__doc__,
    py_modules=['flask'],
    zip_safe=False,
    platforms='any',
    install_requires=[
        'Werkzeug>=0.6.1',
        'Jinja2>=2.4'
    ],
    classifiers=[
        'Development Status :: 3 - Alpha',
        'Environment :: Web Environment',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',
        'Operating System :: OS Independent',
        'Programming Language :: Python',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
        'Topic :: Software Development :: Libraries :: Python Modules'
    ]
)
","@@ -34,7 +34,8 @@ Links
 
 * `website <http://flask.pocoo.org/>`_
 * `documentation <http://flask.pocoo.org/docs/>`_
-* `development version <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_
+* `development version
+  <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_
 
 """"""
 from setuptools import setup
@@ -47,7 +48,8 @@ setup(
     license='BSD',
     author='Armin Ronacher',
     author_email='armin.ronacher@active-4.com',
-    description='A microframework based on Werkzeug, Jinja2 and good intentions',
+    description='A microframework based on Werkzeug, Jinja2 '
+                'and good intentions',
     long_description=__doc__,
     py_modules=['flask'],
     zip_safe=False,
",add missing documentation,add missing documentation,add missing documentation,llm_rectified,0.0,3,False,100.0,100.0,0,0,69,71,0.0,0,2
9d340ad7477774a19a7bdffc83d6cb8cb3e05edc,"Fix a doc oversight, and revert 5876a8fd.",testing.rst,".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the function.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s
    
    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
",".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the file.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s

    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
","@@ -68,7 +68,7 @@ to create a temporary database and initialize it.  The
 :func:`~tempfile.mkstemp` function does two things for us: it returns a
 low-level file handle and a random file name, the latter we use as
 database name.  We just have to keep the `db_fd` around so that we can use
-the :func:`os.close` function to close the function.
+the :func:`os.close` function to close the file.
 
 If we now run that testsuite, we should see the following output::
 
@@ -76,7 +76,7 @@ If we now run that testsuite, we should see the following output::
 
     ----------------------------------------------------------------------
     Ran 0 tests in 0.000s
-    
+
     OK
 
 Even though it did not run any tests, we already know that our flaskr
",add more examples to the uh-test example,add more examples to the uh-test example,add more examples to the uh-test example,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
9d340ad7477774a19a7bdffc83d6cb8cb3e05edc,"Fix a doc oversight, and revert 5876a8fd.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):
    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -270,6 +270,7 @@ def _get_package_path(name):
 # figure out if simplejson escapes slashes.  This behaviour was changed
 # from one version to another without reason.
 if not json_available or '\\/' not in json.dumps('/'):
+
     def _tojson_filter(*args, **kwargs):
         if __debug__:
             _assert_have_json()
",add more info to the request class,add more info to the request class,add more info to the request class,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
f014ce29a7cd5a3ccfabd61e7d66e017ed958e25,"Fix a doc oversight, and revert 5876a8fd.",testing.rst,".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the function.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s
    
    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
",".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the file.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s

    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
","@@ -68,7 +68,7 @@ to create a temporary database and initialize it.  The
 :func:`~tempfile.mkstemp` function does two things for us: it returns a
 low-level file handle and a random file name, the latter we use as
 database name.  We just have to keep the `db_fd` around so that we can use
-the :func:`os.close` function to close the function.
+the :func:`os.close` function to close the file.
 
 If we now run that testsuite, we should see the following output::
 
@@ -76,7 +76,7 @@ If we now run that testsuite, we should see the following output::
 
     ----------------------------------------------------------------------
     Ran 0 tests in 0.000s
-    
+
     OK
 
 Even though it did not run any tests, we already know that our flaskr
",add more examples to the uh-test example,add more examples to the uh-test example,add more examples to the uh-test example,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
f014ce29a7cd5a3ccfabd61e7d66e017ed958e25,"Fix a doc oversight, and revert 5876a8fd.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):
    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    def __init__(self, environ):
        RequestBase.__init__(self, environ)
        self.endpoint = None
        self.view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _NullSession(SecureCookie):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request, self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        session.save_cookie(response, self.session_cookie_name)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowd for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -270,6 +270,7 @@ def _get_package_path(name):
 # figure out if simplejson escapes slashes.  This behaviour was changed
 # from one version to another without reason.
 if not json_available or '\\/' not in json.dumps('/'):
+
     def _tojson_filter(*args, **kwargs):
         if __debug__:
             _assert_have_json()
",add more info to the request class,add more info to the request class,add more info to the request class,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
ef34638f5d24c07a5582cbb60755fd4dfbec9a79,"Updated docs for external server information.

This fixes #14.",quickstart.rst,".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
",".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. _public-server:

.. admonition:: Externally Visible Server

   If you run the server you will notice that the server is only available
   from your own computer, not from any other in the network.  This is the
   default because in debugging mode a user of the application can execute
   arbitrary Python code on your computer.  If you have `debug` disabled
   or trust the users on your network, you can make the server publicly
   available.

   Just change the call of the :meth:`~flask.Flask.run` method to look
   like this::

       app.run(host='0.0.0.0')

   This tells your operating system to listen on a public IP.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
","@@ -54,6 +54,24 @@ So what did that code do?
 
 To stop the server, hit control-C.
 
+.. _public-server:
+
+.. admonition:: Externally Visible Server
+
+   If you run the server you will notice that the server is only available
+   from your own computer, not from any other in the network.  This is the
+   default because in debugging mode a user of the application can execute
+   arbitrary Python code on your computer.  If you have `debug` disabled
+   or trust the users on your network, you can make the server publicly
+   available.
+
+   Just change the call of the :meth:`~flask.Flask.run` method to look
+   like this::
+
+       app.run(host='0.0.0.0')
+
+   This tells your operating system to listen on a public IP.
+
 
 Debug Mode
 ----------
",add more info about the debug mode,add more info about the debug mode,add more info about the debug mode,llm_rectified,0.0,7,True,0,0,0,0,0,0,0,0,0
ef34638f5d24c07a5582cbb60755fd4dfbec9a79,"Updated docs for external server information.

This fixes #14.",setup.rst,"Step 2: Application Setup Code
==============================

Now that we have the schema in place we can create the application module.
Let's call it `flaskr.py` inside the `flaskr` folder.  For starters we
will add the imports we will need as well as the config section.  For
small applications it's a possibility to drop the configuration directly
into the module which we will be doing here.  However a cleaner solution
would be to create a separate `.ini` or `.py` file and load that or import
the values from there.

::

    # all the imports
    import sqlite3
    from flask import Flask, request, session, g, redirect, url_for, \
         abort, render_template, flash

    # configuration
    DATABASE = '/tmp/flaskr.db'
    DEBUG = True
    SECRET_KEY = 'development key'
    USERNAME = 'admin'
    PASSWORD = 'default'

Next we can create our actual application and initialize it with the
config::

    # create our little application :)
    app = Flask(__name__)
    app.secret_key = SECRET_KEY
    app.debug = DEBUG

The `secret_key` is needed to keep the client-side sessions secure.
Choose that key wisely and as hard to guess and complex as possible.  The
debug flag enables or disables the interactive debugger.  Never leave
debug mode activated in a production system because it will allow users to
executed code on the server!

We also add a method to easily connect to the database specified.  That
can be used to open a connection on request and also from the interactive
Python shell or a script.  This will come in handy later

::

    def connect_db():
        return sqlite3.connect(DATABASE)

Finally we just add a line to the bottom of the file that fires up the
server if we run that file as standalone application::

    if __name__ == '__main__':
        app.run()

With that out of the way you should be able to start up the application
without problems.  When you head over to the server you will get an 404
page not found error because we don't have any views yet.  But we will
focus on that a little later.  First we should get the database working.

.. admonition:: Troubleshooting

   If you notice later that the browser cannot connect to the server
   during development, you might want to try this line instead::

       app.run(host='127.0.0.1')

   In a nutshell: Werkzeug starts up as IPv6 on many operating systems by
   default and not every browser is happy with that.  This forces IPv4
   usage.
","Step 2: Application Setup Code
==============================

Now that we have the schema in place we can create the application module.
Let's call it `flaskr.py` inside the `flaskr` folder.  For starters we
will add the imports we will need as well as the config section.  For
small applications it's a possibility to drop the configuration directly
into the module which we will be doing here.  However a cleaner solution
would be to create a separate `.ini` or `.py` file and load that or import
the values from there.

::

    # all the imports
    import sqlite3
    from flask import Flask, request, session, g, redirect, url_for, \
         abort, render_template, flash

    # configuration
    DATABASE = '/tmp/flaskr.db'
    DEBUG = True
    SECRET_KEY = 'development key'
    USERNAME = 'admin'
    PASSWORD = 'default'

Next we can create our actual application and initialize it with the
config::

    # create our little application :)
    app = Flask(__name__)
    app.secret_key = SECRET_KEY
    app.debug = DEBUG

The `secret_key` is needed to keep the client-side sessions secure.
Choose that key wisely and as hard to guess and complex as possible.  The
debug flag enables or disables the interactive debugger.  Never leave
debug mode activated in a production system because it will allow users to
executed code on the server!

We also add a method to easily connect to the database specified.  That
can be used to open a connection on request and also from the interactive
Python shell or a script.  This will come in handy later

::

    def connect_db():
        return sqlite3.connect(DATABASE)

Finally we just add a line to the bottom of the file that fires up the
server if we run that file as standalone application::

    if __name__ == '__main__':
        app.run()

With that out of the way you should be able to start up the application
without problems.  When you head over to the server you will get an 404
page not found error because we don't have any views yet.  But we will
focus on that a little later.  First we should get the database working.

.. admonition:: Externally Visible Server

   Want your server to be publically available?  Check out the
   :ref:`externally visible server <public-server>` section for more
   information.
","@@ -57,13 +57,8 @@ without problems.  When you head over to the server you will get an 404
 page not found error because we don't have any views yet.  But we will
 focus on that a little later.  First we should get the database working.
 
-.. admonition:: Troubleshooting
+.. admonition:: Externally Visible Server
 
-   If you notice later that the browser cannot connect to the server
-   during development, you might want to try this line instead::
-
-       app.run(host='127.0.0.1')
-
-   In a nutshell: Werkzeug starts up as IPv6 on many operating systems by
-   default and not every browser is happy with that.  This forces IPv4
-   usage.
+   Want your server to be publically available?  Check out the
+   :ref:`externally visible server <public-server>` section for more
+   information.
",add more info about the server,add more info about the server,add more info about the server,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
606b006e2391d12fec5313ce606d82463d7aad07,Fixed at least one build warning by renaming files.,Makefile,".PHONY: clean-pyc test

all: clean-pyc test

test:
	python tests/flask_tests.py

clean-pyc:
	find . -name '*.pyc' -exec rm -f {} +
	find . -name '*.pyo' -exec rm -f {} +
	find . -name '*~' -exec rm -f {} +

upload-docs:
	$(MAKE) -C docs dirhtml latex
	$(MAKE) -C docs/_build/latex all-pdf
	scp -r docs/_build/dirhtml/* pocoo.org:/var/www/flask.pocoo.org/docs/
	scp -r docs/_build/latex/Flask.pdf pocoo.org:/var/www/flask.pocoo.org/docs/flask-docs.pdf
",".PHONY: clean-pyc test

all: clean-pyc test

test:
	python tests/flask_tests.py

clean-pyc:
	find . -name '*.pyc' -exec rm -f {} +
	find . -name '*.pyo' -exec rm -f {} +
	find . -name '*~' -exec rm -f {} +

upload-docs:
	$(MAKE) -C docs html dirhtml latex
	$(MAKE) -C docs/_build/latex all-pdf
	cd docs/_build/; mv html flask-docs; zip -r flask-docs.zip flask-docs; mv flask-docs html
	scp -r docs/_build/dirhtml/* pocoo.org:/var/www/flask.pocoo.org/docs/
	scp -r docs/_build/latex/Flask.pdf pocoo.org:/var/www/flask.pocoo.org/docs/flask-docs.pdf
	scp -r docs/_build/flask-docs.zip pocoo.org:/var/www/flask.pocoo.org/docs/
","@@ -11,7 +11,9 @@ clean-pyc:
 	find . -name '*~' -exec rm -f {} +
 
 upload-docs:
-	$(MAKE) -C docs dirhtml latex
+	$(MAKE) -C docs html dirhtml latex
 	$(MAKE) -C docs/_build/latex all-pdf
+	cd docs/_build/; mv html flask-docs; zip -r flask-docs.zip flask-docs; mv flask-docs html
 	scp -r docs/_build/dirhtml/* pocoo.org:/var/www/flask.pocoo.org/docs/
 	scp -r docs/_build/latex/Flask.pdf pocoo.org:/var/www/flask.pocoo.org/docs/flask-docs.pdf
+	scp -r docs/_build/flask-docs.zip pocoo.org:/var/www/flask.pocoo.org/docs/
",add more diff output,add more diff output,add more diff output,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
606b006e2391d12fec5313ce606d82463d7aad07,Fixed at least one build warning by renaming files.,contents.rst.inc,,,,add missing semicolon,add missing semicolon,add missing semicolon,llm_rectified,0.0,3,False,100.0,100.0,0,0,0,0,0.0,0,0
606b006e2391d12fec5313ce606d82463d7aad07,Fixed at least one build warning by renaming files.,index.rst,"Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :class: floatingflask

Welcome to Flask's documentation.  This documentation is divided in
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.
Besides the quickstart there is also a more detailed :ref:`tutorial` that
shows how to create a complete (albeit small) application with Flask.  If
you rather want to dive into all the internal parts of Flask, check out
the :ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

Flask also depends on two external libraries: the `Jinja2`_ template
engine and the `Werkzeug`_ WSGI toolkit.  both of which are not documented
here.  If you want to dive into their documentation check out the
following links:

-   `Jinja2 Documentation <http://jinja.pocoo.org/2/documentation/>`_
-   `Werkzeug Documentation <http://werkzeug.pocoo.org/documentation/>`_

.. _Jinja2: http://jinja.pocoo.org/2/
.. _Werkzeug: http://werkzeug.pocoo.org/

.. include:: contents.rst
","Welcome to Flask
================

.. image:: _static/logo-full.png
   :alt: The Flask Logo with Subtitle
   :class: floatingflask

Welcome to Flask's documentation.  This documentation is divided in
different parts.  I would suggest to get started with the
:ref:`installation` and then heading over to the :ref:`quickstart`.
Besides the quickstart there is also a more detailed :ref:`tutorial` that
shows how to create a complete (albeit small) application with Flask.  If
you rather want to dive into all the internal parts of Flask, check out
the :ref:`api` documentation.  Common patterns are described in the
:ref:`patterns` section.

Flask also depends on two external libraries: the `Jinja2`_ template
engine and the `Werkzeug`_ WSGI toolkit.  both of which are not documented
here.  If you want to dive into their documentation check out the
following links:

-   `Jinja2 Documentation <http://jinja.pocoo.org/2/documentation/>`_
-   `Werkzeug Documentation <http://werkzeug.pocoo.org/documentation/>`_

.. _Jinja2: http://jinja.pocoo.org/2/
.. _Werkzeug: http://werkzeug.pocoo.org/

.. include:: contents.rst.inc
","@@ -25,4 +25,4 @@ following links:
 .. _Jinja2: http://jinja.pocoo.org/2/
 .. _Werkzeug: http://werkzeug.pocoo.org/
 
-.. include:: contents.rst
+.. include:: contents.rst.inc
",add more info about the nag array,add more info about the nag array,add more info about the nag array,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
606b006e2391d12fec5313ce606d82463d7aad07,Fixed at least one build warning by renaming files.,latexindex.rst,"Flask Documentation
===================

.. include:: contents.rst
","Flask Documentation
===================

.. include:: contents.rst.inc
","@@ -1,4 +1,4 @@
 Flask Documentation
 ===================
 
-.. include:: contents.rst
+.. include:: contents.rst.inc
",update documentation.php,,,fallback_short,1.0,0,False,0,0,0,0,0,0,0,0,0
2ba88eefb54f76fc974181babac07ffc7c1f7e73,Fixed simple typo,wtforms.rst,"Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [
            validators.Required(),
            validators.EqualTo('confirm', message='Passwords must match')
        ])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""post"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","Form Validation with WTForms
============================

When you have to work with form data submitted by a browser view code
quickly becomes very hard to read.  There are libraries out there designed
to make this process easier to manage.  One of them is `WTForms`_ which we
will handle here.  If you find yourself in the situation of having many
forms, you might want to give it a try.

When you are working with WTForms you have to define your forms as classes
first.  I recommend breaking up the application into multiple modules 
(:ref:`larger-applications`) for that and adding a separate module for the
forms.

The Forms
---------

This is an example form for a typical registration page::

    from wtforms import Form, BooleanField, TextField, validators

    class RegistrationForm(Form):
        username = TextField('Username', [validators.Length(min=4, max=25)])
        email = TextField('Email Address', [validators.Length(min=6, max=35)])
        password = PasswordField('New Password', [
            validators.Required(),
            validators.EqualTo('confirm', message='Passwords must match')
        ])
        confirm = PasswordField('Repeat Password')
        accept_tos = BooleanField('I accept the TOS', [validators.Required()])

In the View
-----------

In the view function, the usage of this form looks like this::

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        form = RegistrationForm(request.form)
        if request.method == 'POST' and form.validate():
            user = User(form.username.data, form.email.data,
                        form.password.data)
            db_session.add(user)
            flash('Thanks for registering')
            return redirect(url_for('login'))
        return render_template('register.html', form=form)

Notice that we are implying that the view is using SQLAlchemy here
(:ref:`sqlalchemy-pattern`) but this is no requirement of course.  Adapt
the code as necessary.

Things to remember:

1. create the form from the request :attr:`~flask.request.form` value if
   the data is submitted via the HTTP `POST` method and
   :attr:`~flask.request.args` if the data is submitted as `GET`.
2. to validate the data, call the :func:`~wtforms.form.Form.validate`
   method which will return `True` if the data validates, `False`
   otherwise.
3. to access individual values from the form, access `form.<NAME>.data`.

Forms in Templates
------------------

Now to the template side.  When you pass the form to the templates you can
easily render them there.  Look at the following example template to see
how easy this is.  WTForms does half the form generation for us already.
To make it even nicer, we can write a macro that renders a field with
label and a list of errors if there are any.

Here an example `_formhelpers.html` template with such a macro:

.. sourcecode:: html+jinja

    {% macro render_field(field) %}
      <dt>{{ field.label }}
      <dd>{{ field(**kwargs)|safe }}
      {% if field.errors %}
        <ul class=""errors"">
        {% for error in field.errors %}<li>{{ error }}{% endfor %}
        </ul>
      {% endif %}
      </dd>
    {% endmacro %}

This macro accepts a couple of keyword arguments that are forwarded to
WTForm's field function that renders the field for us.  They keyword
arguments will be inserted as HTML attributes.  So for example you can
call ``render_field(form.username, class='username')`` to add a class to
the input element.  Note that WTForms returns standard Python unicode
strings, so we have to tell Jinja2 that this data is already HTML escaped
with the `|safe` filter.

Here the `register.html` template for the function we used above which
takes advantage of the `_formhelpers.html` template:

.. sourcecode:: html+jinja

    {% from ""_formhelpers.html"" import render_field %}
    <form method=""post"" action=""/register"">
      <dl>
        {{ render_field(form.username) }}
        {{ render_field(form.email) }}
        {{ render_field(form.password) }}
        {{ render_field(form.confirm) }}
        {{ render_field(form.accept_tos) }}
      </dl>
      <p><input type=submit value=Register>
    </form>

For more information about WTForms, head over to the `WTForms
website`_.

.. _WTForms: http://wtforms.simplecodes.com/
.. _WTForms website: http://wtforms.simplecodes.com/
","@@ -42,7 +42,7 @@ In the view function, the usage of this form looks like this::
                         form.password.data)
             db_session.add(user)
             flash('Thanks for registering')
-            redirect(url_for('login'))
+            return redirect(url_for('login'))
         return render_template('register.html', form=form)
 
 Notice that we are implying that the view is using SQLAlchemy here
",add example form for registration,add example form for registration,add example form for registration,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
31493850de3d7765d09419aa49b98089f79da3c2,Fixed typo in flask quickstart docs. This fixes #21,quickstart.rst,".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. _public-server:

.. admonition:: Externally Visible Server

   If you run the server you will notice that the server is only available
   from your own computer, not from any other in the network.  This is the
   default because in debugging mode a user of the application can execute
   arbitrary Python code on your computer.  If you have `debug` disabled
   or trust the users on your network, you can make the server publicly
   available.

   Just change the call of the :meth:`~flask.Flask.run` method to look
   like this::

       app.run(host='0.0.0.0')

   This tells your operating system to listen on a public IP.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', method=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
",".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. _public-server:

.. admonition:: Externally Visible Server

   If you run the server you will notice that the server is only available
   from your own computer, not from any other in the network.  This is the
   default because in debugging mode a user of the application can execute
   arbitrary Python code on your computer.  If you have `debug` disabled
   or trust the users on your network, you can make the server publicly
   available.

   Just change the call of the :meth:`~flask.Flask.run` method to look
   like this::

       app.run(host='0.0.0.0')

   This tells your operating system to listen on a public IP.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', methods=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
","@@ -452,7 +452,7 @@ transmitted in a `POST` or `PUT` request) you can use the
 :attr:`~flask.request.form` attribute.  Here a full example of the two
 attributes mentioned above::
 
-    @app.route('/login', method=['POST', 'GET'])
+    @app.route('/login', methods=['POST', 'GET'])
     def login():
         error = None
         if request.method == 'POST':
",add documentation for the `login` method,add documentation for the `login` method,add documentation for the `login` method,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
f1603d33f266ab24eda604f76632fa604b91e3f9,Docs mention query args now.  This fixes #20,quickstart.rst,".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. _public-server:

.. admonition:: Externally Visible Server

   If you run the server you will notice that the server is only available
   from your own computer, not from any other in the network.  This is the
   default because in debugging mode a user of the application can execute
   arbitrary Python code on your computer.  If you have `debug` disabled
   or trust the users on your network, you can make the server publicly
   available.

   Just change the call of the :meth:`~flask.Flask.run` method to look
   like this::

       app.run(host='0.0.0.0')

   This tells your operating system to listen on a public IP.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
... 
/
/login
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', methods=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
",".. _quickstart:

Quickstart
==========

Eager to get started?  This page gives a good introduction in how to gets
started with Flask.  This assumes you already have Flask installed.  If
you do not, head over to the :ref:`installation` section.


A Minimal Application
---------------------

A minimal Flask application looks something like that::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello_world():
        return ""Hello World!""

    if __name__ == '__main__':
        app.run()

Just save it as `hello.py` or something similar and run it with your
Python interpreter.  Make sure to not call your application `flask.py`
because this would conflict with Flask itself.

::

    $ python hello.py
     * Running on http://127.0.0.1:5000/

Head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, you should
see your hello world greeting.

So what did that code do?

1. first we imported the :class:`~flask.Flask` class.  An instance of this
   class will be our WSGI application.
2. next we create an instance of it.  We pass it the name of the module /
   package.  This is needed so that Flask knows where it should look for
   templates, static files and so on.
3. Then we use the :meth:`~flask.Flask.route` decorator to tell Flask
   what URL should trigger our function.
4. The function then has a name which is also used to generate URLs to
   that particular function, and returns the message we want to display in
   the user's browser.
5. Finally we use the :meth:`~flask.Flask.run` function to run the
   local server with our application.  The ``if __name__ == '__main__':``
   makes sure the server only runs if the script is executed directly from
   the Python interpreter and not used as imported module.

To stop the server, hit control-C.

.. _public-server:

.. admonition:: Externally Visible Server

   If you run the server you will notice that the server is only available
   from your own computer, not from any other in the network.  This is the
   default because in debugging mode a user of the application can execute
   arbitrary Python code on your computer.  If you have `debug` disabled
   or trust the users on your network, you can make the server publicly
   available.

   Just change the call of the :meth:`~flask.Flask.run` method to look
   like this::

       app.run(host='0.0.0.0')

   This tells your operating system to listen on a public IP.


Debug Mode
----------

Now that :meth:`~flask.Flask.run` method is nice to start a local
development server, but you would have to restart it manually after each
change you do to code.  That is not very nice and Flask can do better.  If
you enable the debug support the server will reload itself on code changes
and also provide you with a helpful debugger if things go wrong.

There are two ways to enable debugging.  Either set that flag on the
applciation object::

    app.debug = True
    app.run()

Or pass it to run::

    app.run(debug=True)

Both will have exactly the same effect.

.. admonition:: Attention

   The interactive debugger however does not work in forking environments
   which makes it nearly impossible to use on production servers but the
   debugger still allows the execution of arbitrary code which makes it a
   major security risk and **must never be used on production machines**
   because of that.

Screenshot of the debugger in action:

.. image:: _static/debugger.png
   :align: center
   :class: screenshot
   :alt: screenshot of debugger in action


Routing
-------

As you have seen above, the :meth:`~flask.Flask.route` decorator is used
to bind a function to a URL.  But there is more to it!  You can make
certain parts of the URL dynamic and attach multiple rules to a function.

Here some examples::

    @app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello World'


Variable Rules
``````````````

Modern web applications have beautiful URLs.  This helps people remember
the URLs which is especially handy for applications that are used from
mobile devices with slower network connections.  If the user can directly
go to the desired page without having to hit the index page it is more
likely he will like the page and come back next time.

To add variable parts to a URL you can mark these special sections as
``<variable_name>``.  Such a part is then passed as keyword argument to
your function.  Optionally a converter can be specifed by specifying a
rule with ``<converter:variable_name>``.  Here some nice examples::

    @app.route('/user/<username>')
    def show_user_profile(username):
        # show the user profile for that user
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # show the post with the given id, the id is an integer
        pass

The following converters exist:

=========== ===========================================
`int`       accepts integers
`float`     like `int` but for floating point values
`path`      like the default but also accepts slashes
=========== ===========================================

.. _url-building:

URL Building
````````````

If it can match URLs, can it also generate them?  Of course you can.  To
build a URL to a specific function you can use the :func:`~flask.url_for`
function.  It accepts the name of the function as first argument and a
number of keyword arguments, each corresponding to the variable part of
the URL rule.  Unknown variable parts are appended to the URL as query
parameter.  Here some examples:

>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
... 
>>> @app.route('/login')
... def login(): pass
... 
>>> @app.route('/user/<username>')
... def profile(username): pass
... 
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('profile', username='John Doe')
...  print url_for('login', next='/')
... 
/
/login
/login?next=/
/user/John%20Doe

(This also uses the :meth:`~flask.Flask.test_request_context` method
explained below.  It basically tells flask to think we are handling a
request even though we are not, we are in an interactive Python shell.
Have a look at the explanation below. :ref:`context-locals`).

Why would you want to build URLs instead of hardcoding them in your
templates?  There are three good reasons for this:

1. reversing is often more descriptive than hardcoding the URLs.  Also and
   more importantly you can change URLs in one go without having to change
   the URLs all over the place.
2. URL building will handle escaping of special characters and unicode
   data transparently for you, you don't have to deal with that.
3. If your application is placed outside the URL root (so say in
   ``/myapplication`` instead of ``/``), :func:`~flask.url_for` will
   handle that properly for you.


HTTP Methods
````````````

HTTP (the protocol web applications are speaking) knows different methods
to access URLs.  By default a route only answers to `GET` requests, but
that can be changed by providing the `methods` argument to the
:meth:`~flask.Flask.route` decorator.  Here some examples::

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            do_the_login()
        else:
            show_the_login_form()

If `GET` is present, `HEAD` will be added automatically for you.  You
don't have to deal with that.  It will also make sure that `HEAD` requests
are handled like the `HTTP RFC`_ (the document describing the HTTP
protocol) demands, so you can completely ignore that part of the HTTP
specification.

You have no idea what an HTTP method is?  Worry not, here quick
introduction in HTTP methods and why they matter:

The HTTP method (also often called ""the verb"") tells the server what the
clients wants to *do* with the requested page.  The following methods are
very common:

`GET`
    The Browser tells the server: just *get* me the information stored on
    that page and send them to me.  This is probably the most common
    method.

`HEAD`
    The Browser tells the server: get me the information, but I am only
    interested in the *headers*, not the content of the page.  An
    application is supposed to handle that as if a `GET` request was
    received but not deliver the actual contents.  In Flask you don't have
    to deal with that at all, the underlying Werkzeug library handles that
    for you.

`POST`
    The browser tells the server that it wants to *post* some new
    information to that URL and that the server must ensure the data is
    stored and only stored once.  This is how HTML forms are usually
    transmitting data to the server.

`PUT`
    Similar to `POST` but the server might trigger the store procedure
    multiple times by overwriting the old values more than once.  Now you
    might be asking why this is any useful, but there are some good
    reasons to do that.  Consider the connection is lost during
    transmission, in that situation a system between the browser and the
    server might sent the request safely a second time without breaking
    things.  With `POST` that would not be possible because it must only
    be triggered once.

`DELETE`
    Remove the information that the given location.

Now the interesting part is that in HTML4 and XHTML1, the only methods a
form might submit to the server are `GET` and `POST`.  But with JavaScript
and future HTML standards you can use other methods as well.  Furthermore
HTTP became quite popular lately and there are more things than browsers
that are speaking HTTP.  (Your revision control system for instance might
speak HTTP)

.. _HTTP RFC: http://www.ietf.org/rfc/rfc2068.txt

Static Files
------------

Dynamic web applications need static files as well.  That's usually where
the CSS and JavaScript files are coming from.  Ideally your web server is
configured to serve them for you, but during development Flask can do that
as well.  Just create a folder called `static` in your package or next to
your module and it will be available at `/static` on the application.

To generate URLs to that part of the URL, use the special ``'static'`` URL
name::

    url_for('static', filename='style.css')

The file has to be stored on the filesystem as ``static/style.css``.

Rendering Templates
-------------------

Generating HTML from within Python is not fun, and actually pretty
cumbersome because you have to do the HTML escaping on your own to keep
the application secure.  Because of that Flask configures the `Jinja2
<http://jinja.pocoo.org/2/>`_ template engine for you automatically.

To render a template you can use the :func:`~flask.render_template`
method.  All you have to do is to provide the name of the template and the
variables you want to pass to the template engine as keyword arguments.
Here's a simple example of how to render a template::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask will look for templates in the `templates` folder.  So if your
application is a module, that folder is next to that module, if it's a
pacakge it's actually inside your package:

**Case 1**: a module::
    
    /application.py
    /templates
        /hello.html

**Case 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

For templates you can use the full power of Jinja2 templates.  Head over
to the `Jinja2 Template Documentation
<http://jinja.pocoo.org/2/documentation/templates>`_ for more information.

Here an example template:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello World!</h1>
    {% endif %}

Inside templates you also have access to the :class:`~flask.request`,
:class:`~flask.session` and :class:`~flask.g` [#]_ objects
as well as the :func:`~flask.get_flashed_messages` function.

Templates are especially useful if inheritance is used.  If you want to
know how that works, head over to the :ref:`template-inheritance` pattern
documentation.  Basically template inheritance makes it possible to keep
certain elements on each page (like header, navigation and footer).

Automatic escaping is enabled, so if name contains HTML it will be escaped
automatically.  If you can trust a variable and you know that it will be
safe HTML (because for example it came from a module that converts wiki
markup to HTML) you can mark it as safe by using the
:class:`~jinja2.Markup` class or by using the ``|safe`` filter in the
template.  Head over to the Jinja 2 documentation for more examples.

Here a basic introduction in how the :class:`~jinja2.Markup` class works:

>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

.. [#] Unsure what that :class:`~flask.g` object is? It's something you
   can store information on yourself, check the documentation of that
   object (:class:`~flask.g`) and the :ref:`sqlite3` for more
   information.


Accessing Request Data
----------------------

For web applications it's crucial to react to the data a client sent to
the server.  In Flask this information is provided by the global
:class:`~flask.request` object.  If you have some experience with Python
you might be wondering how that object can be global and how Flask
manages to still be threadsafe.  The answer are context locals:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

   If you want to understand how that works and how you can implement
   tests with context locals, read this section, otherwise just skip it.

Certain objects in Flask are global objects, but not just a standard
global object, but actually a proxy to an object that is local to a
specific context.  What a mouthful.  But that is actually quite easy to
understand.

Imagine the context being the handling thread.  A request comes in and the
webserver decides to spawn a new thread (or something else, the
underlying object is capable of dealing with other concurrency systems
than threads as well).  When Flask starts its internal request handling it
figures out that the current thread is the active context and binds the
current application and the WSGI environments to that context (thread).
It does that in an intelligent way that one application can invoke another
application without breaking.

So what does this mean to you?  Basically you can completely ignore that
this is the case unless you are unittesting or something different.  You
will notice that code that depends on a request object will suddenly break
because there is no request object.  The solution is creating a request
object yourself and binding it to the context.  The easiest solution for
unittesting is by using the :meth:`~flask.Flask.test_request_context`
context manager.  In combination with the `with` statement it will bind a
test request so that you can interact with it.  Here an example::

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

The other possibility is passing a whole WSGI environment to the
:meth:`~flask.Flask.request_context` method::

    from flask import request

    with app.request_context(environ):
        assert request.method == 'POST'

The Request Object
``````````````````

The request object is documented in the API section and we will not cover
it here in detail (see :class:`~flask.request`), but just mention some of
the most common operations.  First of all you have to import it from the
the `flask` module::

    from flask import request

The current request method is available by using the
:attr:`~flask.request.method` attribute.  To access form data (data
transmitted in a `POST` or `PUT` request) you can use the
:attr:`~flask.request.form` attribute.  Here a full example of the two
attributes mentioned above::

    @app.route('/login', methods=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # this is executed if the request method was GET or the
        # credentials were invalid

What happens if the key does not exist in the `form` attribute?  In that
case a special :exc:`KeyError` is raised.  You can catch it like a
standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request
error page is shown instead.  So for many situations you don't have to
deal with that problem.

To access parameters submitted in the URL (``?key=value``) you can use the
:attr:`~flask.request.args` attribute::

    searchword = request.args.get('q', '')

We recommend accessing URL parameters with `get` or by catching the
`KeyError` because users might change the URL and presenting them a 400
bad request page in that case is a bit user unfriendly.

For a full list of methods and attribtues on that object, head over to the
:class:`~flask.request` documentation.


File Uploads
````````````

Obviously you can handle uploaded files with Flask just as easy.  Just
make sure not to forget to set the ``enctype=""multipart/form-data""``
attribtue on your HTML form, otherwise the browser will not transmit your
files at all.

Uploaded files are stored in memory or at a temporary location on the
filesystem.  You can access those files by looking at the
:attr:`~flask.request.files` attribute on the request object.  Each
uploaded file is stored in that dictionary.  It behaves just like a
standard Python :class:`file` object, but it also has a
:meth:`~werkzeug.FileStorage.save` method that allows you to store that
file on the filesystem of the server.  Here a simple example how that
works::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

If you want to know how the file was named on the client before it was
uploaded to your application, you can access the
:attr:`~werkzeug.FileStorage.filename` attribute.  However please keep in
mind that this value can be forged so never ever trust that value.  If you
want to use the filename of the client to store the file on the server,
pass it through the :func:`~werkzeug.secure_filename` function that
Werkzeug provides for you::

    from flask import request
    from werkzeug import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f= request.files['the_file']
            f.save('/var/www/uploads/' + secure_filename(f.filename))
        ...

Cookies
```````

To access cookies you can use the :attr:`~flask.request.cookies`
attribute.  Again this is a dictionary with all the cookies the client
transmits.  If you want to use sessions, do not use the cookies directly
but instead use the :ref:`sessions` in Flask that add some security on top
of cookies for you.


Redirects and Errors
--------------------

To redirect a user to somewhere else you can use the
:func:`~flask.redirect` function, to abort a request early with an error
code the :func:`~flask.abort` function.  Here an example how this works::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

This is a rather pointless example because a user will be redirected from
the index to a page he cannot access (401 means access denied) but it
shows how that works.

By default a black and white error page is shown for each error code.  If
you want to customize the error page, you can use the
:meth:`~flask.Flask.errorhandler` decorator::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

Note the ``404`` after the :func:`~flask.render_template` call.  This
tells Flask that the status code of that page should be 404 which means
not found.  By default 200 is assumed which translats to: all went well.

.. _sessions:

Sessions
--------

Besides the request object there is also a second object called
:class:`~flask.session` that allows you to store information specific to a
user from one request to the next.  This is implemented on top of cookies
for you and signes the cookies cryptographically.  What this means is that
the user could look at the contents of your cookie but not modify it,
unless he knows the secret key used for signing.

In order to use sessions you have to set a secret key.  Here is how
sessions work::

    from flask import session, redirect, url_for, escape

    @app.route('/')
    def index():
        if 'username' in session:
            return 'Logged in as %s' % escape(session['username'])
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form action="""" method=""post"">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if its there
        session.pop('username', None)

    # set the secret key.  keep this really secret:
    app.secret_key = 'the secret key'

The here mentioned :func:`~flask.escape` does escaping for you if you are
not using the template engine (like in this example).

Message Flashing
----------------

Good applications and user interfaces are all about feedback.  If the user
does not get enough feedback he will probably end up hating the
application.  Flask provides a really simple way to give feedback to a
user with the flashing system.  The flashing system basically makes it
possible to record a message at the end of a request and access it next
request and only next request.  This is usually combined with a layout
template that does this.

To flash a message use the :func:`~flask.flash` method, to get hold of the
messages you can use :func:`~flask.get_flashed_messages` which is also
available in the templates.  Check out the :ref:`message-flashing-pattern`
for a full example.
","@@ -160,6 +160,8 @@ The following converters exist:
 `path`      like the default but also accepts slashes
 =========== ===========================================
 
+.. _url-building:
+
 URL Building
 ````````````
 
@@ -167,7 +169,8 @@ If it can match URLs, can it also generate them?  Of course you can.  To
 build a URL to a specific function you can use the :func:`~flask.url_for`
 function.  It accepts the name of the function as first argument and a
 number of keyword arguments, each corresponding to the variable part of
-the URL rule.  Here some examples:
+the URL rule.  Unknown variable parts are appended to the URL as query
+parameter.  Here some examples:
 
 >>> from flask import Flask, url_for
 >>> app = Flask(__name__)
@@ -184,9 +187,11 @@ the URL rule.  Here some examples:
 ...  print url_for('index')
 ...  print url_for('login')
 ...  print url_for('profile', username='John Doe')
+...  print url_for('login', next='/')
 ... 
 /
 /login
+/login?next=/
 /user/John%20Doe
 
 (This also uses the :meth:`~flask.Flask.test_request_context` method
",add more examples to url_for documentation,add more examples to url_for documentation,add more examples to url_for documentation,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
f1603d33f266ab24eda604f76632fa604b91e3f9,Docs mention query args now.  This fixes #20,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import types
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session for support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)
    def _set_permanent(self, value):
        self['_permanent'] = bool(value)
    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            from warnings import warn
            warn(Warning('View function did not return a response'),
                 stacklevel=2)
            return u''
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import types
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session for support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)
    def _set_permanent(self, value):
        self['_permanent'] = bool(value)
    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """"""
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            from warnings import warn
            warn(Warning('View function did not return a response'),
                 stacklevel=2)
            return u''
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -145,6 +145,10 @@ class _RequestContext(object):
 
 def url_for(endpoint, **values):
     """"""Generates a URL to the given endpoint with the method provided.
+    Variable arguments that are unknown to the target endpoint are appended
+    to the generated URL as query arguments.
+
+    For more information, head over to the :ref:`Quickstart <url-building>`.
 
     :param endpoint: the endpoint of the URL (name of the function)
     :param values: the variable arguments of the URL rule
",add more info to url_for,add more info to url_for,add more info to url_for,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
a9284afde97c30d136e8ec675794c7cdcf4ca277,Fixed typo in tutorial.  This fixes #19,testing.rst,"Bonus: Testing the Application
===============================

Now that you have finished the application and everything works as
expected, it's probably not the best idea to add automated tests to
simplify modifications in the future.  The application above is used as a
basic example of how to perform unittesting in the :ref:`testing` section
of the documentation.  Go there to see how easy it is to test Flask
applications.
","Bonus: Testing the Application
===============================

Now that you have finished the application and everything works as
expected, it's probably not a good idea to add automated tests to simplify
modifications in the future.  The application above is used as a basic
example of how to perform unittesting in the :ref:`testing` section of the
documentation.  Go there to see how easy it is to test Flask applications.
","@@ -2,8 +2,7 @@ Bonus: Testing the Application
 ===============================
 
 Now that you have finished the application and everything works as
-expected, it's probably not the best idea to add automated tests to
-simplify modifications in the future.  The application above is used as a
-basic example of how to perform unittesting in the :ref:`testing` section
-of the documentation.  Go there to see how easy it is to test Flask
-applications.
+expected, it's probably not a good idea to add automated tests to simplify
+modifications in the future.  The application above is used as a basic
+example of how to perform unittesting in the :ref:`testing` section of the
+documentation.  Go there to see how easy it is to test Flask applications.
",fix doc block,fix doc block,fix doc block,llm_rectified,0.0,3,True,0,0,0,0,0,0,0,0,0
8d49440d8b881b2df2c10085a58d3a4e4085147e,Added example for context bound objects to the testing docs.  This fixes #18,testing.rst,".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the file.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s

    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
",".. _testing:

Testing Flask Applications
==========================

   **Something that is untested is broken.**

Not sure where that is coming from, and it's not entirely correct, but
also not that far from the truth.  Untested applications make it hard to
improve existing code and developers of untested applications tend to
become pretty paranoid.  If an application however has automated tests, you
can safely change things and you will instantly know if your change broke
something.

Flask gives you a couple of ways to test applications.  It mainly does
that by exposing the Werkzeug test :class:`~werkzeug.Client` class to your
code and handling the context locals for you.  You can then use that with
your favourite testing solution.  In this documentation we will use the
:mod:`unittest` package that comes preinstalled with each Python
installation.

The Application
---------------

First we need an application to test for functionality.  For the testing
we will use the application from the :ref:`tutorial`.  If you don't have
that application yet, get the sources from `the examples`_.

.. _the examples:
   http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/

The Testing Skeleton
--------------------

In order to test that, we add a second module (
`flaskr_tests.py`) and create a unittest skeleton there::

    import os
    import flaskr
    import unittest
    import tempfile

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

    if __name__ == '__main__':
        unittest.main()

The code in the :meth:`~unittest.TestCase.setUp` method creates a new test
client and initializes a new database.  That function is called before
each individual test function.  To delete the database after the test, we
close the file and remove it from the filesystem in the
:meth:`~unittest.TestCase.tearDown` method.  What the test client does is
give us a simple interface to the application.  We can trigger test
requests to the application and the client will also keep track of cookies
for us.

Because SQLite3 is filesystem-based we can easily use the tempfile module
to create a temporary database and initialize it.  The
:func:`~tempfile.mkstemp` function does two things for us: it returns a
low-level file handle and a random file name, the latter we use as
database name.  We just have to keep the `db_fd` around so that we can use
the :func:`os.close` function to close the file.

If we now run that testsuite, we should see the following output::

    $ python flaskr_tests.py

    ----------------------------------------------------------------------
    Ran 0 tests in 0.000s

    OK

Even though it did not run any tests, we already know that our flaskr
application is syntactically valid, otherwise the import would have died
with an exception.

The First Test
--------------

Now we can add the first test.  Let's check that the application shows
""No entries here so far"" if we access the root of the application (``/``).
For that we modify our created test case class so that it looks like
this::

    class FlaskrTestCase(unittest.TestCase):

        def setUp(self):
            self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
            self.app = flaskr.app.test_client()
            flaskr.init_db()

        def tearDown(self):
            os.close(self.db_fd)
            os.unlink(flaskr.DATABASE)

        def test_empty_db(self):
            rv = self.app.get('/')
            assert 'No entries here so far' in rv.data

Test functions begin with the word `test`.  Every function named like that
will be picked up automatically.  By using `self.app.get` we can send an
HTTP `GET` request to the application with the given path.  The return
value will be a :class:`~flask.Flask.response_class` object.  We can now
use the :attr:`~werkzeug.BaseResponse.data` attribute to inspect the
return value (as string) from the application.  In this case, we ensure
that ``'No entries here so far'`` is part of the output.

Run it again and you should see one passing test::

    $ python flaskr_tests.py
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.034s

    OK

Of course you can submit forms with the test client as well, which we will
use now to log our user in.

Logging In and Out
------------------

The majority of the functionality of our application is only available for
the administration user.  So we need a way to log our test client in to the
application and out of it again.  For that we fire some requests to the
login and logout pages with the required form data (username and
password).  Because the login and logout pages redirect, we tell the
client to `follow_redirects`.

Add the following two methods to your `FlaskrTestCase` class::

   def login(self, username, password):
       return self.app.post('/login', data=dict(
           username=username,
           password=password
       ), follow_redirects=True)

   def logout(self):
       return self.app.get('/logout', follow_redirects=True)

Now we can easily test if logging in and out works and that it fails with
invalid credentials.  Add this new test to the class::

   def test_login_logout(self):
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
       assert 'You were logged in' in rv.data
       rv = self.logout()
       assert 'You were logged out' in rv.data
       rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
       assert 'Invalid username' in rv.data
       rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
       assert 'Invalid password' in rv.data

Test Adding Messages
--------------------

Now we can also test that adding messages works.  Add a new test method
like this::

    def test_messages(self):
        self.login(flaskr.USERNAME, flaskr.PASSWORD)
        rv = self.app.post('/add', data=dict(
            title='<Hello>',
            text='<strong>HTML</strong> allowed here'
        ), follow_redirects=True)
        assert 'No entries here so far' not in rv.data
        assert '&lt;Hello&gt' in rv.data
        assert '<strong>HTML</strong> allowed here' in rv.data

Here we check that HTML is allowed in the text but not in the title,
which is the intended behavior.

Running that should now give us three passing tests::

    $ python flaskr_tests.py 
    ...
    ----------------------------------------------------------------------
    Ran 3 tests in 0.332s
    
    OK

For more complex tests with headers and status codes, check out the
`MiniTwit Example`_ from the sources.  That one contains a larger test
suite.


.. _MiniTwit Example:
   http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/


Other Testing Tricks
--------------------

Besides using the test client we used above there is also the
:meth:`~flask.Flask.test_request_context` method that in combination with
the `with` statement can be used to activate a request context
temporarily.  With that you can access the :class:`~flask.request`,
:class:`~flask.g` and :class:`~flask.session` objects like in view
functions.  Here a full example that showcases this::

    app = flask.Flask(__name__)

    with app.test_request_context('/?name=Peter'):
        assert flask.request.path == '/'
        assert flask.request.args['name'] == 'Peter'

All the other objects that are context bound can be used the same.
","@@ -195,3 +195,22 @@ suite.
 
 .. _MiniTwit Example:
    http://github.com/mitsuhiko/flask/tree/master/examples/minitwit/
+
+
+Other Testing Tricks
+--------------------
+
+Besides using the test client we used above there is also the
+:meth:`~flask.Flask.test_request_context` method that in combination with
+the `with` statement can be used to activate a request context
+temporarily.  With that you can access the :class:`~flask.request`,
+:class:`~flask.g` and :class:`~flask.session` objects like in view
+functions.  Here a full example that showcases this::
+
+    app = flask.Flask(__name__)
+
+    with app.test_request_context('/?name=Peter'):
+        assert flask.request.path == '/'
+        assert flask.request.args['name'] == 'Peter'
+
+All the other objects that are context bound can be used the same.
",add more examples to test_applications,add more examples to test_applications,add more examples to test_applications,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
9248a7baca5bc616a60f9b63b525e872fbfddef2,None responses fail properly now.  This fixes #24,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import types
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session for support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)
    def _set_permanent(self, value):
        self['_permanent'] = bool(value)
    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    external = values.pop('_external', False)
    return _request_ctx_stack.top.url_adapter.build(endpoint, values,
                                                    force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            from warnings import warn
            warn(Warning('View function did not return a response'),
                 stacklevel=2)
            return u''
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import types
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session for support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)
    def _set_permanent(self, value):
        self['_permanent'] = bool(value)
    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    external = values.pop('_external', False)
    return _request_ctx_stack.top.url_adapter.build(endpoint, values,
                                                    force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -752,10 +752,7 @@ class Flask(object):
         :param rv: the return value from the view function
         """"""
         if rv is None:
-            from warnings import warn
-            warn(Warning('View function did not return a response'),
-                 stacklevel=2)
-            return u''
+            raise ValueError('View function did not return a response')
         if isinstance(rv, self.response_class):
             return rv
         if isinstance(rv, basestring):
",add more info to the view function,add more info to the view function,add more info to the view function,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
67fc46526234653b0a519e9f1e8a05a2c40c80f8,"Fix typo, remove useless import, limit lines to 79 columns.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session for support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)
    def _set_permanent(self, value):
        self['_permanent'] = bool(value)
    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    external = values.pop('_external', False)
    return _request_ctx_stack.top.url_adapter.build(endpoint, values,
                                                    force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without arguments
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = None

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    external = values.pop('_external', False)
    return _request_ctx_stack.top.url_adapter.build(endpoint, values,
                                                    force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class Flask(object):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, package_name):
        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.package_name = package_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.package_name)

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a list of functions that should be called at the beginning
        #: of the request before request dispatching kicks in.  This
        #: can for example be used to open database connections or
        #: getting hold of the currently logged in user.
        #: To register a function here, use the :meth:`before_request`
        #: decorator.
        self.before_request_funcs = []

        #: a list of functions that are called at the end of the
        #: request.  The function is passed the current response
        #: object and modify it in place or replace it.
        #: To register a function here use the :meth:`after_request`
        #: decorator.
        self.after_request_funcs = []

        #: a list of functions that are called without argument
        #: to populate the template context.  Each returns a dictionary
        #: that the template context is updated with.
        #: To register a function here, use the :meth:`context_processor`
        #: decorator.
        self.template_context_processors = [_default_template_ctx_processor]

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.package_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.package_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        for func in self.template_context_processors:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors.append(f)
        return f

    def match_request(self):
        """"""Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """"""
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        for func in self.before_request_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        session = _request_ctx_stack.top.session
        if not isinstance(session, _NullSession):
            self.save_session(session, response)
        for handler in self.after_request_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -87,14 +87,16 @@ class _RequestGlobals(object):
 
 
 class Session(SecureCookie):
-    """"""Expands the session for support for switching between permanent
+    """"""Expands the session with support for switching between permanent
     and non-permanent sessions.
     """"""
 
     def _get_permanent(self):
         return self.get('_permanent', False)
+
     def _set_permanent(self, value):
         self['_permanent'] = bool(value)
+
     permanent = property(_get_permanent, _set_permanent)
     del _get_permanent, _set_permanent
 
@@ -391,7 +393,7 @@ class Flask(object):
         #: decorator.
         self.after_request_funcs = []
 
-        #: a list of functions that are called without arguments
+        #: a list of functions that are called without argument
         #: to populate the template context.  Each returns a dictionary
         #: that the template context is updated with.
         #: To register a function here, use the :meth:`context_processor`
",add more documentation to simplejson,add more documentation to simplejson,add more documentation to simplejson,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
67fc46526234653b0a519e9f1e8a05a2c40c80f8,"Fix typo, remove useless import, limit lines to 79 columns.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
import warnings
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1/0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                return ','.join(super(ListConverter, self).to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = flask.render_template_string('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1 // 0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                base_to_url = super(ListConverter, self).to_url
                return ','.join(base_to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        render = flask.render_template_string
        with app.test_request_context():
            rv = render('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = render('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","@@ -16,7 +16,6 @@ import sys
 import flask
 import unittest
 import tempfile
-import warnings
 from datetime import datetime
 from werkzeug import parse_date
 
@@ -61,7 +60,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):
         assert sorted(rv.allow) == ['GET', 'HEAD']
         rv = c.head('/')
         assert rv.status_code == 200
-        assert not rv.data # head truncates
+        assert not rv.data  # head truncates
         assert c.post('/more').data == 'POST'
         assert c.get('/more').data == 'GET'
         rv = c.delete('/more')
@@ -85,7 +84,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):
         assert sorted(rv.allow) == ['GET', 'HEAD']
         rv = c.head('/')
         assert rv.status_code == 200
-        assert not rv.data # head truncates
+        assert not rv.data  # head truncates
         assert c.post('/more').data == 'POST'
         assert c.get('/more').data == 'GET'
         rv = c.delete('/more')
@@ -191,7 +190,7 @@ class BasicFunctionalityTestCase(unittest.TestCase):
             flask.abort(404)
         @app.route('/error')
         def error():
-            1/0
+            1 // 0
         c = app.test_client()
         rv = c.get('/')
         assert rv.status_code == 404
@@ -236,7 +235,8 @@ class BasicFunctionalityTestCase(unittest.TestCase):
             def to_python(self, value):
                 return value.split(',')
             def to_url(self, value):
-                return ','.join(super(ListConverter, self).to_url(x) for x in value)
+                base_to_url = super(ListConverter, self).to_url
+                return ','.join(base_to_url(x) for x in value)
         app = flask.Flask(__name__)
         app.url_map.converters['list'] = ListConverter
         @app.route('/<list:args>')
@@ -297,10 +297,11 @@ class JSONTestCase(unittest.TestCase):
 
     def test_template_escaping(self):
         app = flask.Flask(__name__)
+        render = flask.render_template_string
         with app.test_request_context():
-            rv = flask.render_template_string('{{ ""</script>""|tojson|safe }}')
+            rv = render('{{ ""</script>""|tojson|safe }}')
             assert rv == '""<\\/script>""'
-            rv = flask.render_template_string('{{ ""<\0/script>""|tojson|safe }}')
+            rv = render('{{ ""<\0/script>""|tojson|safe }}')
             assert rv == '""<\\u0000\\/script>""'
 
 
",add tests for list converter,add tests for list converter,add tests for list converter,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
a921aef6c47cecbacef5173f03c07c52e6bc8fea,Fixed late binding of url_prefix.  This fixes #29.,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if self.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if state.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -448,7 +448,7 @@ class Module(_PackageBoundObject):
         """"""
         def register_rule(state):
             the_rule = rule
-            if self.url_prefix:
+            if state.url_prefix:
                 the_rule = state.url_prefix + rule
             state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                    view_func, **options)
",add more info to module.py,add more info to module.py,add more info to module.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
a921aef6c47cecbacef5173f03c07c52e6bc8fea,Fixed late binding of url_prefix.  This fixes #29.,flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1 // 0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                base_to_url = super(ListConverter, self).to_url
                return ','.join(base_to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        render = flask.render_template_string
        with app.test_request_context():
            rv = render('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = render('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


class ModuleTestCase(unittest.TestCase):

    def test_basic_module(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.route('/')
        def index():
            return 'admin index'
        @admin.route('/login')
        def login():
            return 'admin login'
        @admin.route('/logout')
        def logout():
            return 'admin logout'
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()
        assert c.get('/').data == 'the index'
        assert c.get('/admin/').data == 'admin index'
        assert c.get('/admin/login').data == 'admin login'
        assert c.get('/admin/logout').data == 'admin logout'

    def test_request_processing(self):
        catched = []
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.before_request
        def before_admin_request():
            catched.append('before-admin')
        @admin.after_request
        def after_admin_request(response):
            catched.append('after-admin')
            return response
        @admin.route('/')
        def index():
            return 'the admin'
        @app.before_request
        def before_request():
            catched.append('before-app')
        @app.after_request
        def after_request(response):
            catched.append('after-app')
            return response
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()

        assert c.get('/').data == 'the index'
        assert catched == ['before-app', 'after-app']
        del catched[:]

        assert c.get('/admin/').data == 'the admin'
        assert catched == ['before-app', 'before-admin',
                           'after-admin', 'after-app']


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    suite.addTest(unittest.makeSuite(ModuleTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1 // 0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                base_to_url = super(ListConverter, self).to_url
                return ','.join(base_to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        render = flask.render_template_string
        with app.test_request_context():
            rv = render('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = render('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


class ModuleTestCase(unittest.TestCase):

    def test_basic_module(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.route('/')
        def index():
            return 'admin index'
        @admin.route('/login')
        def login():
            return 'admin login'
        @admin.route('/logout')
        def logout():
            return 'admin logout'
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()
        assert c.get('/').data == 'the index'
        assert c.get('/admin/').data == 'admin index'
        assert c.get('/admin/login').data == 'admin login'
        assert c.get('/admin/logout').data == 'admin logout'

    def test_request_processing(self):
        catched = []
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.before_request
        def before_admin_request():
            catched.append('before-admin')
        @admin.after_request
        def after_admin_request(response):
            catched.append('after-admin')
            return response
        @admin.route('/')
        def index():
            return 'the admin'
        @app.before_request
        def before_request():
            catched.append('before-app')
        @app.after_request
        def after_request(response):
            catched.append('after-app')
            return response
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()

        assert c.get('/').data == 'the index'
        assert catched == ['before-app', 'after-app']
        del catched[:]

        assert c.get('/admin/').data == 'the admin'
        assert catched == ['before-app', 'before-admin',
                           'after-admin', 'after-app']

    def test_late_binding(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin')
        @admin.route('/')
        def index():
            return '42'
        app.register_module(admin, url_prefix='/admin')
        assert app.test_client().get('/admin/').data == '42'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    suite.addTest(unittest.makeSuite(ModuleTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","@@ -441,6 +441,15 @@ class ModuleTestCase(unittest.TestCase):
         assert catched == ['before-app', 'before-admin',
                            'after-admin', 'after-app']
 
+    def test_late_binding(self):
+        app = flask.Flask(__name__)
+        admin = flask.Module(__name__, 'admin')
+        @admin.route('/')
+        def index():
+            return '42'
+        app.register_module(admin, url_prefix='/admin')
+        assert app.test_client().get('/admin/').data == '42'
+
 
 def suite():
     from minitwit_tests import MiniTwitTestCase
",add unit tests for context and module,add unit tests for context and module,add unit tests for context and module,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
f6da77e894a939b838e02fb744fa3031abfc96ec,Fixed URL examples.  This fixes #30.,api.rst,".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `url`         ``http://www.example.com/myapplication/page.html``
      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
      `url_root`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True

    .. attribute:: permanent

       If set to `True` the session life for
       :attr:`~flask.Flask.permanent_session_lifetime` seconds.  The
       default is 31 days.  If set to `False` (which is the default) the
       session will be deleted when the user closes the browser.


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g

   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

    Note that the ``|tojson`` filter escapes forward slashes properly.

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
",".. _api:

API
===

.. module:: flask

This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.


Application Object
------------------

.. autoclass:: Flask
   :members:

Incoming Request Data
---------------------

.. autoclass:: Request

.. class:: request

   To access incoming request data, you can use the global `request`
   object.  Flask parses incoming request data for you and gives you
   access to it through that global object.  Internally Flask makes
   sure that you always get the correct data for the active thread if you
   are in a multithreaded environment.

   The request object is an instance of a :class:`~werkzeug.Request`
   subclass and provides all of the attributes Werkzeug defines.  This
   just shows a quick overview of the most important ones.

   .. attribute:: form

      A :class:`~werkzeug.MultiDict` with the parsed form data from `POST`
      or `PUT` requests.  Please keep in mind that file uploads will not
      end up here,  but instead in the :attr:`files` attribute.

   .. attribute:: args

      A :class:`~werkzeug.MultiDict` with the parsed contents of the query
      string.  (The part in the URL after the question mark).

   .. attribute:: values

      A :class:`~werkzeug.CombinedMultiDict` with the contents of both
      :attr:`form` and :attr:`args`.

   .. attribute:: cookies

      A :class:`dict` with the contents of all cookies transmitted with
      the request.

   .. attribute:: stream

      If the incoming form data was not encoded with a known mimetype
      the data is stored unmodified in this stream for consumption.  Most
      of the time it is a better idea to use :attr:`data` which will give
      you that data as a string.  The stream only returns the data once.
      
   .. attribute:: data

      Contains the incoming request data as string in case it came with
      a mimetype Flask does not handle.

   .. attribute:: files

      A :class:`~werkzeug.MultiDict` with files uploaded as part of a
      `POST` or `PUT` request.  Each file is stored as
      :class:`~werkzeug.FileStorage` object.  It basically behaves like a
      standard file object you know from Python, with the difference that
      it also has a :meth:`~werkzeug.FileStorage.save` function that can
      store the file on the filesystem.

   .. attribute:: environ

      The underlying WSGI environment.

   .. attribute:: method

      The current request method (``POST``, ``GET`` etc.)

   .. attribute:: path
   .. attribute:: script_root
   .. attribute:: url
   .. attribute:: base_url
   .. attribute:: url_root

      Provides different ways to look at the current URL.  Imagine your
      application is listening on the following URL::

          http://www.example.com/myapplication

      And a user requests the following URL::

          http://www.example.com/myapplication/page.html?x=y

      In this case the values of the above mentioned attributes would be
      the following:

      ============= ======================================================
      `path`        ``/page.html``
      `script_root` ``/myapplication``
      `base_url`    ``http://www.example.com/myapplication/page.html``
      `url`         ``http://www.example.com/myapplication/page.html?x=y``
      `url_root`    ``http://www.example.com/myapplication/``
      ============= ======================================================

   .. attribute:: is_xhr

      `True` if the request was triggered via a JavaScript
      `XMLHttpRequest`. This only works with libraries that support the
      ``X-Requested-With`` header and set it to `XMLHttpRequest`.
      Libraries that do that are prototype, jQuery and Mochikit and
      probably some more.

   .. attribute:: json

      Contains the parsed body of the JSON request if the mimetype of
      the incoming data was `application/json`.  This requires Python 2.6
      or an installed version of simplejson.

Response Objects
----------------

.. autoclass:: flask.Response
   :members: set_cookie, data, mimetype

   .. attribute:: headers

      A :class:`Headers` object representing the response headers.

   .. attribute:: status_code

      The response status as integer.


Sessions
--------

If you have the :attr:`Flask.secret_key` set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.

To access the current session you can use the :class:`session` object:

.. class:: session

   The session object works pretty much like an ordinary dict, with the
   difference that it keeps track on modifications.

   The following attributes are interesting:

   .. attribute:: new

      `True` if the session is new, `False` otherwise.

   .. attribute:: modified

      `True` if the session object detected a modification.  Be advised
      that modifications on mutable structures are not picked up
      automatically, in that situation you have to explicitly set the
      attribute to `True` yourself.  Here an example::

          # this change is not picked up because a mutable object (here
          # a list) is changed.
          session['objects'].append(42)
          # so mark it as modified yourself
          session.modified = True

    .. attribute:: permanent

       If set to `True` the session life for
       :attr:`~flask.Flask.permanent_session_lifetime` seconds.  The
       default is 31 days.  If set to `False` (which is the default) the
       session will be deleted when the user closes the browser.


Application Globals
-------------------

To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for :class:`request` and :class:`session`.

.. data:: g

   Just store on this whatever you want.  For example a database
   connection or the user that is currently logged in.


Useful Functions and Classes
----------------------------

.. autofunction:: url_for

.. function:: abort(code)

   Raises an :exc:`~werkzeug.exception.HTTPException` for the given
   status code.  For example to abort request handling with a page not
   found exception, you would call ``abort(404)``.

   :param code: the HTTP error code.

.. autofunction:: redirect

.. autofunction:: escape

.. autoclass:: Markup
   :members: escape, unescape, striptags

Message Flashing
----------------

.. autofunction:: flash

.. autofunction:: get_flashed_messages

Returning JSON
--------------

.. autofunction:: jsonify

.. data:: json

    If JSON support is picked up, this will be the module that Flask is
    using to parse and serialize JSON.  So instead of doing this yourself::

        try:
            import simplejson as json
        except ImportError:
            import json

    You can instead just do this::

        from flask import json

    For usage examples, read the :mod:`json` documentation.

    The :func:`~json.dumps` function of this json module is also available
    as filter called ``|tojson`` in Jinja2.  Note that inside `script`
    tags no escaping must take place, so make sure to disable escaping
    with ``|safe`` if you intend to use it inside `script` tags:

    .. sourcecode:: html+jinja

        <script type=text/javascript>
            doSomethingWith({{ user.username|tojson|safe }});
        </script>

    Note that the ``|tojson`` filter escapes forward slashes properly.

Template Rendering
------------------

.. autofunction:: render_template

.. autofunction:: render_template_string

.. autofunction:: get_template_attribute
","@@ -104,8 +104,8 @@ Incoming Request Data
       ============= ======================================================
       `path`        ``/page.html``
       `script_root` ``/myapplication``
-      `url`         ``http://www.example.com/myapplication/page.html``
-      `base_url`    ``http://www.example.com/myapplication/page.html?x=y``
+      `base_url`    ``http://www.example.com/myapplication/page.html``
+      `url`         ``http://www.example.com/myapplication/page.html?x=y``
       `url_root`    ``http://www.example.com/myapplication/``
       ============= ======================================================
 
",add missing documentation to request object,add missing documentation to request object,add missing documentation to request object,llm_rectified,0.0,6,False,0,0,0,0,0,0,0,0,0
745638e774063de206aae930df71789de13e7c73,"Added missing decorators for module wide context processors.

This fixes #25.",flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if state.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if state.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request, even if outside of a module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a modul.  This
        function is only executed for requests handled by a module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(self.name, []).append(f))
        return f

    def app_context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a module.  Such a
        function is executed each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -465,7 +465,7 @@ class Module(_PackageBoundObject):
 
     def before_app_request(self, f):
         """"""Like :meth:`Flask.before_request`.  Such a function is executed
-        before each request.
+        before each request, even if outside of a module.
         """"""
         self._record(lambda s: s.app.before_request_funcs
             .setdefault(None, []).append(f))
@@ -482,12 +482,28 @@ class Module(_PackageBoundObject):
 
     def after_app_request(self, f):
         """"""Like :meth:`Flask.after_request` but for a module.  Such a function
-        is executed after each request.
+        is executed after each request, even if outside of the module.
         """"""
         self._record(lambda s: s.app.after_request_funcs
             .setdefault(None, []).append(f))
         return f
 
+    def context_processor(self, f):
+        """"""Like :meth:`Flask.context_processor` but for a modul.  This
+        function is only executed for requests handled by a module.
+        """"""
+        self._record(lambda s: s.app.template_context_processors
+            .setdefault(self.name, []).append(f))
+        return f
+
+    def app_context_processor(self, f):
+        """"""Like :meth:`Flask.context_processor` but for a module.  Such a
+        function is executed each request, even if outside of the module.
+        """"""
+        self._record(lambda s: s.app.template_context_processors
+            .setdefault(None, []).append(f))
+        return f
+
     def _record(self, func):
         self._register_events.append(func)
 
",add more documentation to module.py,add more documentation to module.py,add more documentation to module.py,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
745638e774063de206aae930df71789de13e7c73,"Added missing decorators for module wide context processors.

This fixes #25.",flask_tests.py,"# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1 // 0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                base_to_url = super(ListConverter, self).to_url
                return ','.join(base_to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        render = flask.render_template_string
        with app.test_request_context():
            rv = render('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = render('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


class ModuleTestCase(unittest.TestCase):

    def test_basic_module(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.route('/')
        def index():
            return 'admin index'
        @admin.route('/login')
        def login():
            return 'admin login'
        @admin.route('/logout')
        def logout():
            return 'admin logout'
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()
        assert c.get('/').data == 'the index'
        assert c.get('/admin/').data == 'admin index'
        assert c.get('/admin/login').data == 'admin login'
        assert c.get('/admin/logout').data == 'admin logout'

    def test_request_processing(self):
        catched = []
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.before_request
        def before_admin_request():
            catched.append('before-admin')
        @admin.after_request
        def after_admin_request(response):
            catched.append('after-admin')
            return response
        @admin.route('/')
        def index():
            return 'the admin'
        @app.before_request
        def before_request():
            catched.append('before-app')
        @app.after_request
        def after_request(response):
            catched.append('after-app')
            return response
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()

        assert c.get('/').data == 'the index'
        assert catched == ['before-app', 'after-app']
        del catched[:]

        assert c.get('/admin/').data == 'the admin'
        assert catched == ['before-app', 'before-admin',
                           'after-admin', 'after-app']

    def test_late_binding(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin')
        @admin.route('/')
        def index():
            return '42'
        app.register_module(admin, url_prefix='/admin')
        assert app.test_client().get('/admin/').data == '42'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    suite.addTest(unittest.makeSuite(ModuleTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","# -*- coding: utf-8 -*-
""""""
    Flask Tests
    ~~~~~~~~~~~

    Tests Flask itself.  The majority of Flask is already tested
    as part of Werkzeug.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import re
import sys
import flask
import unittest
import tempfile
from datetime import datetime
from werkzeug import parse_date


example_path = os.path.join(os.path.dirname(__file__), '..', 'examples')
sys.path.append(os.path.join(example_path, 'flaskr'))
sys.path.append(os.path.join(example_path, 'minitwit'))


class ContextTestCase(unittest.TestCase):

    def test_context_binding(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return 'Hello %s!' % flask.request.args['name']
        @app.route('/meh')
        def meh():
            return flask.request.url

        with app.test_request_context('/?name=World'):
            assert index() == 'Hello World!'
        with app.test_request_context('/meh'):
            assert meh() == 'http://localhost/meh'


class BasicFunctionalityTestCase(unittest.TestCase):

    def test_request_dispatching(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.request.method
        @app.route('/more', methods=['GET', 'POST'])
        def more():
            return flask.request.method

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_url_mapping(self):
        app = flask.Flask(__name__)
        def index():
            return flask.request.method
        def more():
            return flask.request.method

        app.add_url_rule('/', 'index', index)
        app.add_url_rule('/more', 'more', more, methods=['GET', 'POST'])

        c = app.test_client()
        assert c.get('/').data == 'GET'
        rv = c.post('/')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD']
        rv = c.head('/')
        assert rv.status_code == 200
        assert not rv.data  # head truncates
        assert c.post('/more').data == 'POST'
        assert c.get('/more').data == 'GET'
        rv = c.delete('/more')
        assert rv.status_code == 405
        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']

    def test_session(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/set', methods=['POST'])
        def set():
            flask.session['value'] = flask.request.form['value']
            return 'value set'
        @app.route('/get')
        def get():
            return flask.session['value']

        c = app.test_client()
        assert c.post('/set', data={'value': '42'}).data == 'value set'
        assert c.get('/get').data == '42'

    def test_missing_session(self):
        app = flask.Flask(__name__)
        def expect_exception(f, *args, **kwargs):
            try:
                f(*args, **kwargs)
            except RuntimeError, e:
                assert e.args and 'session is unavailable' in e.args[0]
            else:
                assert False, 'expected exception'
        with app.test_request_context():
            assert flask.session.get('missing_key') is None
            expect_exception(flask.session.__setitem__, 'foo', 42)
            expect_exception(flask.session.pop, 'foo')

    def test_session_expiration(self):
        permanent = True
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'
        @app.route('/')
        def index():
            flask.session['test'] = 42
            flask.session.permanent = permanent
            return ''
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        expires = parse_date(match.group())
        expected = datetime.utcnow() + app.permanent_session_lifetime
        assert expires.year == expected.year
        assert expires.month == expected.month
        assert expires.day == expected.day

        permanent = False
        rv = app.test_client().get('/')
        assert 'set-cookie' in rv.headers
        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
        assert match is None

    def test_flashes(self):
        app = flask.Flask(__name__)
        app.secret_key = 'testkey'

        with app.test_request_context():
            assert not flask.session.modified
            flask.flash('Zap')
            flask.session.modified = False
            flask.flash('Zip')
            assert flask.session.modified
            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

    def test_request_processing(self):
        app = flask.Flask(__name__)
        evts = []
        @app.before_request
        def before_request():
            evts.append('before')
        @app.after_request
        def after_request(response):
            response.data += '|after'
            evts.append('after')
            return response
        @app.route('/')
        def index():
            assert 'before' in evts
            assert 'after' not in evts
            return 'request'
        assert 'after' not in evts
        rv = app.test_client().get('/').data
        assert 'after' in evts
        assert rv == 'request|after'

    def test_error_handling(self):
        app = flask.Flask(__name__)
        @app.errorhandler(404)
        def not_found(e):
            return 'not found', 404
        @app.errorhandler(500)
        def internal_server_error(e):
            return 'internal server error', 500
        @app.route('/')
        def index():
            flask.abort(404)
        @app.route('/error')
        def error():
            1 // 0
        c = app.test_client()
        rv = c.get('/')
        assert rv.status_code == 404
        assert rv.data == 'not found'
        rv = c.get('/error')
        assert rv.status_code == 500
        assert 'internal server error' in rv.data

    def test_response_creation(self):
        app = flask.Flask(__name__)
        @app.route('/unicode')
        def from_unicode():
            return u'Hällo Wörld'
        @app.route('/string')
        def from_string():
            return u'Hällo Wörld'.encode('utf-8')
        @app.route('/args')
        def from_tuple():
            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
        c = app.test_client()
        assert c.get('/unicode').data == u'Hällo Wörld'.encode('utf-8')
        assert c.get('/string').data == u'Hällo Wörld'.encode('utf-8')
        rv = c.get('/args')
        assert rv.data == 'Meh'
        assert rv.headers['X-Foo'] == 'Testing'
        assert rv.status_code == 400
        assert rv.mimetype == 'text/plain'

    def test_url_generation(self):
        app = flask.Flask(__name__)
        @app.route('/hello/<name>', methods=['POST'])
        def hello():
            pass
        with app.test_request_context():
            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
            assert flask.url_for('hello', name='test x', _external=True) \
                == 'http://localhost/hello/test%20x'

    def test_custom_converters(self):
        from werkzeug.routing import BaseConverter
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(',')
            def to_url(self, value):
                base_to_url = super(ListConverter, self).to_url
                return ','.join(base_to_url(x) for x in value)
        app = flask.Flask(__name__)
        app.url_map.converters['list'] = ListConverter
        @app.route('/<list:args>')
        def index(args):
            return '|'.join(args)
        c = app.test_client()
        assert c.get('/1,2,3').data == '1|2|3'

    def test_static_files(self):
        app = flask.Flask(__name__)
        rv = app.test_client().get('/static/index.html')
        assert rv.status_code == 200
        assert rv.data.strip() == '<h1>Hello World!</h1>'
        with app.test_request_context():
            assert flask.url_for('static', filename='index.html') \
                == '/static/index.html'

    def test_none_response(self):
        app = flask.Flask(__name__)
        @app.route('/')
        def test():
            return None
        try:
            app.test_client().get('/')
        except ValueError, e:
            assert str(e) == 'View function did not return a response'
            pass
        else:
            assert ""Expected ValueError""


class JSONTestCase(unittest.TestCase):

    def test_jsonify(self):
        d = dict(a=23, b=42, c=[1, 2, 3])
        app = flask.Flask(__name__)
        @app.route('/kw')
        def return_kwargs():
            return flask.jsonify(**d)
        @app.route('/dict')
        def return_dict():
            return flask.jsonify(d)
        c = app.test_client()
        for url in '/kw', '/dict':
            rv = c.get(url)
            assert rv.mimetype == 'application/json'
            assert flask.json.loads(rv.data) == d

    def test_json_attr(self):
        app = flask.Flask(__name__)
        @app.route('/add', methods=['POST'])
        def add():
            return unicode(flask.request.json['a'] + flask.request.json['b'])
        c = app.test_client()
        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
                            content_type='application/json')
        assert rv.data == '3'

    def test_template_escaping(self):
        app = flask.Flask(__name__)
        render = flask.render_template_string
        with app.test_request_context():
            rv = render('{{ ""</script>""|tojson|safe }}')
            assert rv == '""<\\/script>""'
            rv = render('{{ ""<\0/script>""|tojson|safe }}')
            assert rv == '""<\\u0000\\/script>""'


class TemplatingTestCase(unittest.TestCase):

    def test_context_processing(self):
        app = flask.Flask(__name__)
        @app.context_processor
        def context_processor():
            return {'injected_value': 42}
        @app.route('/')
        def index():
            return flask.render_template('context_template.html', value=23)
        rv = app.test_client().get('/')
        assert rv.data == '<p>23|42'

    def test_escaping(self):
        text = '<p>Hello World!'
        app = flask.Flask(__name__)
        @app.route('/')
        def index():
            return flask.render_template('escaping_template.html', text=text,
                                         html=flask.Markup(text))
        lines = app.test_client().get('/').data.splitlines()
        assert lines == [
            '&lt;p&gt;Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '<p>Hello World!',
            '&lt;p&gt;Hello World!',
            '<p>Hello World!'
        ]

    def test_macros(self):
        app = flask.Flask(__name__)
        with app.test_request_context():
            macro = flask.get_template_attribute('_macro.html', 'hello')
            assert macro('World') == 'Hello World!'

    def test_template_filter(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def my_reverse(s):
            return s[::-1]
        assert 'my_reverse' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['my_reverse'] == my_reverse
        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

    def test_template_filter_with_name(self):
        app = flask.Flask(__name__)
        @app.template_filter('strrev')
        def my_reverse(s):
            return s[::-1]
        assert 'strrev' in  app.jinja_env.filters.keys()
        assert app.jinja_env.filters['strrev'] == my_reverse
        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

    def test_template_filter_with_template(self):
        app = flask.Flask(__name__)
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'

    def test_template_filter_with_name_and_template(self):
        app = flask.Flask(__name__)
        @app.template_filter('super_reverse')
        def my_reverse(s):
            return s[::-1]
        @app.route('/')
        def index():
            return flask.render_template('template_filter.html', value='abcd')
        rv = app.test_client().get('/')
        assert rv.data == 'dcba'


class ModuleTestCase(unittest.TestCase):

    def test_basic_module(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.route('/')
        def index():
            return 'admin index'
        @admin.route('/login')
        def login():
            return 'admin login'
        @admin.route('/logout')
        def logout():
            return 'admin logout'
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()
        assert c.get('/').data == 'the index'
        assert c.get('/admin/').data == 'admin index'
        assert c.get('/admin/login').data == 'admin login'
        assert c.get('/admin/logout').data == 'admin logout'

    def test_request_processing(self):
        catched = []
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @admin.before_request
        def before_admin_request():
            catched.append('before-admin')
        @admin.after_request
        def after_admin_request(response):
            catched.append('after-admin')
            return response
        @admin.route('/')
        def index():
            return 'the admin'
        @app.before_request
        def before_request():
            catched.append('before-app')
        @app.after_request
        def after_request(response):
            catched.append('after-app')
            return response
        @app.route('/')
        def index():
            return 'the index'
        app.register_module(admin)
        c = app.test_client()

        assert c.get('/').data == 'the index'
        assert catched == ['before-app', 'after-app']
        del catched[:]

        assert c.get('/admin/').data == 'the admin'
        assert catched == ['before-app', 'before-admin',
                           'after-admin', 'after-app']

    def test_context_processors(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
        @app.context_processor
        def inject_all_regualr():
            return {'a': 1}
        @admin.context_processor
        def inject_admin():
            return {'b': 2}
        @admin.app_context_processor
        def inject_all_module():
            return {'c': 3}
        @app.route('/')
        def index():
            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')
        @admin.route('/')
        def index():
            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')
        app.register_module(admin)
        c = app.test_client()
        assert c.get('/').data == '13'
        assert c.get('/admin/').data == '123'

    def test_late_binding(self):
        app = flask.Flask(__name__)
        admin = flask.Module(__name__, 'admin')
        @admin.route('/')
        def index():
            return '42'
        app.register_module(admin, url_prefix='/admin')
        assert app.test_client().get('/admin/').data == '42'


def suite():
    from minitwit_tests import MiniTwitTestCase
    from flaskr_tests import FlaskrTestCase
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ContextTestCase))
    suite.addTest(unittest.makeSuite(BasicFunctionalityTestCase))
    suite.addTest(unittest.makeSuite(TemplatingTestCase))
    if flask.json_available:
        suite.addTest(unittest.makeSuite(JSONTestCase))
    suite.addTest(unittest.makeSuite(MiniTwitTestCase))
    suite.addTest(unittest.makeSuite(FlaskrTestCase))
    suite.addTest(unittest.makeSuite(ModuleTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')
","@@ -441,6 +441,29 @@ class ModuleTestCase(unittest.TestCase):
         assert catched == ['before-app', 'before-admin',
                            'after-admin', 'after-app']
 
+    def test_context_processors(self):
+        app = flask.Flask(__name__)
+        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
+        @app.context_processor
+        def inject_all_regualr():
+            return {'a': 1}
+        @admin.context_processor
+        def inject_admin():
+            return {'b': 2}
+        @admin.app_context_processor
+        def inject_all_module():
+            return {'c': 3}
+        @app.route('/')
+        def index():
+            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')
+        @admin.route('/')
+        def index():
+            return flask.render_template_string('{{ a }}{{ b }}{{ c }}')
+        app.register_module(admin)
+        c = app.test_client()
+        assert c.get('/').data == '13'
+        assert c.get('/admin/').data == '123'
+
     def test_late_binding(self):
         app = flask.Flask(__name__)
         admin = flask.Module(__name__, 'admin')
",add tests for module example,add tests for module example,add tests for module example,llm_rectified,0.0,5,False,0,0,0,0,0,0,0,0,0
e409bc792d4419ed588afbc60c53b61923c415a7,Fixed typo,flask.py,"# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import mimetypes
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property, wrap_file, Headers
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def send_file(filename_or_fp, mimetype=None, as_attachment=False,
              attachment_filename=None):
    """"""Sends the contents of a file to the client.  This will use the
    most efficient method available and configured.  By default it will
    try to use the WSGI server's file_wrapper support.  Alternatively
    you can set the application's :attr:`~Flask.use_x_sendfile` attribute
    to ``True`` to directly emit an `X-Sendfile` header.  This however
    requires support of the underlying webserver for `X-Sendfile`.

    By default it will try to guess the mimetype for you, but you can
    also explicitly provide one.  For extra security you probably want
    to sent certain files as attachment (HTML for instance).

    Please never pass filenames to this function from user sources without
    checking them first.  Something like this is usually sufficient to
    avoid security problems::

        if '..' in filename or filename.startswith('/'):
            abort(404)

    .. versionadded:: 0.2

    :param filename_or_fp: the filename of the file to send.  This is
                           relative to the :attr:`~Flask.root_path` if a
                           relative path is specified.
                           Alternatively a file object might be provided
                           in which case `X-Sendfile` might not work and
                           fall back to the traditional method.
    :param mimetype: the mimetype of the file if provided, otherwise
                     auto detection happens.
    :param as_attachment: set to `True` if you want to send this file with
                          a ``Content-Disposition: attachment`` header.
    :param attachment_filename: the filename for the attachment if it
                                differs from the file's filename.
    """"""
    if isinstance(filename_or_fp, basestring):
        filename = filename_or_fp
        file = None
    else:
        file = filename_or_fp
        filename = getattr(file, 'name', None)
    if filename is not None:
        filename = os.path.join(current_app.root_path, filename)
    if mimetype is None and (filename or attachment_filename):
        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]
    if mimetype is None:
        mimetype = 'application/octet-stream'

    headers = Headers()
    if as_attachment:
        if attachment_filename is None:
            if filename is None:
                raise TypeError('filename unavailable, required for '
                                'sending as attachment')
            attachment_filename = os.path.basename(filename)
        headers.add('Content-Disposition', 'attachment',
                    filename=attachment_filename)

    if current_app.use_x_sendfile and filename:
        if file is not None:
            file.close()
        headers['X-Sendfile'] = filename
        data = None
    else:
        if file is None:
            file = open(filename, 'rb')
        data = wrap_file(request.environ, file)

    return Response(data, mimetype=mimetype, headers=headers,
                    direct_passthrough=True)


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if state.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request, even if outside of a module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a modul.  This
        function is only executed for requests handled by a module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(self.name, []).append(f))
        return f

    def app_context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a module.  Such a
        function is executed each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: Enable this if you want to use the X-Sendfile feature.  Keep in
    #: mind that the server has to support this.  This only affects files
    #: sent with the :func:`send_file` method.
    #:
    #: .. versionadded:: 0.2
    use_x_sendfile = False

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :params environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","# -*- coding: utf-8 -*-
""""""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
""""""
from __future__ import with_statement
import os
import sys
import mimetypes
from datetime import datetime, timedelta

from itertools import chain
from jinja2 import Environment, PackageLoader, FileSystemLoader
from werkzeug import Request as RequestBase, Response as ResponseBase, \
     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
     ImmutableDict, cached_property, wrap_file, Headers
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException
from werkzeug.contrib.securecookie import SecureCookie

# try to load the best simplejson implementation available.  If JSON
# is not installed, we add a failing class.
json_available = True
try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json_available = False

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect
from jinja2 import Markup, escape

# use pkg_resource if that works, otherwise fall back to cwd.  The
# current working directory is generally not reliable with the notable
# exception of google appengine.
try:
    import pkg_resources
    pkg_resources.resource_stream
except (ImportError, AttributeError):
    pkg_resources = None


class Request(RequestBase):
    """"""The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.

    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    """"""

    endpoint = view_args = routing_exception = None

    @property
    def module(self):
        """"""The name of the current module""""""
        if self.endpoint and '.' in self.endpoint:
            return self.endpoint.rsplit('.', 1)[0]

    @cached_property
    def json(self):
        """"""If the mimetype is `application/json` this will contain the
        parsed JSON data.
        """"""
        if __debug__:
            _assert_have_json()
        if self.mimetype == 'application/json':
            return json.loads(self.data)


class Response(ResponseBase):
    """"""The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.  Quite often you don't have to create this object yourself because
    :meth:`~flask.Flask.make_response` will take care of that for you.

    If you want to replace the response object used you can subclass this and
    set :attr:`~flask.Flask.request_class` to your subclass.
    """"""
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class Session(SecureCookie):
    """"""Expands the session with support for switching between permanent
    and non-permanent sessions.
    """"""

    def _get_permanent(self):
        return self.get('_permanent', False)

    def _set_permanent(self, value):
        self['_permanent'] = bool(value)

    permanent = property(_get_permanent, _set_permanent)
    del _get_permanent, _set_permanent


class _NullSession(Session):
    """"""Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """"""

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class _RequestContext(object):
    """"""The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """"""

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        if self.session is None:
            self.session = _NullSession()
        self.g = _RequestGlobals()
        self.flashes = None

        try:
            self.request.endpoint, self.request.view_args = \
                self.url_adapter.match()
        except HTTPException, e:
            self.request.routing_exception = e

    def __enter__(self):
        _request_ctx_stack.push(self)

    def __exit__(self, exc_type, exc_value, tb):
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.
        if tb is None or not self.app.debug:
            _request_ctx_stack.pop()


def url_for(endpoint, **values):
    """"""Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    Here some examples:

    ==================== ======================= =============================
    Active Module        Target Endpoint         Target Function
    ==================== ======================= =============================
    `None`               ``'index'``             `index` of the application
    `None`               ``'.index'``            `index` of the application
    ``'admin'``          ``'index'``             `index` of the `admin` module
    any                  ``'.index'``            `index` of the application
    any                  ``'admin.index'``       `index` of the `admin` module
    ==================== ======================= =============================

    Variable arguments that are unknown to the target endpoint are appended
    to the generated URL as query arguments.

    For more information, head over to the :ref:`Quickstart <url-building>`.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    :param _external: if set to `True`, an absolute URL is generated.
    """"""
    ctx = _request_ctx_stack.top
    if '.' not in endpoint:
        mod = ctx.request.module
        if mod is not None:
            endpoint = mod + '.' + endpoint
    elif endpoint.startswith('.'):
        endpoint = endpoint[1:]
    external = values.pop('_external', False)
    return ctx.url_adapter.build(endpoint, values, force_external=external)


def get_template_attribute(template_name, attribute):
    """"""Loads a macro (or variable) a template exports.  This can be used to
    invoke a macro from within Python code.  If you for example have a
    template named `_foo.html` with the following contents:

    .. sourcecode:: html+jinja

       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}

    You can access this from Python code like this::

        hello = get_template_attribute('_foo.html', 'hello')
        return hello('World')

    .. versionadded:: 0.2

    :param template_name: the name of the template
    :param attribute: the name of the variable of macro to acccess
    """"""
    return getattr(current_app.jinja_env.get_template(template_name).module,
                   attribute)


def flash(message):
    """"""Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.

    :param message: the message to be flashed.
    """"""
    session.setdefault('_flashes', []).append(message)


def get_flashed_messages():
    """"""Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """"""
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
    return flashes


def jsonify(*args, **kwargs):
    """"""Creates a :class:`~flask.Response` with the JSON representation of
    the given arguments with an `application/json` mimetype.  The arguments
    to this function are the same as to the :class:`dict` constructor.

    Example usage::

        @app.route('/_get_current_user')
        def get_current_user():
            return jsonify(username=g.user.username,
                           email=g.user.email,
                           id=g.user.id)

    This will send a JSON response like this to the browser::

        {
            ""username"": ""admin"",
            ""email"": ""admin@localhost"",
            ""id"": 42
        }

    This requires Python 2.6 or an installed version of simplejson.

    .. versionadded:: 0.2
    """"""
    if __debug__:
        _assert_have_json()
    return current_app.response_class(json.dumps(dict(*args, **kwargs),
        indent=None if request.is_xhr else 2), mimetype='application/json')


def send_file(filename_or_fp, mimetype=None, as_attachment=False,
              attachment_filename=None):
    """"""Sends the contents of a file to the client.  This will use the
    most efficient method available and configured.  By default it will
    try to use the WSGI server's file_wrapper support.  Alternatively
    you can set the application's :attr:`~Flask.use_x_sendfile` attribute
    to ``True`` to directly emit an `X-Sendfile` header.  This however
    requires support of the underlying webserver for `X-Sendfile`.

    By default it will try to guess the mimetype for you, but you can
    also explicitly provide one.  For extra security you probably want
    to sent certain files as attachment (HTML for instance).

    Please never pass filenames to this function from user sources without
    checking them first.  Something like this is usually sufficient to
    avoid security problems::

        if '..' in filename or filename.startswith('/'):
            abort(404)

    .. versionadded:: 0.2

    :param filename_or_fp: the filename of the file to send.  This is
                           relative to the :attr:`~Flask.root_path` if a
                           relative path is specified.
                           Alternatively a file object might be provided
                           in which case `X-Sendfile` might not work and
                           fall back to the traditional method.
    :param mimetype: the mimetype of the file if provided, otherwise
                     auto detection happens.
    :param as_attachment: set to `True` if you want to send this file with
                          a ``Content-Disposition: attachment`` header.
    :param attachment_filename: the filename for the attachment if it
                                differs from the file's filename.
    """"""
    if isinstance(filename_or_fp, basestring):
        filename = filename_or_fp
        file = None
    else:
        file = filename_or_fp
        filename = getattr(file, 'name', None)
    if filename is not None:
        filename = os.path.join(current_app.root_path, filename)
    if mimetype is None and (filename or attachment_filename):
        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]
    if mimetype is None:
        mimetype = 'application/octet-stream'

    headers = Headers()
    if as_attachment:
        if attachment_filename is None:
            if filename is None:
                raise TypeError('filename unavailable, required for '
                                'sending as attachment')
            attachment_filename = os.path.basename(filename)
        headers.add('Content-Disposition', 'attachment',
                    filename=attachment_filename)

    if current_app.use_x_sendfile and filename:
        if file is not None:
            file.close()
        headers['X-Sendfile'] = filename
        data = None
    else:
        if file is None:
            file = open(filename, 'rb')
        data = wrap_file(request.environ, file)

    return Response(data, mimetype=mimetype, headers=headers,
                    direct_passthrough=True)


def render_template(template_name, **context):
    """"""Renders a template from the template folder with the given
    context.

    :param template_name: the name of the template to be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """"""Renders a template from the given template source string
    with the given context.

    :param template_name: the sourcecode of the template to be
                          rendered
    :param context: the variables that should be available in the
                    context of the template.
    """"""
    current_app.update_template_context(context)
    return current_app.jinja_env.from_string(source).render(context)


def _default_template_ctx_processor():
    """"""Default template context processor.  Injects `request`,
    `session` and `g`.
    """"""
    reqctx = _request_ctx_stack.top
    return dict(
        request=reqctx.request,
        session=reqctx.session,
        g=reqctx.g
    )


def _assert_have_json():
    """"""Helper function that fails if JSON is unavailable.""""""
    if not json_available:
        raise RuntimeError('simplejson not installed')


def _get_package_path(name):
    """"""Returns the path to a package or cwd if that cannot be found.""""""
    try:
        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))
    except (KeyError, AttributeError):
        return os.getcwd()


# figure out if simplejson escapes slashes.  This behaviour was changed
# from one version to another without reason.
if not json_available or '\\/' not in json.dumps('/'):

    def _tojson_filter(*args, **kwargs):
        if __debug__:
            _assert_have_json()
        return json.dumps(*args, **kwargs).replace('/', '\\/')
else:
    _tojson_filter = json.dumps


class _PackageBoundObject(object):

    def __init__(self, import_name):
        #: the name of the package or module.  Do not change this once
        #: it was set by the constructor.
        self.import_name = import_name

        #: where is the app root located?
        self.root_path = _get_package_path(self.import_name)

    def open_resource(self, resource):
        """"""Opens a resource from the application's resource folder.  To see
        how this works, consider the following folder structure::

            /myapplication.py
            /schemal.sql
            /static
                /style.css
            /template
                /layout.html
                /index.html

        If you want to open the `schema.sql` file you would do the
        following::

            with app.open_resource('schema.sql') as f:
                contents = f.read()
                do_something_with(contents)

        :param resource: the name of the resource.  To access resources within
                         subfolders use forward slashes as separator.
        """"""
        if pkg_resources is None:
            return open(os.path.join(self.root_path, resource), 'rb')
        return pkg_resources.resource_stream(self.import_name, resource)


class _ModuleSetupState(object):

    def __init__(self, app, url_prefix=None):
        self.app = app
        self.url_prefix = url_prefix


class Module(_PackageBoundObject):
    """"""Container object that enables pluggable applications.  A module can
    be used to organize larger applications.  They represent blueprints that,
    in combination with a :class:`Flask` object are used to create a large
    application.

    A module is like an application bound to an `import_name`.  Multiple
    modules can share the same import names, but in that case a `name` has
    to be provided to keep them apart.  If different import names are used,
    the rightmost part of the import name is used as name.

    Here an example structure for a larger appliation::

        /myapplication
            /__init__.py
            /views
                /__init__.py
                /admin.py
                /frontend.py

    The `myapplication/__init__.py` can look like this::

        from flask import Flask
        from myapplication.views.admin import admin
        from myapplication.views.frontend import frontend

        app = Flask(__name__)
        app.register_module(admin, url_prefix='/admin')
        app.register_module(frontend)

    And here an example view module (`myapplication/views/admin.py`)::

        from flask import Module

        admin = Module(__name__)

        @admin.route('/')
        def index():
            pass

        @admin.route('/login')
        def login():
            pass

    For a gentle introduction into modules, checkout the
    :ref:`working-with-modules` section.
    """"""

    def __init__(self, import_name, name=None, url_prefix=None):
        if name is None:
            assert '.' in import_name, 'name required if package name ' \
                'does not point to a submodule'
            name = import_name.rsplit('.', 1)[1]
        _PackageBoundObject.__init__(self, import_name)
        self.name = name
        self.url_prefix = url_prefix
        self._register_events = []

    def route(self, rule, **options):
        """"""Like :meth:`Flask.route` but for a module.  The endpoint for the
        :func:`url_for` function is prefixed with the name of the module.
        """"""
        def decorator(f):
            self.add_url_rule(rule, f.__name__, f, **options)
            return f
        return decorator

    def add_url_rule(self, rule, endpoint, view_func=None, **options):
        """"""Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
        the :func:`url_for` function is prefixed with the name of the module.
        """"""
        def register_rule(state):
            the_rule = rule
            if state.url_prefix:
                the_rule = state.url_prefix + rule
            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
                                   view_func, **options)
        self._record(register_rule)

    def before_request(self, f):
        """"""Like :meth:`Flask.before_request` but for a module.  This function
        is only executed before each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def before_app_request(self, f):
        """"""Like :meth:`Flask.before_request`.  Such a function is executed
        before each request, even if outside of a module.
        """"""
        self._record(lambda s: s.app.before_request_funcs
            .setdefault(None, []).append(f))
        return f

    def after_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  This function
        is only executed after each request that is handled by a function of
        that module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(self.name, []).append(f))
        return f

    def after_app_request(self, f):
        """"""Like :meth:`Flask.after_request` but for a module.  Such a function
        is executed after each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.after_request_funcs
            .setdefault(None, []).append(f))
        return f

    def context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a modul.  This
        function is only executed for requests handled by a module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(self.name, []).append(f))
        return f

    def app_context_processor(self, f):
        """"""Like :meth:`Flask.context_processor` but for a module.  Such a
        function is executed each request, even if outside of the module.
        """"""
        self._record(lambda s: s.app.template_context_processors
            .setdefault(None, []).append(f))
        return f

    def _record(self, func):
        self._register_events.append(func)


class Flask(_PackageBoundObject):
    """"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see :func:`open_resource`.

    Usually you create a :class:`Flask` instance in your main module or
    in the `__init__.py` file of your package like this::

        from flask import Flask
        app = Flask(__name__)
    """"""

    #: the class that is used for request objects.  See :class:`~flask.request`
    #: for more information.
    request_class = Request

    #: the class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
    response_class = Response

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    permanent_session_lifetime = timedelta(days=31)

    #: Enable this if you want to use the X-Sendfile feature.  Keep in
    #: mind that the server has to support this.  This only affects files
    #: sent with the :func:`send_file` method.
    #:
    #: .. versionadded:: 0.2
    use_x_sendfile = False

    #: options that are passed directly to the Jinja2 environment
    jinja_options = ImmutableDict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']
    )

    def __init__(self, import_name):
        _PackageBoundObject.__init__(self, import_name)

        #: the debug flag.  Set this to `True` to enable debugging of
        #: the application.  In debug mode the debugger will kick in
        #: when an unhandled exception ocurrs and the integrated server
        #: will automatically reload the application if changes in the
        #: code are detected.
        self.debug = False

        #: a dictionary of all view functions registered.  The keys will
        #: be function names which are also used to generate URLs and
        #: the values are the function objects themselves.
        #: to register a view function, use the :meth:`route` decorator.
        self.view_functions = {}

        #: a dictionary of all registered error handlers.  The key is
        #: be the error code as integer, the value the function that
        #: should handle that error.
        #: To register a error handler, use the :meth:`errorhandler`
        #: decorator.
        self.error_handlers = {}

        #: a dictionary with lists of functions that should be called at the
        #: beginning of the request.  The key of the dictionary is the name of
        #: the module this function is active for, `None` for all requests.
        #: This can for example be used to open database connections or
        #: getting hold of the currently logged in user.  To register a
        #: function here, use the :meth:`before_request` decorator.
        self.before_request_funcs = {}

        #: a dictionary with lists of functions that should be called after
        #: each request.  The key of the dictionary is the name of the module
        #: this function is active for, `None` for all requests.  This can for
        #: example be used to open database connections or getting hold of the
        #: currently logged in user.  To register a function here, use the
        #: :meth:`before_request` decorator.
        self.after_request_funcs = {}

        #: a dictionary with list of functions that are called without argument
        #: to populate the template context.  They key of the dictionary is the
        #: name of the module this function is active for, `None` for all
        #: requests.  Each returns a dictionary that the template context is
        #: updated with.  To register a function here, use the
        #: :meth:`context_processor` decorator.
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(BaseConverter.to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
        self.url_map = Map()

        if self.static_path is not None:
            self.add_url_rule(self.static_path + '/<filename>',
                              build_only=True, endpoint='static')
            if pkg_resources is not None:
                target = (self.import_name, 'static')
            else:
                target = os.path.join(self.root_path, 'static')
            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {
                self.static_path: target
            })

        #: the Jinja2 environment.  It is created from the
        #: :attr:`jinja_options` and the loader that is returned
        #: by the :meth:`create_jinja_loader` function.
        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     **self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            get_flashed_messages=get_flashed_messages
        )
        self.jinja_env.filters['tojson'] = _tojson_filter

    def create_jinja_loader(self):
        """"""Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """"""
        if pkg_resources is None:
            return FileSystemLoader(os.path.join(self.root_path, 'templates'))
        return PackageLoader(self.import_name)

    def update_template_context(self, context):
        """"""Update the template context with some commonly used variables.
        This injects request, session and g into the template context.

        :param context: the context as a dictionary that is updated in place
                        to add extra variables.
        """"""
        funcs = self.template_context_processors[None]
        mod = _request_ctx_stack.top.request.module
        if mod is not None and mod in self.template_context_processors:
            funcs = chain(funcs, self.template_context_processors[mod])
        for func in funcs:
            context.update(func())

    def run(self, host='127.0.0.1', port=5000, **options):
        """"""Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        :param host: the hostname to listen on.  set this to ``'0.0.0.0'``
                     to have the server available externally as well.
        :param port: the port of the webserver
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See :func:`werkzeug.run_simple`
                        for more information.
        """"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    def test_client(self):
        """"""Creates a test client for this application.  For information
        about unit testing head over to :ref:`testing`.
        """"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_session(self, request):
        """"""Creates or opens a new session.  Default implementation stores all
        session data in a signed cookie.  This requires that the
        :attr:`secret_key` is set.

        :param request: an instance of :attr:`request_class`.
        """"""
        key = self.secret_key
        if key is not None:
            return Session.load_cookie(request, self.session_cookie_name,
                                       secret_key=key)

    def save_session(self, session, response):
        """"""Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved (a
                        :class:`~werkzeug.contrib.securecookie.SecureCookie`
                        object)
        :param response: an instance of :attr:`response_class`
        """"""
        expires = None
        if session.permanent:
            expires = datetime.utcnow() + self.permanent_session_lifetime
        session.save_cookie(response, self.session_cookie_name,
                            expires=expires, httponly=True)

    def register_module(self, module, **options):
        """"""Registers a module with this application.  The keyword argument
        of this function are the same as the ones for the constructor of the
        :class:`Module` class and will override the values of the module if
        provided.
        """"""
        options.setdefault('url_prefix', module.url_prefix)
        state = _ModuleSetupState(self, **options)
        for func in module._register_events:
            func(state)

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """"""Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        .. versionchanged:: 0.2
           `view_func` parameter added.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object
        """"""
        if endpoint is None:
            assert view_func is not None, 'expected view func if endpoint ' \
                                          'is not provided.'
            endpoint = view_func.__name__
        options['endpoint'] = endpoint
        options.setdefault('methods', ('GET',))
        self.url_map.add(Rule(rule, **options))
        if view_func is not None:
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """"""A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'

        Variables parts in the route can be specified with angular
        brackets (``/user/<username>``).  By default a variable part
        in the URL accepts any string without a slash however a different
        converter can be specified as well by using ``<converter:name>``.

        Variable parts are passed to the view function as keyword
        arguments.

        The following converters are possible:

        =========== ===========================================
        `int`       accepts integers
        `float`     like `int` but for floating point values
        `path`      like the default but also accepts slashes
        =========== ===========================================

        Here some examples::

            @app.route('/')
            def index():
                pass

            @app.route('/<username>')
            def show_user(username):
                pass

            @app.route('/post/<int:post_id>')
            def show_post(post_id):
                pass

        An important detail to keep in mind is how Flask deals with trailing
        slashes.  The idea is to keep each URL unique so the following rules
        apply:

        1. If a rule ends with a slash and is requested without a slash
           by the user, the user is automatically redirected to the same
           page with a trailing slash attached.
        2. If a rule does not end with a trailing slash and the user request
           the page with a trailing slash, a 404 not found is raised.

        This is consistent with how web servers deal with static files.  This
        also makes it possible to use relative link targets safely.

        The :meth:`route` decorator accepts a couple of other arguments
        as well:

        :param rule: the URL rule as string
        :param methods: a list of methods this rule should be limited
                        to (``GET``, ``POST`` etc.).  By default a rule
                        just listens for ``GET`` (and implicitly ``HEAD``).
        :param subdomain: specifies the rule for the subdoain in case
                          subdomain matching is in use.
        :param strict_slashes: can be used to disable the strict slashes
                               setting for this rule.  See above.
        :param options: other options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.
        """"""
        def decorator(f):
            self.add_url_rule(rule, None, f, **options)
            return f
        return decorator

    def errorhandler(self, code):
        """"""A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404

        You can also register a function as error handler without using
        the :meth:`errorhandler` decorator.  The following example is
        equivalent to the one above::

            def page_not_found():
                return 'This page does not exist', 404
            app.error_handlers[404] = page_not_found

        :param code: the code as integer for the handler
        """"""
        def decorator(f):
            self.error_handlers[code] = f
            return f
        return decorator

    def template_filter(self, name=None):
        """"""A decorator that is used to register custom template filter.
        You can specify a name for the filter, otherwise the function
        name will be used. Example::

          @app.template_filter()
          def reverse(s):
              return s[::-1]

        :param name: the optional name of the filter, otherwise the
                     function name will be used.
        """"""
        def decorator(f):
            self.jinja_env.filters[name or f.__name__] = f
            return f
        return decorator

    def before_request(self, f):
        """"""Registers a function to run before each request.""""""
        self.before_request_funcs.setdefault(None, []).append(f)
        return f

    def after_request(self, f):
        """"""Register a function to be run after each request.""""""
        self.after_request_funcs.setdefault(None, []).append(f)
        return f

    def context_processor(self, f):
        """"""Registers a template context processor function.""""""
        self.template_context_processors[None].append(f)
        return f

    def dispatch_request(self):
        """"""Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """"""
        req = _request_ctx_stack.top.request
        try:
            if req.routing_exception is not None:
                raise req.routing_exception
            return self.view_functions[req.endpoint](**req.view_args)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        :class:`tuple`          the response object is created with the
                                contents of the tuple as arguments
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        ======================= ===========================================

        :param rv: the return value from the view function
        """"""
        if rv is None:
            raise ValueError('View function did not return a response')
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """"""Called before the actual request dispatching and will
        call every as :meth:`before_request` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """"""
        funcs = self.before_request_funcs.get(None, ())
        mod = request.module
        if mod and mod in self.before_request_funcs:
            funcs = chain(funcs, self.before_request_funcs[mod])
        for func in funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """"""Can be overridden in order to modify the response object
        before it's sent to the WSGI server.  By default this will
        call all the :meth:`after_request` decorated functions.

        :param response: a :attr:`response_class` object.
        :return: a new response object or the same, has to be an
                 instance of :attr:`response_class`.
        """"""
        ctx = _request_ctx_stack.top
        mod = ctx.request.module
        if not isinstance(ctx.session, _NullSession):
            self.save_session(ctx.session, response)
        funcs = ()
        if mod and mod in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[mod])
        if None in self.after_request_funcs:
            funcs = chain(funcs, self.after_request_funcs[None])
        for handler in funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """"""The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """"""
        with self.request_context(environ):
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
            response = self.make_response(rv)
            response = self.process_response(response)
            return response(environ, start_response)

    def request_context(self, environ):
        """"""Creates a request context from the given environment and binds
        it to the current context.  This must be used in combination with
        the `with` statement because the request is only bound to the
        current context for the duration of the `with` block.

        Example usage::

            with app.request_context(environ):
                do_something_with(request)

        :param environ: a WSGI environment
        """"""
        return _RequestContext(self, environ)

    def test_request_context(self, *args, **kwargs):
        """"""Creates a WSGI environment from the given values (see
        :func:`werkzeug.create_environ` for more information, this
        function accepts the same arguments).
        """"""
        return self.request_context(create_environ(*args, **kwargs))

    def __call__(self, environ, start_response):
        """"""Shortcut for :attr:`wsgi_app`.""""""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)
","@@ -1113,7 +1113,7 @@ class Flask(_PackageBoundObject):
             with app.request_context(environ):
                 do_something_with(request)
 
-        :params environ: a WSGI environment
+        :param environ: a WSGI environment
         """"""
         return _RequestContext(self, environ)
 
",add missing package_resources dependency,add missing package_resources dependency,add missing package_resources dependency,llm_rectified,0.0,4,False,0,0,0,0,0,0,0,0,0
93a8ca02822d07cd9f13495f53d27ab22e9adf3a,Fixed some minor typos throughout docs.,becomingbig.rst,".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bring those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expand on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large application consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here are some suggestions for how Flask can be modified to better 
accomodate large-scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifing the target functions explicitly or by name and importing
    them when needed.
-   switch to explicit request object passing.  This requires more typing
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directly into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does Flask not do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code and something of larger scale.  At some
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and harder to get started with.
",".. _becomingbig:

Becoming Big
============

Your application is becoming more and more complex?  Flask is really not
designed for large scale applications and does not attempt to do so, but
that does not mean you picked the wrong tool in the first place.

Flask is powered by Werkzeug and Jinja2, two libraries that are in use at
a number of large websites out there and all Flask does is bring those
two together.  Being a microframework, Flask is literally a single file.
What that means for large applications is that it's probably a good idea
to take the code from Flask and put it into a new module within the
applications and expand on that.

What Could Be Improved?
-----------------------

For instance it makes a lot of sense to change the way endpoints (the
names of the functions / URL rules) are handled to also take the module
name into account.  Right now the function name is the URL name, but
imagine you have a large application consisting of multiple components.
In that case, it makes a lot of sense to use dotted names for the URL
endpoints.

Here are some suggestions for how Flask can be modified to better 
accommodate large-scale applications:

-   implement dotted names for URL endpoints
-   get rid of the decorator function registering which causes a lot
    of troubles for applications that have circular dependencies.  It
    also requires that the whole application is imported when the system
    initializes or certain URLs will not be available right away.   A
    better solution would be to have one module with all URLs in there and
    specifying the target functions explicitly or by name and importing
    them when needed.
-   switch to explicit request object passing.  This requires more typing
    (because you now have something to pass around) but it makes it a
    whole lot easier to debug hairy situations and to test the code.
-   integrate the `Babel`_ i18n package or `SQLAlchemy`_ directly into the
    core framework.

.. _Babel: http://babel.edgewall.org/
.. _SQLAlchemy: http://www.sqlalchemy.org/

Why does Flask not do all that by Default?
------------------------------------------

There is a huge difference between a small application that only has to
handle a couple of requests per second and with an overall code complexity
of less than 4000 lines of code and something of larger scale.  At some
point it becomes important to integrate external systems, different
storage backends and more.

If Flask was designed with all these contingencies in mind, it would be a
much more complex framework and harder to get started with.
","@@ -25,7 +25,7 @@ In that case, it makes a lot of sense to use dotted names for the URL
 endpoints.
 
 Here are some suggestions for how Flask can be modified to better 
-accomodate large-scale applications:
+accommodate large-scale applications:
 
 -   implement dotted names for URL endpoints
 -   get rid of the decorator function registering which causes a lot
@@ -33,7 +33,7 @@ accomodate large-scale applications:
     also requires that the whole application is imported when the system
     initializes or certain URLs will not be available right away.   A
     better solution would be to have one module with all URLs in there and
-    specifing the target functions explicitly or by name and importing
+    specifying the target functions explicitly or by name and importing
     them when needed.
 -   switch to explicit request object passing.  This requires more typing
     (because you now have something to pass around) but it makes it a
",add more info about the module name,add more info about the module name,add more info about the module name,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
93a8ca02822d07cd9f13495f53d27ab22e9adf3a,Fixed some minor typos throughout docs.,design.rst,"Design Decisions in Flask
=========================

If you are curious why Flask does certain things the way it does and not
differently, this section is for you.  This should give you an idea about
some of the design decisions that may appear arbitrary and surprising at
first, especially in direct comparison with other frameworks.


The Explicit Application Object
-------------------------------

A Python web application based on WSGI has to have one central callable
object that implements the actual application.  In Flask this is an
instance of the :class:`~flask.Flask` class.  Each Flask application has
to create an instance of this class itself and pass it the name of the
module, but why can't Flask do that itself?

Without such an explicit application object the following code::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def index():
        return 'Hello World!'

Would look like this instead::

    from hypothetical_flask import route

    @route('/')
    def index():
        return 'Hello World!'

There are three major reasons for this.  The most important one is that
implicit application objects require that there may only be one class at
the time.  There are ways to fake multiple application with a single
application object, like maintaining a stack of applications, but this
causes some problems I won't outline here in detail.  Now the question is:
when does a microframework need more than one application at the same
time?  A good example for this is unittesting.  When you want to test
something it can be very helpful to create a minimal application to test
specific behavior.  When the application object is deleted everything it
allocated will be freed again.

Another thing that becomes possible when you have an explicit object laying
around in your code is that you can subclass the base class
(:class:`~flask.Flask`) to alter specific behaviour.  This would not be
possible without hacks if the object were created ahead of time for you
based on a class that is not exposed to you.

But there is another very important reason why Flask depends on an
explicit instanciation of that class: the package name.  Whenever you
create a Flask instance you usually pass it `__name__` as package name.
Flask depends on that information to properly load resources relative
to your module.  With Python's outstanding support for reflection it can
then access the package to figure out where the templates and static files
are stored (see :meth:`~flask.Flask.open_resource`).  Now obviously there
are frameworks around that do not need any configuration and will still be
able to load templates relative to your application module.  But they have
to use the current working directory for that, which is a very unreliable
way to determine where the application is.  The current working directory
is process-wide and if you are running multiple applications in one
process (which could happen in a webserver without you knowing) the paths
will be off.  Worse: many webservers do not set the working directory to
the directory of your application but to the document root which does not
have to be the same folder.

The third reason is ""explicit is better than implicit"".  That object is
your WSGI application, you don't have to remember anything else.  If you
want to apply a WSGI middleware, just wrap it and you're done (though
there are better ways to do that so that you do not lose the reference
to the application object :meth:`~flask.Flask.wsgi_app`).

One Template Engine
-------------------

Flask decides on one template engine: Jinja2.  Why doesn't Flask have a
pluggable template engine interface?  You can obviously use a different
template engine, but Flask will still configure Jinja2 for you.  While
that limitation that Jinja2 is *always* configured will probably go away,
the decision to bundle one template engine and use that will not.

Template engines are like programming languages and each of those engines
has a certain understanding about how things work.  On the surface they
all work the same: you tell the engine to evaluate a template with a set
of variables and take the return value as string.

But that's about where similarities end.  Jinja2 for example has an
extensive filter system, a certain way to do template inheritance, support
for reusable blocks (macros) that can be used from inside templates and
also from Python code, uses unicode for all operations, supports
iterative template rendering, configurable syntax and more.  On the other
hand an engine like Genshi is based on XML stream evaluation, template
inheritance by taking the availability of XPath into account and more.
Mako on the other hand treats templates similar to Python modules.

When it comes to connecting a template engine with an application or 
framework there is more than just rendering templates.  For instance,
Flask uses Jinja2's extensive autoescaping support.  Also it provides 
ways to access macros from Jinja2 templates.

A template abstraction layer that would not take the unique features of
the template engines away is a science on its own and a too large
undertaking for a microframework like Flask.


Micro with Dependencies
-----------------------

Why does Flask call itself a microframework and yet it depends on two
libraries (namely Werkzeug and Jinja2).  Why shouldn't it?  If we look
over to the Ruby side of web development there we have a protocol very
similar to WSGI.  Just that it's called Rack there, but besides that it
looks very much like a WSGI rendition for Ruby.  But nearly all
applications in Ruby land do not work with Rack directly, but on top of a
library with the same name.  This Rack library has two equivalents in
Python: WebOb (formerly Paste) and Werkzeug.  Paste is still around but
from my understanding it's sort of deprecated in favour of WebOb.  The
development of WebOb and Werkzeug started side by side with similar ideas
in mind: be a good implementation of WSGI for other applications to take
advantage.

Flask is a framework that takes advantage of the work already done by
Werkzeug to properly interface WSGI (which can be a complex task at
times).  Thanks to recent developments in the Python package
infrastructure, packages with depencencies are no longer an issue and
there are very few reasons against having libraries that depend on others.


Thread Locals
-------------

Flask uses thread local objects (context local objects in fact, they
support greenlet contexts as well) for request, session and an extra
object you can put your own things on (:data:`~flask.g`).  Why is that and
isn't that a bad idea?

Yes it is usually not such a bright idea to use thread locals.  They cause
troubles for servers that are not based on the concept of threads and make
large applications harder to maintain.  However Flask is just not designed
for large applications or asyncronous servers.  Flask wants to make it
quick and easy to write a traditional web application.

Also see the :ref:`becomingbig` section of the documentation for some
inspiration for larger applications based on Flask.
","Design Decisions in Flask
=========================

If you are curious why Flask does certain things the way it does and not
differently, this section is for you.  This should give you an idea about
some of the design decisions that may appear arbitrary and surprising at
first, especially in direct comparison with other frameworks.


The Explicit Application Object
-------------------------------

A Python web application based on WSGI has to have one central callable
object that implements the actual application.  In Flask this is an
instance of the :class:`~flask.Flask` class.  Each Flask application has
to create an instance of this class itself and pass it the name of the
module, but why can't Flask do that itself?

Without such an explicit application object the following code::

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def index():
        return 'Hello World!'

Would look like this instead::

    from hypothetical_flask import route

    @route('/')
    def index():
        return 'Hello World!'

There are three major reasons for this.  The most important one is that
implicit application objects require that there may only be one class at
the time.  There are ways to fake multiple application with a single
application object, like maintaining a stack of applications, but this
causes some problems I won't outline here in detail.  Now the question is:
when does a microframework need more than one application at the same
time?  A good example for this is unittesting.  When you want to test
something it can be very helpful to create a minimal application to test
specific behavior.  When the application object is deleted everything it
allocated will be freed again.

Another thing that becomes possible when you have an explicit object laying
around in your code is that you can subclass the base class
(:class:`~flask.Flask`) to alter specific behaviour.  This would not be
possible without hacks if the object were created ahead of time for you
based on a class that is not exposed to you.

But there is another very important reason why Flask depends on an
explicit instantiation of that class: the package name.  Whenever you
create a Flask instance you usually pass it `__name__` as package name.
Flask depends on that information to properly load resources relative
to your module.  With Python's outstanding support for reflection it can
then access the package to figure out where the templates and static files
are stored (see :meth:`~flask.Flask.open_resource`).  Now obviously there
are frameworks around that do not need any configuration and will still be
able to load templates relative to your application module.  But they have
to use the current working directory for that, which is a very unreliable
way to determine where the application is.  The current working directory
is process-wide and if you are running multiple applications in one
process (which could happen in a webserver without you knowing) the paths
will be off.  Worse: many webservers do not set the working directory to
the directory of your application but to the document root which does not
have to be the same folder.

The third reason is ""explicit is better than implicit"".  That object is
your WSGI application, you don't have to remember anything else.  If you
want to apply a WSGI middleware, just wrap it and you're done (though
there are better ways to do that so that you do not lose the reference
to the application object :meth:`~flask.Flask.wsgi_app`).

One Template Engine
-------------------

Flask decides on one template engine: Jinja2.  Why doesn't Flask have a
pluggable template engine interface?  You can obviously use a different
template engine, but Flask will still configure Jinja2 for you.  While
that limitation that Jinja2 is *always* configured will probably go away,
the decision to bundle one template engine and use that will not.

Template engines are like programming languages and each of those engines
has a certain understanding about how things work.  On the surface they
all work the same: you tell the engine to evaluate a template with a set
of variables and take the return value as string.

But that's about where similarities end.  Jinja2 for example has an
extensive filter system, a certain way to do template inheritance, support
for reusable blocks (macros) that can be used from inside templates and
also from Python code, uses unicode for all operations, supports
iterative template rendering, configurable syntax and more.  On the other
hand an engine like Genshi is based on XML stream evaluation, template
inheritance by taking the availability of XPath into account and more.
Mako on the other hand treats templates similar to Python modules.

When it comes to connecting a template engine with an application or 
framework there is more than just rendering templates.  For instance,
Flask uses Jinja2's extensive autoescaping support.  Also it provides 
ways to access macros from Jinja2 templates.

A template abstraction layer that would not take the unique features of
the template engines away is a science on its own and a too large
undertaking for a microframework like Flask.


Micro with Dependencies
-----------------------

Why does Flask call itself a microframework and yet it depends on two
libraries (namely Werkzeug and Jinja2).  Why shouldn't it?  If we look
over to the Ruby side of web development there we have a protocol very
similar to WSGI.  Just that it's called Rack there, but besides that it
looks very much like a WSGI rendition for Ruby.  But nearly all
applications in Ruby land do not work with Rack directly, but on top of a
library with the same name.  This Rack library has two equivalents in
Python: WebOb (formerly Paste) and Werkzeug.  Paste is still around but
from my understanding it's sort of deprecated in favour of WebOb.  The
development of WebOb and Werkzeug started side by side with similar ideas
in mind: be a good implementation of WSGI for other applications to take
advantage.

Flask is a framework that takes advantage of the work already done by
Werkzeug to properly interface WSGI (which can be a complex task at
times).  Thanks to recent developments in the Python package
infrastructure, packages with dependencies are no longer an issue and
there are very few reasons against having libraries that depend on others.


Thread Locals
-------------

Flask uses thread local objects (context local objects in fact, they
support greenlet contexts as well) for request, session and an extra
object you can put your own things on (:data:`~flask.g`).  Why is that and
isn't that a bad idea?

Yes it is usually not such a bright idea to use thread locals.  They cause
troubles for servers that are not based on the concept of threads and make
large applications harder to maintain.  However Flask is just not designed
for large applications or asynchronous servers.  Flask wants to make it
quick and easy to write a traditional web application.

Also see the :ref:`becomingbig` section of the documentation for some
inspiration for larger applications based on Flask.
","@@ -51,7 +51,7 @@ possible without hacks if the object were created ahead of time for you
 based on a class that is not exposed to you.
 
 But there is another very important reason why Flask depends on an
-explicit instanciation of that class: the package name.  Whenever you
+explicit instantiation of that class: the package name.  Whenever you
 create a Flask instance you usually pass it `__name__` as package name.
 Flask depends on that information to properly load resources relative
 to your module.  With Python's outstanding support for reflection it can
@@ -125,7 +125,7 @@ advantage.
 Flask is a framework that takes advantage of the work already done by
 Werkzeug to properly interface WSGI (which can be a complex task at
 times).  Thanks to recent developments in the Python package
-infrastructure, packages with depencencies are no longer an issue and
+infrastructure, packages with dependencies are no longer an issue and
 there are very few reasons against having libraries that depend on others.
 
 
@@ -140,7 +140,7 @@ isn't that a bad idea?
 Yes it is usually not such a bright idea to use thread locals.  They cause
 troubles for servers that are not based on the concept of threads and make
 large applications harder to maintain.  However Flask is just not designed
-for large applications or asyncronous servers.  Flask wants to make it
+for large applications or asynchronous servers.  Flask wants to make it
 quick and easy to write a traditional web application.
 
 Also see the :ref:`becomingbig` section of the documentation for some
",add more info about the object creation,add more info about the object creation,add more info about the object creation,llm_rectified,0.0,7,False,0,0,0,0,0,0,0,0,0
